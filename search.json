[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "통계와 분석",
    "section": "",
    "text": "안내\n이 책은 통계와 분석의 강의노트입니다. 개인적으로 공부하는 것이면 괜찮습니다. 다른 목적으로 이 책을 사용하려면 저자와 상의해야 합니다.\n류춘렬, cryu@kookmin.ac.kr\n이 강의에서 배우는 것은 아래와 같습니다. R을 적극적으로 활용한다는 점에서 데이터 사이언스 분야와 접근이 같지만 사회과학적 통계 이론과 데이터 분석에도 중점을 두므로 두 분야의 균형을 이룹니다.\n\nR과 R Studio를 이용한 통계 기법\nQuarto를 이용한 보고서 작성\n데이터 다루기: 가져오기, 내보내기, 재구성, 변환\n데이터 분석: 기술적 통계, 데이터 시각화\n통계 이론: 확률분포와 표집분포의 이해, 여러 종류의 분포\n통계적 추론: 가설을 검정하고 신뢰 구간을 계산하는 현대적 기법\n예측적 모델 수립: 예측과 분류, 전망을 위한 회귀 모델\n\n데이터 사이언스 분야는 Thulin (2021) https://modernstatisticswithr.com을 꽤 참고했습니다.\n이 노트는 입말로 썼습니다. 내가 생각하기에, 입말이 글말보다 이해가 빠릅니다. 처음은 어색하지만 익숙해지면 편합니다.\n이 강의 노트를 편집하는데 posit (2023) (사이트)와 Yihui Xie (2019) (사이트) 등의 여러 사이트에서 많은 도움을 받았습니다.\n한 학기 동안 잘 달려갑시다!\n참고로 이 강의 노트는 Quarto를 이용해서 작성하였습니다.\n\n\n\n\n\n\nDark Mode 버튼\n\n\n\n왼쪽 위 통계와 분석 오른편에 Dark Mode 토글 버튼이 있습니다. 밝은 화면이 눈부시면 어두운 화면으로 바꾸세요.\n\n\n\n\n\n\nposit. (2023). Welcome to Quarto. https://quarto.org\n\n\nThulin, M. (2021). Modern statistics with R. Eos Chasma Press. https://modernstatisticswithr.com/\n\n\nYihui Xie, G. G., J. J. Allaire. (2019). R Markdown: The definitive guide. Chapman & Hall/CRC. https://bookdown.org/yihui/rmarkdown/"
  },
  {
    "objectID": "introduction.html#r의-세상으로",
    "href": "introduction.html#r의-세상으로",
    "title": "1  강의 소개",
    "section": "1.1 R의 세상으로",
    "text": "1.1 R의 세상으로\nR은 여러 통계 프로그램과 다릅니다. 공짜고 효율적이며 빠르고 최신이에요. 거대한 이용자 공동체가 서로 도우며 R을 개선하고 있습니다. R은 그 어떤 통계 프로그램보다 더 많은 분석 기법을 포함하고 있어서 다양한 학문 분야에서 사용합니다. 소통학이나 정치학, 천문학, 의학 등등. 유사한 분석을 반복하기도 아주 쉬워요. R은 통계학자가 개발해서 데이터를 다루기가 여타 프로그램보다 편합니다. 여러 면에서 현존 최강이라고 불러도 될 정도지요.\n더구나 R Studio라는 IDE (통합개발환경: Integrated Development Environment)를 사용해서 R 프로그래밍을 쉽게 할 뿐만 아니라 다른 패키지를 사용하기 편합니다. Quarto 패키지를 이용해서 문서나 윕페이지, 보고서 등을 아주 편하게 만들 수 있습니다. 데이터를 교체해도 만들어놓은 파일을 사용해서 새 보고서로 변환하는 작업도 자동적이어서 업무 수행 능력이 획기적으로 향상합니다."
  },
  {
    "objectID": "introduction.html#사전-지식",
    "href": "introduction.html#사전-지식",
    "title": "1  강의 소개",
    "section": "1.2 사전 지식",
    "text": "1.2 사전 지식\n이 강의를 듣는데 통계에 관한 사전 지식은 필요 없어요. 원래 초보자를 위한 것이라 차근차근하게 밑바닥부터 나갈 거에요. 물론 컴퓨터 프로그래밍에 대한 사전 지식은 더 필요 없지요.\n처음부터 끝까지 차례대로 공부할 필요는 없어요. 중간에 건너 뛰어려면 그래도 됩니다. 그런데 R을 배우려면 R을 직접 사용해보는 게 필요하니까 해당 세션의 R 실습 문제는 꼭 풀어보는 게 좋아요."
  },
  {
    "objectID": "introduction.html#균형",
    "href": "introduction.html#균형",
    "title": "1  강의 소개",
    "section": "1.3 균형",
    "text": "1.3 균형\nR을 이용해서 통계에 접근하는 길은 대체로 두 가지로 나누어져요. 하나는 사회과학의 전통적 통계를 공부하는 것이고 다른 하나는 요즘 뜨는 데이터 사이언스를 공부하는 거에요. 이 강의에서는 양쪽을 다 다루지만 그래도 사회과학의 전통적 통계 쪽으로 기울기는 할 겁니다.\nchatGPT에 사회과학과 데이터 분석 통계의 접근법을 합쳐서 가르치는 법을 물었는데 이렇게 두 가지를 말하네요. 맞는 말인 듯해서 나름대로 내용에 반영하려고 노력했습니다.\n\n핵심 개념에 집중하세요: 사회과학 및 데이터 분석 모두 통계학의 핵심 개념에 대한 강한 기초를 요구합니다. 먼저 이러한 핵심 개념에 집중하여 확률, 분포, 가설 검정 및 회귀 분석과 같은 핵심 개념을 가르치세요. 학생들이 이러한 개념을 이해한 후에는 전문적인 주제로 넘어가도록 합니다.\n차이점을 강조하세요: 두 접근 방식 모두 통계적 방법을 사용하지만, 사회과학과 데이터 분석에서 이러한 방법의 초점과 적용이 다를 수 있습니다. 학생들이 어떤 접근 방식을 사용해야 하는지 이해하도록 이러한 차이점을 강조하세요."
  },
  {
    "objectID": "introduction.html#보고서와-문서-작성",
    "href": "introduction.html#보고서와-문서-작성",
    "title": "1  강의 소개",
    "section": "1.4 보고서와 문서 작성",
    "text": "1.4 보고서와 문서 작성\n더구나 최근에는 데이터 분석과 문서 작성이 하나로 통합하는 추세입니다. 빅데이터를 이용한 보고서 작성이 이제 당연시되고 그 작업을 RStudio가 하니까 직장에서 R과 RStudio를 다루는 능력이 필요합니다.\n인공지능 chatGPT의 도움이 이런 추세를 가속화합니다. 예전에는 프로그래밍 능력이 일정 수준 이상이어야 보고서 작성을 할 수 있었지만 이제는 chapGPT가 기본 프로그램을 짜주니까 어느 정도의 R 지식과 학습이 있으면 그걸 보고 수정해서 작업을 완료할 수 있습니다. 구글 번역을 예로 들면, 영어 지식이 낮으면 아무리 구글 번역을 해도 그걸로 한글을 영어로 번역하기 어렵습니다. 그러나 영어 지식이 일정 수준 이상이라면 구글 번역을 초벌로 삼아서 한글을 영어로 번역한 문서를 만들어내기 쉽습니다\n\n\nTable 1.1: 강의의 구조: 세 부분\n\n\n\n\n\n\n\nR\n통계 이론\n데이터 분석\n\n\n\n\n\nR Studio\nR script (분석)\nQuarto (보고서)\n\n\n확률변수와 분포\n추론통계\n모델 만들기\n\n\n데이터 다루기\n통계 프로그래밍\n시각적 데이터"
  },
  {
    "objectID": "basic-concepts.html#모집단과-표본",
    "href": "basic-concepts.html#모집단과-표본",
    "title": "2  통계의 기초 개념",
    "section": "2.1 모집단과 표본",
    "text": "2.1 모집단과 표본\n\n2.1.1 모집단과 표본의 개념\n우리가 관심을 가지고 조사하려는 전체 집단을 모집단 population 이라고 합니다. 대한민국 국민, 20대 한국인, 한국대학교 학생, 2023년 통계와 분석 수강생 등이 모집단이 될 수 있지요. 사람이 아닌 사물이나 단체 등도 모집단이 될 수 있어요. 한국전자에서 생산하는 텔레비전, 전세계 국가 등이 그런 모집단의 예입니다. 이론적으로 무한히 많은 개체를 가진 모집단을 무한모집단이라하고, 유한한 수의 개체를 가진 모집단을 유한모집단이라고 합니다.\n모집단이 아주 크거나 기타 이유로 모집단 전체를 조사하기가 어려울 수 있어요. 이럴 때 모집단에서 일부를 뽑아 조사하여 모집단의 속성을 추정할 수 있는데 이런 일부집단을 표본 sample 이라고 합니다. 표본이 포함한 개체의 수를 표본 크기 sample size 라고 합니다.\n모집단을 전부 조사하는 것이 전수조사 Census 입니다. 표본을 조사하는 건 표본조사입니다. 통계는 표본조사를 통해 얻은 결과를 모집단에 일반화시킵니다. 전수조사는 시간과 노력이 많이 드는 단점이 있지만, 여러 장점도 있습니다.\n\n모집단에 대해 정확히 알게 된다.\n희귀한 사례에 대해 조사하기 쉽다.\n표본조사의 결과를 더 정확히 추정하게 해준다.\n\n표본조사는 전수조사에 비하여 이런 장점이 있습니다.\n\n시간과 노력, 비용을 절약해서 효율적이다.\n적은 수를 조사하므로 많은 항목을 상세히 조사할 있다.\n전수조사의 미진한 부분이나 추가할 부분을 보완할 수 있다.\n\n모집단의 속성을 측정한 측정값들을 통계처리한 수치를, 즉 평균이나 표준편차 등등을 모수 parameter 라고 합니다. 표본의 속성을 측정한 측정값들을 통계처리한 수치를 통계량 statistic 이라고 합니다. 통계량은 방법의 의미와 계산된 값의 의미, 양쪽으로 모두 사용됩니다. (평균을 예로 들면, 방법; ‘평균은 대표성이 좋다’, 값; ‘키 평균은 172cm다’) 통계량은 모수를 추정하려고 존재합니다. 통상 모수는 그리스 문자로 적고 통계량은 영어로 적습니다.\n\n\nTable 2.1: 모수와 통계량의 표기\n\n\n\n\n\n\n\n\n\n\n통계\n|\n모수 (발음)\n\n통계량\n\n\n\n\n\n평균\n|\n\\(\\mu\\) ( mu )\n모평균\n\\(m\\), \\(\\bar x\\)\n표본평균\n\n\n분산\n|\n\\(\\sigma^{2}\\) ( - )\n모분산\n\\(s^{2}\\)\n표본분산\n\n\n표준편차\n|\n\\(\\sigma\\) ( sigma )\n모표준편차\n\\(s\\)\n표본표준편차\n\n\n상관계수\n|\n\\(\\rho\\) ( rho )\n모상관계수\n\\(r\\)\n표본상관계수\n\n\n\n\n\n\nTable 2.2: 통계에 사용하는 그리스 문자\n\n\n그리스어\n발음\n그리스어\n발음\n그리스어\n발음\n\n\n\n\n\\(\\alpha\\)\nalpha\n\\(\\iota\\)\niota\n\\(\\sigma\\)\nsigma\n\n\n\\(\\beta\\)\nbeta\n\\(\\kappa\\)\nkappa\n\\(\\tau\\)\ntau\n\n\n\\(\\gamma\\)\ngamma\n\\(\\lambda\\)\nlambda\n\\(\\upsilon\\)\nupsilon\n\n\n\\(\\epsilon\\)\nepsilon\n\\(\\mu\\)\nmu\n\\(\\phi\\)\nphi\n\n\n\\(\\zeta\\)\nzeta\n\\(\\nu\\)\nnu\n\\(\\chi\\)\nchi\n\n\n\\(\\sigma\\)\nsigma\n\\(\\xi\\)\nxi\n\\(\\psi\\)\npsi\n\n\n\\(\\eta\\)\neta\n\\(\\pi\\)\npi\n\\(\\omega\\)\nomega\n\n\n\\(\\theta\\)\ntheta\n\\(\\rho\\)\nrho\n\n\n\n\n\n\n모집단, 표본, 전수조사, 표본조사, 무한모집단, 유한모집단, 표본 크기, 모수, 통계량"
  },
  {
    "objectID": "basic-concepts.html#기술통계학과-추론통계학",
    "href": "basic-concepts.html#기술통계학과-추론통계학",
    "title": "2  통계의 기초 개념",
    "section": "2.2 기술통계학과 추론통계학",
    "text": "2.2 기술통계학과 추론통계학\n우리가 관심을 가지는 집단을 조사하여 그 집단의 특성을 수치로 표현하는 방법을 기술통계학 descriptive statistics 이라고 합니다. 기술통계학은 데이터를 요약하고 단순화하여 조사한 대상의 특성을 유용한 형태의 특성치로 가공하여 내놓습니다. 이러한 특성치는 평균, 표준편차, 분산, 비율, 회귀계수 등이 있습니다. 표본을 조사하는 이유는 모집단을 알기 위함입니다. 표본조사의 결과인 통계량을 이용하여 모수를 추정하는 방법을 추론통계학 inferential statistics 이라고 합니다.\n기술통계학은 대체로 특성을 있는 그대로 기술하는 것이라서 이해하기가 쉽습니다. 그러나 추론통계학은 추론에 이론적 뒷받침이 필요해서 지적 노력이 조금 필요합니다.\n통계량에서 모수를 추정하는 과정에 여러 요소들이 관여하므로 합리적인 방법을 추구해야 합니다. 예를 들어, 표본 크기가 추론 결과에 영향을 줄 수 있습니다. 그래서 확률 probability 이론이 끼여듭니다. 표본의 통계량에서 모집단의 모수를 추론할 때, 그 추론이 얼마나 신뢰할 만한가 하는 정도를 확률 이론으로 계산하는 겁니다. 예를 들어, 모집단의 키 평균이 170cm이라고 가정하고 (\\(\\mu\\)=170), 그 모집단에서 100명의 표본을 뽑아 키 평균을 계산하면 172cm가 (\\(\\bar{x}\\)=172) 나올 확률이 얼마나 되는가? 이렇게 되는 겁니다.\n신문에서 선거철에 여론조사를 발표하면서 흔히 “A후보의 지지율이 조사결과 56%인데 95% 신뢰도로 오차범위가 \\(\\pm\\) 3%입니다” 라고 말합니다. 표본조사로 지지율이라는 통계량이 56%가 나왔는데 과연 이게 모집단의 모수와 동일할 확률이 얼마나 되는가? 모수가 53%-59% 사이에 있을 확률이 95%다. 이런 식으로 확률 이론이 추론통계학에 기반을 제공하는 겁니다. 앞의 기사에서 \\(\\pm\\) 3%는 오차 허용범위를 말하는데 이것은 표집할 때 나타나는 모집단과 표본의 차이에서 발생합니다. 표본에서 A 후보를 지지하는 사람의 비율이, 즉 지지율이 모집단과 동일한 경우도 있겠지만 그보다는 모집단보다 더 높거나 더 낮을 가능성이 많습니다. 이렇게 표집의 과정에서 오차가 발생하는 걸 표집오차라고 하고 그 결과로 오차 허용범위가 생깁니다.\n자, 그래서 기술통계학에서 추론통계학으로 넘어가는 중간에 확률 이론을 살짝 맛보고 가게 됩니다. 정말 기본 중의 기본만 살짝 거쳐가는 겁니다.\n기술통계학, 추론통계학, 확률, 표집오차, 오차 허용범위"
  },
  {
    "objectID": "basic-concepts.html#측정-척도",
    "href": "basic-concepts.html#측정-척도",
    "title": "2  통계의 기초 개념",
    "section": "2.3 측정 척도",
    "text": "2.3 측정 척도\n측정 척도 measurement scale 는 연구나 조사에서 측정하려는 특성의 성격과 측정 방법에 따라 구분되는 척도입니다. 측정 척도에는 명목척도, 서열척도, 등간척도, 비율척도 등, 네 종류가 있습니다.\n\n2.3.1 명목척도\n명목척도 nominal scale 는 관찰 대상의 특성을 범주 category 나 종류로 구분하는 것입니다. 예를 들어, 사람을 남자와 여자로 구분하는 것. 또는 옷 색깔을 빨강, 파랑, 노랑 등 색으로 구분하는 것 등이 있습니다. 또 사람의 거주지를 서울, 경기도, 강원도 등으로 구분하는 것도 여기에 속합니다.\n범주나 종류는 수치로 크기를 측정할 수 없는 것으로 명목 척도를 숫자로 나타낸다고 해도 그것은 크기가 의미가 없습니다. 예를 들어, 남자를 1로 여자를 2로 적어 놓는다고 해도 숫자에 구분 이외의 기능이 없습니다. 그래서 남자를 2로 여자를 1로 적어도 아무런 차이가 없습니다.\n\n\n2.3.2 서열 척도\n서열 척도 ordinal scale 는 측정 대상인 특성을 서열로 구분하는 것입니다. 즉 절대적인 수치가 없고 상대적인 서열만 측정하는 것입니다. 예를 들어, 올림픽 마라톤 경기에서 1등부터 차례로 순서를 매기는 것이 그것입니다. 달린 시간이 얼마인가는 상관없이 그저 상대적인 서열만 측정하는 방법입니다.\n미디어의 신뢰도를 측정하면서, 여러 신문사 방송사의 이름을 죽 제시하고 신뢰도 순서로 순위를 매기도록 하는 게 서열 척도입니다. 브랜드 선호도를 조사할 때도 이 방법을 사용하는 경우가 많습니다. 예를 들어, 소비자에게 여러 맥주 브랜드를 모두 알려주고 선호도의 순서로 적으라고 하면 서열 척도 측정입니다.\n\n\n2.3.3 등간 척도\n등간 척도 interval scale 는 측정 눈금 간의 간격이 모두 동일한 것으로 간주하는 방법입니다. 온도를 예로 들면, 11도와 12도의 1도 차이는 32도와 33도의 1도 차이와 동일한 의미(간격)를 가집니다. 우리가 설문조사에서 5점 척도나 7점 척도를 사용한다면 이것이 등간 척도라고 가정하는 겁니다. 즉 1점과 2점의 1 차이는 5점과 6점의 1 차이와 동일한 크기와 의미를 가졌다고 보는 겁니다.\n학력고사의 등급이 1등급, 2등급, …, 9등급 이렇게 설정됩니다. 이때 1등급과 2등급의 1 차이는 5등급과 6등급의 1 차이와 같지 않습니다. 학력고사 점수의 차이도 같지 않고 그 안에 포함되는 수험생의 수도 같지 않습니다. 이것은 등간척도가 아닙니다. 그래서 학력고사 등급은 대체로 순위 척도로 간주해야 하고, 경우에 따라서는 명목 척도로 다루어야 합니다. 물론 학력고사 등급을 등간척도로 가정하고 통계 분석을 하는 경우도 있습니다만, 그것은 펀의를 위한 가정이고 여전히 학력고사 등급은 등간 척도가 아닙니다.\n등간 척도에서는 0이 의미를 가지지 않고 그냥 척도 수준의 하나에 불과합니다. 등간척도에서 0이 절대적 기준의 의미를 가지면 비율 척도가 됩니다.\n\n\n2.3.4 비율 척도\n등간 척도에서 0이 절대적 ’없음’의 의미를 가지면 비율 척도 radio scale 가 됩니다. 0을 기준으로 비율을 계산할 수 있기 때문입니다. 즉 2 점은 4 점의 50%라고 말할 수 있습니다. 비율 척도는 척도 중에서 가장 수준이 높은 척도라고 간주합니다. 무게나 길이는 대표적인 비율 척도입니다. 재산도 빚은 -이고 자산은 +이지만, 0 이 ’없음’을 의미하므로 비율 척도입니다.\n등간 척도와 비율 척도의 차이를 이해하기 위해서 온도를 예로 들겠습니다. 온도를 재는 척도는 섭씨와 화씨가 있습니다. 둘 다 0° 가 있지만 그 온도는 서로 다릅니다. 예를 들어, 섭씨 0° 가 화씨에서는 32° 이고 화씨 0° 는 섭씨 -18° 입니다. 섭씨나 화씨의 온도 척도에서는 0° 가 절대적 “없음”을 나타내지 못합니다. 따라서 “몇 배가 덥다”는 비율의 표현을 사용하면 안 됩니다.\n절대온도를 나타내는 켈빈 K는 0 이 의미가 있으므로 비율 척도입니다. 온도는 분자의 운동량으로 결정되는데 켈빈 K의 0도는 측정 물체의 분자 운동량이 0 이므로 더 이상 온도가 내려갈 수 없는 진짜 0 도입니다. 그래서 켈빈에서는 마이너스 온도가 없습니다. 비율 척도라서 100K보다 200K가 두 배 높다고, 즉 온도(분자 운동량)가 200% 라고 말할 수 있습니다.\n\n\nTable 2.3: 온도 척도 세 방법의 비교\n\n\n\n\n\n\n\n\n\n섭씨 C\n\n화씨 F\n\n켈빈 K\n\n\n\n\n30\n=\n86\n=\n303\n\n\n60\n=\n140\n=\n333\n\n\n30 \\(\\rightarrow\\) 60 (100%)\n\n86 \\(\\rightarrow\\) 140 (63%)\n\n303 \\(\\rightarrow\\) 333 (10%)\n\n\n\n\n위의 표를 보면 각 온도 척도에 따라 동일한 온도가 다른 수치로 표시 됩니다. 그래서 섭씨에서 30도가 60도로 오르면 100% 증가가 되지만, 화씨에서 같은 온도인 86도가 140도로 오르면 63% 증가가 됩니다. 역시 켈빈에서 동일한 온도인 303도에서 333도로 오른 것이므로 10% 증가입니다. 이 셋의 수치 중에서 켈빈의 10%만이 타당하고 나머지는 틀립니다. 왜냐하면, 켈빈의 0도만이 ’없음’이라는 기준을 충족하는 비율 척도이기 때문입니다.\n등간 척도와 비율 척도는 얼핏 봐서 이용하는 데 별 차이가 없어보이지만 현실에서 큰 실수를 야기할 수 있습니다. 예를 들어, 화학 공장에서 두 물질을 섞어 새 물질을 만드는데 반응 온도는 10°C입니다. 사장이 생산량을 2배 늘리라고 했는데 온도(분자 활동)가 2배 늘면 생산량이 2배 증가하므로 공장장이 반응 온도를 20°C로 올렸습니다. 과연 원하는 생산량이 나왔을까요? 겨우 3.6% (=10 \\(\\div\\) 273) 늘었습니다. 10°C가 283 K이므로 반응온도를 2배 올리려면 566 K (=283 \\(\\times\\) 2) 로, 즉 293°C로 올려야 합니다. 두 배, 세 배 등 비율을 적용하려면 반드시 비율 척도를 사용해야 합니다."
  },
  {
    "objectID": "basic-concepts.html#변수",
    "href": "basic-concepts.html#변수",
    "title": "2  통계의 기초 개념",
    "section": "2.4 변수",
    "text": "2.4 변수\n변수 variable 는 측정 단위의 특성을 측정한 값의 이름입니다. 만일 키가 조사 대상이면 키를 측정하게 되는데, 사람이 측정 단위이고 ’키’가 변수입니다. 측정한 키의 값들이, 예를 들어 173cm나 167cm 같은 값들이, 변수값이 됩니다. 만일 “나이’를 조사했으면 나이가 변수가 됩니다.\nR 프로그래밍에서 변수는 어떤 값을 저장하는 장소의 이름입니다. 예를 들어, x &lt;- 3 이라고 하면 x 라는 변수에 3을 저장합니다. 이 장에서는 통계의 개념을 설명하므로 당연히 변수를 통계학에서 정의한 의미로 사용합니다. R과 통계학에서 동일한 이름을 사용하는 이유는 그 둘이 유사하기 때문이므로 나중에는 둘이 같은 것이라고 인식하게 됩니다.\n\n2.4.1 정량 변수와 정성 변수\n정량 변수 quantitative variable 는 변수값을 수치로 표현하는 변수입니다. 정량 변수는 양적 변수 또는 계량적 변수라고도 부릅니다. 무게, 길이, 은행 잔고, 통계시험 점수 등이 그 예입니다.\n정성 변수 qualitative 는 변수값을 수치로 표현하지 못하는 변수입니다. 정성 변수는 질적 변수라고도 부릅니다. 경기도나 충청도 등 행정구역으로 구분하는 거주지, 여자나 남자로 구분하는 성별, 파랑이나 노랑 등 색으로 구분하는 색깔, 재학 중인 대학교 이름 등이 그 예입니다.\n정량 변수, 양적 변수, 계량적 변수, 정성 변수, 질적 변수\n\n\n2.4.2 이산 변수와 연속 변수\n이산 변수 discrete variable 는 변수를 정수값으로 표현하는 변수입니다. 과목의 수강학생 수나 운송회사에서 보유한 버스의 수 등이 그 예입니다. 35명이나 42명의 수강인원은 가능하지만, 30.4명의 수강인원은 불가능하기 때문입니다. 0.4로 쪼개진 학생이 살아서 강의실에 들어올 수는 없겠지요. 물론 수강인원을 평균으로 계산했을 때 ‘과목당 32.5명이 수강한다’ 등의 표현이 가능합니다만 이것은 ’변수의 평균’이지 변수가 아닙니다.\n연속 변수 continuous variable 는 변수를 실수값으로 표현하는 변수입니다. 실수값은 무한히 많은 수가 존재하므로 특정한 두 수 사이에서 끊이지 않는 연속적인 실수값이 존재하므로 연속적 변수가 됩니다. 길이를 예로 들어 보면, 171 cm의 키와 173 cm의 키 사이에 172 cm도 존재하지만 171.2 cm, 172.21 cm, 172.21358 cm 등 정수가 아닌 실수로 측정할 때 거의 무한대의 수가 존재하게 됩니다. 이런 변수를 연속 변수라고 합니다.\n이산 변수, 연속 변수\n\n\n2.4.3 확률 변수\n확률 변수는 변수가 확률론적으로 (‘확률적’이 아니라!) 분포하는 (이론적인) 변수를 말합니다. 영어로는 random variable, probabilistic variable, stochastic variable 이라고 부르죠. 굳이 영어 이름을 말하는 이유는 random variable, 즉 무작위 변수라는 이름이 오히려 확률 변수의 특성을 잘 나타내기 때문입니다. 한국어에서 확률은 ’무작위적’ random 의 의미가 아니라 ‘가능성이 높은’ probable 이라는 의미를 가지기 때문에 오해를 부르기 쉽습니다. 학생들이 통계학의 ‘확률과 분포’ 분야에서 헤매는 이유 중의 하나가 아마도 이런 용어의 혼동 때문이라고 생각합니다. 그래서 통계힉 분야에서 확률적 probable 이란 부정확한 용어 대신에 확률론적 probabilistic 이라는 정확한 용어를 사용하는 추세입니다.\n무작위 random 의 의미를 알아 봅시다. 동전을 던지면 앞면 또는 뒷면이 나올 확률은 동일합니다. 또 주사위를 던지면 1이 나올 확률이나 4가 나올 확률이나 모두 동일하지요. 그런 걸 말합니다. 물론 현실에서는 동전이 굽은 형태라든지 주사위의 모서리가 닳은 형태라든지, 그런 영향으로 뽑힐 확률이 엄밀하게 따져서 동일하지는 않겠지만, 이론적으로 동일하다고 가정할 때 무작위적 확률이라고 말할 수 있습니다. 이제부터 통계에서 ‘확률적’ 또는 ’확률론적’이라는 용어를 보면 ’무작위적’이라고 이해해주세요.\n참고로 모집단에서 표본조사를 위하여 표본을 추출할 때 확률 표집 probability sampling 과 비확률 표집 non-probability sampling 이 있습니다. 확률 표집은 각 개체가 표본에 뽑힐 확률이 동일한 방법이고 (즉 각 개체가 무작위적으로 뽑히는 방법이고) 비확률 표집은 동일하지 않는 방법입니다. 만일 전화를 사용해서 조사한다면 전화를 소유한 사람들만 뽑아야하므로 전화 소유자가 비소유자에 비해서 표본에 뽑힐 가능성이 아주 높게 됩니다. 따라서 동일한 확률이 적용되지 않으므로 비확률 표집이 됩니다. 여기서도 정확한 용어를 써서 확률론 표집 (즉 무작위 표집), 비확률론 표집, 이렇게 바꾸어야 개념의 혼란을 방지할 수 있습니다.\n확률 변수의 분포가 확률 분포인데 이것도 이산 확률 분포와 연속 확률 분포가 있습니다. 연속 확률 분포는 정규분포나 지수분포 등 여러 가지가 있습니다. 나중에 추론 통계에서 추론를 위해서 이런 분포를 이용할 것입니다. 통계학에서 확률 변수는 \\(X\\)나 \\(Y\\)처럼 대문자로 표시하고 현실에서 관찰한 실제적 변수는 \\(x\\)나 \\(y\\)처럼 소문자로 표시합니다.\n확률 변수, 무작위 변수, 확률론 변수, 확률론적, 무작위적"
  },
  {
    "objectID": "basic-concepts.html#인과관계와-변수",
    "href": "basic-concepts.html#인과관계와-변수",
    "title": "2  통계의 기초 개념",
    "section": "2.5 인과관계와 변수",
    "text": "2.5 인과관계와 변수\n인과관계 causation 는 원인과 결과로 이루어진 관계입니다. 인과 관계가 성립하려면 원인과 결과가 있어야 하므로 인과관계는 적어도 두 개의 변수를 포함합니다. 상관관계 correlation 는 두 개의 변수가 서로 연관하여 있는 관계입니다. 인과관계가 성립하려면 반드시 상관관계가 성립해야 하지만, 상관관계가 반드시 인과관계를 의미하지는 않습니다.\n사람의 키와 무게는 상관관계가 있지만 키가 무게의 원인이 아니고 무게도 키의 원인이 아닙니다. 부모의 유전이 사람의 키와 무게에 동시에 영향을 미치는 것이므로 상관관계는 있지만 인과관계로 보기 어렵습니다. 이렇게 부모의 유전이라는 제3의 요인이 키와 무게에 모두 영향을 주어서 키와 무게가 상관관계를 갖는 것을 허위상관관계 spurious relationship 라고 합니다. 봄이 오면 얼음이 녹고 꽃이 피는데 얼음이 녹아서 꽃이 피게 되는 인과관계는 아니지요. 기온상승이라는 제3요인이 둘에게 모두 영향을 주는 허위상관관계입니다. 부모의 키와 자식의 키는 상관관계가 있습니다. 유전을 통해 부모의 키가 자식의 키의 원인이므로 두 변수는 상관관계이면서 인과관계입니다.\n\n\n\nFigure 2.1: 인과관계와 허위상관관계\n\n\n인과관계, 상관관계, 허위상관관계\n\n2.5.1 독립변수와 종속변수\n사회과학에서 통상 독립변수 independent variable 와 종속변수 dependent variable 를 인과관계로 설명합니다. 독립변수는 영향을 주는 변수, 종속변수는 그 영향을 받는 변수로 정의합니다. 둘은 설명변수 explanatory variable 와 반응변수 reponse variable 로 부르기도 합니다. 독립변수가 설명하는 변수고 종속변수가 반응하는 변수입니다.\n그러나 데이터 분석을 할 때 독립변수와 종속변수의 관계가 늘 인과관계는 아닙니다. 키가 크면 몸무게도 역시 무거우므로, 회귀분석을 통해서 키를 이용하여 몸무게를 예측할 수 있습니다. 앞서 말한 바처럼 이건 인과관계가 아닙니다. 역시 회귀분석을 통해 부모의 키를 독립변수로 사용해서 자식의 키를 예측할 수 있습니다. 이때는 독립변수와 종속변수의 인과관계가 성립합니다.\n독립변수, 종속변수, 설명변수, 반응변수\n\n\n2.5.2 매개변수와 조절변수\n조절변수 moderator variable 는 중간에서 독립변수가 종속변수에 미치는 영향(관계)의 크기와 방향에 관여하는 변수입니다. 조절변수는 독립변수와 연관이 없으므로 독립변수의 영향을 받지 않습니다다. 예를 들어, 미디어 이용시간이 미디어 효과에 영향을 준다고 할 때 남자는 영향을 많이 받고 여자는 영향을 적게 받는다면 성별은 조절변수입니다. 중간에서 관계와 영향의 정도에 관여하지만 미디어 이용시간이 성별에 영향을 주는 건 아니니까요.\n매개변수 mediator variable 는 중간에서 독립변수가 종속변수에 미치는 영향을 전달하는 변수입니다. 따라서 매개변수는 독립변수의 영향을 받습니다다.예를 들어, 미디어 이용시간이 미디어 만족을 통해서 미디어 효과에 영향을 준다고 하면, 먼저 미디어 이용시간이 미디어 만족에 영향을 주고, 그 뒤에 미디어 만족이 미디어 효과에 영향을 주는 것입니다. 따라서 미디어 이용시간이 미디어 효과에 영향을 주지만 (즉 인과관계가 있지만) 그 영향은 중간의 미디어 만족을 통해서 전달되어야만 합니다.\n조절변수와 매개변수는 관계의 역할에서 개념적으로 확실히 다르게 인식할 수 있습니다. 특히 조절변수는 독립변수의 영향을 받지 않지만 매개변수는 영향을 받는다는 점에서도 구별됩니다. 그러나 실제 연구에서 두 변수를 확실하게 구분하기 어려울 때가 꽤 있고, 구분을 하는 의미가 별로 없는 경우도 있습니다. 나중에 회귀분석에서 자세하게 살펴봅니다.\n\n\n\nFigure 2.2: 조절변수와 매개변수\n\n\n조절변수, 매개변수"
  },
  {
    "objectID": "base-r.html#r과-rstudio-설치",
    "href": "base-r.html#r과-rstudio-설치",
    "title": "3  R 기본",
    "section": "3.1 R과 RStudio 설치",
    "text": "3.1 R과 RStudio 설치\n아래의 사이트에서 R과 R Studio를 다운해서 설치하세요.\nhttps://posit.co/download/rstudio-desktop/#download\n가능하면 가장 최신의 버전으로 설치하는 게 좋아요."
  },
  {
    "objectID": "base-r.html#rstudio",
    "href": "base-r.html#rstudio",
    "title": "3  R 기본",
    "section": "3.2 RStudio",
    "text": "3.2 RStudio\nR Studio는 R을 편하게 사용하려고 만든 거니까 우리는 R Studio를 사용하게 될 겁니다. R Studio를 실행하면 화면이 나타납니다.\n처음에 실행하면 패널이 세 개만 있을 거에요. 하지만 4 패널을 금방 생성해서 사용할 거니까 패널이 네 개라고 보는 게 좋아요.\n\n스크립트 패널: 여기가 실행파일(스크립트)을 만들고 수정하는 곳이에요.\n콘솔 패널: 여기가 R 코드가 실행되고 결과와 메시지가 나오는 곳이에요.\n환경 패널: 여기 데이터 목록이 나올 거에요.\n파일, 그래프, 도움, 패키지 패널: 그 말대로 그것들이 나올 거에요.\n\n\n\n\nFigure 3.1: RStudio의 4 패널\n\n\nRStudio를 종료할 때 워크스페이스를 (.RData) 저장할 거냐고 묻는 경우가 있는데 안 하는 게 좋아요. 자칫하면 혼란이 생기거든요. R 실행파일만 저장하고 다음에 그걸 다시 실행하면 됩니다. 물론 R 실행파일이나 (.R) Quarto 파일은 (.qmd) 잊지 말고 저장해야죠."
  },
  {
    "objectID": "base-r.html#r-코드-실행",
    "href": "base-r.html#r-코드-실행",
    "title": "3  R 기본",
    "section": "3.3 R 코드 실행",
    "text": "3.3 R 코드 실행\nR 코드는 R에게 명령을 실행하라는 지시문입니다. 코드로 이루어진 파일이 R 실행파일인데 이름 뒤에 .R이 붙어요. 데이터를 다루고 분석하는 일을 코드를 통해서 지시하는 겁니다. 대개 코드는 한 줄에 하나의 지시문을 적어요.\n바로 아래에 나타난 코드 뭉치를 코드 청크라고 부릅니다. Quarto에서는 코드 청크를 본문에 넣고 그걸 바로 실행해서 결과를 문서 안에 포함하는 게 가능하지만 아직 안 배웠으니 콘솔을 사용합니다. 아래의 코드를 콘솔에 적거나 복사해서 붙이고 엔터를 눌러서 실행해 보세요.\n\n1+1\n\n코드 뭉치는 한 줄도 되지만 대개 여러 줄로 구성되는 게 보통입니다.\n\n2*2\n1+2*3-5\n\nR 코드를 콘솔에 넣고 엔터키를 치면 그 코드를 실행하고 결과를 되줍니다. 위의 코드를 복사해서 콘솔에 넣고 엔터를 쳐 실행해보세요.\n\n3.3.1 R 스크립트\n콘솔 안에서 일할 때, 자판의 윗 화살표 ↑를 누르면 바로 전에 사용한 코드를 다시 불러 올 수 있습니다. 그러나 그것보다 스크립트 패널을 사용하는 게 더 효율적입니다. R 스크립트 파일은 편집하고 즉석에서 실행하고 수정할 수 있어서 훨씬 효율적이에요.\n스크립트 파일을 새로 만들려면, Ctrl+Shift+N을 누르거나 메뉴에서 File &gt; New File &gt; R Script를 선택하면 됩니다. 스크립트 패널에 새 스크립트 파일을 열고 아래를 복사해서 넣어 보세요. 그리고 run 단추를 클릭해서 한 줄씩 실행해 보세요.\n\n1+1\n2*2\n1+2*3-5\n(1+2)*3-5\n\n스크립트 패널에서는 콘솔 패널과 달리, 엔터키를 누르면 코드를 실행하는 게 아니라 줄을 바꿉니다. 이것은 스크립트 패널은 스크립트 파일의 편집이 주요 목적이기 때문입니다. 스크립트 패널에서 R 코드를 실행하려면 아래처럼 합니다.\n\nCtrl+Shift+Enter를 친다.\nCtrl+Alt+Enter를 치면, 실행을 하지만 코드를 되보여주거나 결과를 보여주지 않는다.\n(외부파일을 실행하려면, 소스 Source 버튼을 클릭한다.)\n\n그냥 Run 버튼을 클릭하면 커서가 있는 한 줄의 코드가 실행합니다. 만일 그 전에 마우스로 선택된 블럭이 있으면 그 선택 블럭이 실행합니다. Run 버튼 대신에 Ctrl+Enter를 쳐도 됩니다."
  },
  {
    "objectID": "base-r.html#변수와-함수",
    "href": "base-r.html#변수와-함수",
    "title": "3  R 기본",
    "section": "3.4 변수와 함수",
    "text": "3.4 변수와 함수\n\n3.4.1 데이터 저장\n아래처럼 변수 x 에 숫자를 부여합니다. 이때 자판의 왼꺾쇠 “&lt;”와 하이폰 “-”을 빈칸없이 “&lt;-” 이렇게 사용합니다. 이게 실행되면 x라는 변수가 생기고 동시에 그 x 변수는 4의 값을 갖게 됩니다.”\n\nx &lt;- 4\n\n이걸 실행하면 아래처럼 나타납니다.\n\nx &lt;- 4\nx    # x를 출력에 나타나게 한다\n\n[1] 4\n\n\n[1]가 의미하는 건 곧 배울 겁니다. 변수 x를 만들었으니 아래처럼 사용하면 됩니다. 아래를 복사해서 실행해 보세요.\n\nx + 1\nx + x\n\n변수를 만들 때 아래처럼 수식을 사용해도 되고 다른 변수를 넣어도 됩니다. 기호와 숫자 사이에 빈칸은 있어도 되고 없어도 됩니다. 보통 빈칸을 넣습니다.\n\nx &lt;- 1 + 2 + 3 + 4\n\n좀 드물게 사용하지만, 화살표 방향이 달라도 됩니다.\n\n2 + 2 -&gt; y\n\n\n\n3.4.2 변수 이름을 만들기\n간단하게 만들기. 각각 y, z, x 변수를 만듭시다.\n\ny &lt;- 100\nz &lt;- 20\nx &lt;- y - z\n\n또는 알아보기 쉽게 만들기. 각각 소득, 세금, 세후_소득 등 세 변수를 만듭시다.\n\n소득 &lt;- 100\n세금 &lt;- 20\n세후_소득 &lt;- 소득 - 세금\n\n잘 되었는지 변수 세후_소득을 출력해봅니다. 80이 나오면 맞게 된 겁니다.\n\n세후_소득\n\n[1] 80\n\n\n이것도 됩니다. 실행한 뒤에 환경 패널에서 변수가 제대로 생겼나 봅니다.\n\n세후_소득 &lt;- 소득 &lt;- 120\n\n영어로 변수를 만들 때, R은 대문자와 소문자를 구분해요. 즉 Taxes와 taxes를 다른 변수로 인식합니다.\n변수를 만들 때 -, +, *, :, =, !, $는 사용하지 못합니다. 왜냐하면 이 기호는 실행문에서 사용하기 때문입니다.\n아래는 변수 이름을 만드는 일반적 방법입니다.\n\n_ 기호 이용; snake_case, household_net_income, 가구_소득\n대소문자 이용; snakeCase, SnakeCase, NetIncome\n. 기호 이용; period.case, 경기도.가구당.소득\n그냥 붙이기; householdnetincome, 경기도가구당소득\n\n변수를 만들 때, 설명을 붙이면 나중에 알아보기 편해요. # 기호를 문장 앞에 붙이면 R은 그 문장을, 코드가 아닌, 설명으로 인식해서 무시합니다. 코드 오른쪽에 붙이면 그 자리부터 설명으로 인식합니다.\n\n# 소득과 세금을 결정한다\n소득 &lt;- 100  # 소득을 100으로\n세금 &lt;- 20   # 세금을 20으로\n\n\n# 세후 소득의 결정\n세후_소득 &lt;- 소득 - 세금\n\n스크립트 패널에서 Ctrl+Shift+C를 누르면 커서가 위치한 줄의 # 기호가 없어지고 생기고 합니다. C는 Comment를 뜻합니다. #를 넣어서 그 줄만 실행이 안 되게 할 수 있고, 다음에 #를 빼서 실행하도록 변경할 수 있어요.\n\n\n3.4.3 벡터와 데이터 프레임\n변수에는 하나의 숫자/값만 넣는 게 아니라 여러 개의 숫자/값을 넣을 수 있어요. 이럴 때 벡터 변수라고 해요. 통상적으로 변수 하나가 여러 사례를 갖게 되니까 벡터 변수가 통상적으로 사용하는 변수와 유사합니다.\n즉 일일이 사람마다 변수로 취급하고 값을 넣어주게 되면 아래처럼 불편합니다.\n\n사람1_나이 &lt;- 28\n사람2_나이 &lt;- 48\n사람3_나이 &lt;- 47\n# ...계속된다\n\n그래서 변수에 한꺼번에 사례의 변수값을 넣는 게 편하지요. 여러 개 변수값을 갖는 변수를 벡터 변수 또는 그냥 벡터라고 부릅니다. 벡터를 만드는 함수는 c( )입니다.\n\n나이 &lt;- c(28, 48, 47, 71, 22, 80, 48, 30, 31)\n\n벡터 변수에 연산을 하면 각각에 대해서 계산합니다.\n\n나이_개월수 &lt;- 나이 * 12\n나이_개월수\n\n[1] 336 576 564 852 264 960 576 360 372\n\n\n변수에 변수값이 여러 개 포함되면 벡터이고, 그런 벡터가 여러 개 있으면 데이터 프레임이 됩니다. 우리가 통계 분석에 사용하는 것은 데이터 프레임입니다. 벡터 테이블 tables of vectors 이라고 부르기도 합니다.\n앞에서 벡터변수 ’나이’는 지정했으니까 벡터변수 ’구매량’을 하나 더 만듭니다.\n\n구매량 &lt;- c(20, 59, 2, 12, 22, 160, 34, 34, 29)\n\n두 개의 벡터를 합쳐서 데이터 프레임을 만듭니다.\n\n책가게 &lt;- data.frame(나이, 구매량)\n\n콘솔 패널에 책가게를 쳐서 실행해서 결과를 봅니다. Quarto에서 실행하는 것과 (실제 결과는 같지만) 보이는 output은 약간 다를지 모릅니다. 나이와 구매량은 벡터이고 책가게는 데이터프레임이에요.\n\n책가게\n\n  나이 구매량\n1   28     20\n2   48     59\n3   47      2\n4   71     12\n5   22     22\n6   80    160\n7   48     34\n8   30     34\n9   31     29\n\n\n나이를 프린트 해 볼까요?\n\n나이\n\n[1] 28 48 47 71 22 80 48 30 31\n\n\n긴 벡터를 가진 변수를 만들어 실험해 봅시다. 벡터를 만들 때 변수값 사이에 쉼표를 넣고, 줄을 바꿀 때는 엔터를 칩니다. 자동으로 들여쓰기를 합니다. 줄바꿈한 것은 실행할 때 (콘솔 패널에서) 줄 맨앞에 +가 붙는데 이건 R이 아직 명령이 이어지고 있다는 걸 인식한 겁니다.\n\n거리 &lt;- c(687, 5076, 7270, 967, 6364, 1683, 9394, 5712, 5206,\n               4317, 9411, 5625, 9725, 4977, 2730, 5648, 3818, 8241,\n               5547, 1637, 4428, 8584, 2962, 5729, 5325, 4370, 5989,\n               9030, 5532, 9623)\n거리\n\n [1]  687 5076 7270  967 6364 1683 9394 5712 5206 4317 9411 5625 9725 4977 2730\n[16] 5648 3818 8241 5547 1637 4428 8584 2962 5729 5325 4370 5989 9030 5532 9623\n\n\n실행할 때의 콘솔 패널 넓이에 따라서 output이 줄바꿈하는 부분이 달라집니다.\n변수에 값이 하나밖에 없어도 [1]이 앞에 붙는다는 것은 그 변수가 벡터라는 걸 보여줍니다.\n\nx &lt;- 4\nx\n\n[1] 4\n\n\n잇단 숫자는 아래처럼 생성합니다.\n\nx &lt;- c(1:5)\nx\n\n[1] 1 2 3 4 5\n\n\n\n\n3.4.4 함수\n함수 functions 는 미리 만들어놓은 지시문의 뭉치를 간단하게 표현한 겁니다. 대개 함수이름(변수이름)의 형태를 가집니다. 아래의 mean은 평균을 계산하는 함수입니다.\n\n나이 &lt;- c(28, 48, 47, 71, 22, 80, 48, 30, 31)\nmean(나이)\n\n[1] 45\n\n\n함수는 여러 개의 변수를 이용하기도 합니다. 아래는 상관계수를 구하는 함수인 cor( )입니다. 함수는 추가로 옵션이 붙기도 합니다.\n\n나이 &lt;- c(28, 48, 47, 71, 22, 80, 48, 30, 31)\n구매량 &lt;- c(20, 59, 2, 12, 22, 160, 34, 34, 29)\ncor(나이, 구매량, method = \"pearson\")\n\n[1] 0.589402\n\n\n변수나 옵션이 필요하지 않아도 함수는 ( )를 포함합니다. 예를 들어 현재 시간을 넣어주는 Sys.time( )도 ( )가 필요합니다. 물론 안에는 아무것도 안 넣어요.\n\nSys.time()\n\n[1] \"2023-07-15 15:50:50 KST\"\n\n\n함수는 여러분도 만들어서 사용할 수 있습니다. 그런 걸 사용자 정의 함수라고 합니다. Example 6.4 예 그 예가 있습니다.\n\n\n3.4.5 수학 연산\n사칙 연산에는 +, -, *, / 를 사용합니다. 아래에 다른 것들이 있습니다.\n\nabs(x): 절대값 \\(|x|\\)\nsqrt(x) : 제곱근 \\(\\sqrt{x}\\)\nlog(x) : x 자연로그값 \\(e\\)\nlog(x, base = a ): x 로그값 a\na^x : a의 x 제곱 \\(a^x\\)\nexp(x) : e의 x 제곱 \\(e^x\\)\nsum(x) : x 가 벡터일 때 \\(x=(x_1, x_2, x_3, ..., x_n)\\) 총합 \\(\\sum_{i=1}^{n}x_i\\)\nprod(x) : x가 벡터일 때 \\(x=(x_1, x_2, x_3, ..., x_n)\\) 모든 걸 곱한 값 \\(\\prod_{i=1}^{n}x_i\\)\npi : \\(\\pi\\) 값\nx %% a : x 를 a로 나눈 나머지값\nfactorial(x) : x!\nchoose(n,k) : 순열 \\({n}\\choose{k}\\)"
  },
  {
    "objectID": "base-r.html#패키지",
    "href": "base-r.html#패키지",
    "title": "3  R 기본",
    "section": "3.5 패키지",
    "text": "3.5 패키지\nR은 수많은 함수를 포함해서 수많은 일을 하지만, 그래도 데이터 분석의 모든 것을 다 하지는 못합니다. 그래서 패키지가 필요합니다. 패키지는 R에 포함하는 새로운 함수와 데이터셋의 집합체를 말합니다. 패키지는 통계분석, 그래프 그리기, C++ 코드, 데이터 처리 등 모든 분야에서 새로 개발되어 R에 포함됩니다. R은 20,000개가 넘는 패키지를 포함합니다.\n예를 들어, 그래프 그리기 기능을 확장하는 ggplot2라는 패키지를 설치해서 각종 그래프를 그릴 수 있어요. ggplot2 패키지를 설치하려면 RStudio 메뉴에서 Tools&gt; Install packages 를 선택하거나, RStudio의 오른쪽 아래 파일, 도움 패널 창에 있는 메뉴의 Packages 탭&gt; Install 클릭해서 설치해도 됩니다.\n콘솔 창에 아래의 코드를 적고 실행해도 됩니다.\n&gt; install.packages(“ggplot2”)\n설치가 다 되면 아래의 메시지가 나타납니다.\npackage 'ggplot2' successfully unpacked and MD5 sums checked\n설치가 되었다고 바로 사용하지 못해요. 설치한 패키지에 포함한 함수나 데이터셋을 사용하려면, 매번 R을 시작할 때 library(패키지_이름) 함수를 실행해서 활성화해야 합니다. 패키지가 필요한 스크립트 파일은 맨 앞에 library 함수를 포함할 것을 권장합니다.\n\nlibrary(ggplot2)\n\n패키지 활성화는 R Studio 오른쪽 아래 패널 메뉴의 패키지탭을 클릭하고 나타난 패키지 목록에 해당 패키지 이름이 있으면 그 체크 박스를 체크해도 역시 됩니다. 체크하는 순간 콘솔 박스에서 library(패키지 이름)이 실행합니다."
  },
  {
    "objectID": "base-r.html#기술적-통계",
    "href": "base-r.html#기술적-통계",
    "title": "3  R 기본",
    "section": "3.6 기술적 통계",
    "text": "3.6 기술적 통계\n여기서는 ggplot2 패키지에 실린 데이터셋 둘을 사용할 거예요.\n\ndiamands : 다이아몬드 50,000여 개의 가격\nmsleep : 포유류 83 종류의 잠 시간\n\n만일 여기서 R을 새로 시작했다면, 먼저 library를 이용해서 활성화 시켜야겠죠. 설치 안 했으면 먼저 설치를 해야 합니다.\n\n# install.packages(\"ggplot2\")\nlibrary(ggplot2)\n\n분석 전에 먼저 msleep 데이터셋을 살펴봅니다.\n\nmsleep\n\n# A tibble: 83 × 11\n   name   genus vore  order conservation sleep_total sleep_rem sleep_cycle awake\n   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;              &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt;\n 1 Cheet… Acin… carni Carn… lc                  12.1      NA        NA      11.9\n 2 Owl m… Aotus omni  Prim… &lt;NA&gt;                17         1.8      NA       7  \n 3 Mount… Aplo… herbi Rode… nt                  14.4       2.4      NA       9.6\n 4 Great… Blar… omni  Sori… lc                  14.9       2.3       0.133   9.1\n 5 Cow    Bos   herbi Arti… domesticated         4         0.7       0.667  20  \n 6 Three… Brad… herbi Pilo… &lt;NA&gt;                14.4       2.2       0.767   9.6\n 7 North… Call… carni Carn… vu                   8.7       1.4       0.383  15.3\n 8 Vespe… Calo… &lt;NA&gt;  Rode… &lt;NA&gt;                 7        NA        NA      17  \n 9 Dog    Canis carni Carn… domesticated        10.1       2.9       0.333  13.9\n10 Roe d… Capr… herbi Arti… lc                   3        NA        NA      21  \n# ℹ 73 more rows\n# ℹ 2 more variables: brainwt &lt;dbl&gt;, bodywt &lt;dbl&gt;\n\n\n처음 10개 행을 보여줄 겁니다. 또 83 x 11 이라는 데이터셋 정보를 알려줄 텐데 83개 행에 (가로줄: 83개 사례) 11개 열이 (세로줄: 11개 변수) 있다는 겁니다. 모든 걸 보려면 아래의 함수를 사용합니다. View함수를 사용하면서 V가 대문자라는 걸 주의하세요. R 함수와 변수는 영문 대소문자를 구분합니다.\n\nView(msleep)\n\n변수값 NA는 결측값 missing value 입니다. 결측값은 잘못 입력한 값이므로 통계에 사용하지 못하는 값입니다.\n아래는 데이터셋에 대한 정보를 알리는 함수입니다. 복사해서 스크립트 패널에 넣고 실행해 보세요.\n\nhead(msleep)\ntail(msleep)\ndim(msleep)\nstr(msleep)\nnames(msleep)\n\n\nhead : 앞 열(세로줄: 변수)들의 정보를 알립니다.\ndim : 열과 행(가로줄: 사례)의 숫자를 알립니다.\ntail : 뒤 열들의 정보를 알립니다.\nstr : 변수의 정보를 알립니다. (chr은 문자, num은 숫자, dbl은 소숫점을 가진 숫자)\nnames : 변수들의 이름으로 구성한 벡터를 되줍니다.\n\n데이터셋의 자료형태는 티블 tibble 자료형과 데이터프레임 data.frame 자료형이 있습니다. 티블은 데이터 프레임을 우리가 흔히 보는 형태로 바꾸어 준 것입니다. 우리는 데이터를 저장할 때 (즉 엑셀에 넣을 때) 사례는 열로, 변수는 행으로 저장합니다. 이것이 우리가 흔히 보는 데이터 저장 방식으로 티블 tibble 자료형입니다. 위에서 여러 함수들을 이용해서 msleep 정보를 꺼낼 때 맨 위에 나타나는 tibble은 이 데이터셋이 티블 형태라는 걸 알립니다.\n데이터프레임 자료형을 티블 자료형으로 변환하려면 as_tibble( ) 함수를 사용하고, 직접 만들려면 tibble( ) 함수를 사용합니다. (먼저 tibble 패키지를 활성화할 필요가 있을지 몰라요.)\n\n?msleep\n\n위 코드의 실행 결과는 도움 패널에 나타나며 msleep 데이터셋의 자세한 설명을 알려줍니다. 아직 msleep은 환경 패널 Environment Panel 의 변수 목록에 나타나지 않았다는 걸 주목하세요. 목록에 포함하려면 아래 코드를 실행합니다.\n\ndata(msleep)\n\n자, 이제 환경 패널의 데이터 목록에 나타났습니다. 환경패널의 msleep 왼쪽의 작고 파란 삼각형을 클릭해서 msleep 데이터셋을 펼쳐보면 변수 목록과 속성이 나타납니다.\n\n3.6.1 숫자형 자료\n숫자형 자료 numerical data 의 기술적 통계를 산출하는 간단한 방법은 summary 함수에요. 문자 변수에는 아무 정보도 되주지 않고, 숫자 변수에는 여러 정보를 되줍니다.\n\nsummary(msleep)\n\n     name              genus               vore              order          \n Length:83          Length:83          Length:83          Length:83         \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n                                                                            \n conservation        sleep_total      sleep_rem      sleep_cycle    \n Length:83          Min.   : 1.90   Min.   :0.100   Min.   :0.1167  \n Class :character   1st Qu.: 7.85   1st Qu.:0.900   1st Qu.:0.1833  \n Mode  :character   Median :10.10   Median :1.500   Median :0.3333  \n                    Mean   :10.43   Mean   :1.875   Mean   :0.4396  \n                    3rd Qu.:13.75   3rd Qu.:2.400   3rd Qu.:0.5792  \n                    Max.   :19.90   Max.   :6.600   Max.   :1.5000  \n                                    NA's   :22      NA's   :51      \n     awake          brainwt            bodywt        \n Min.   : 4.10   Min.   :0.00014   Min.   :   0.005  \n 1st Qu.:10.25   1st Qu.:0.00290   1st Qu.:   0.174  \n Median :13.90   Median :0.01240   Median :   1.670  \n Mean   :13.57   Mean   :0.28158   Mean   : 166.136  \n 3rd Qu.:16.15   3rd Qu.:0.12550   3rd Qu.:  41.750  \n Max.   :22.10   Max.   :5.71200   Max.   :6654.000  \n                 NA's   :27                          \n\n\n개별 정보를 알고 싶을 때는 아래의 함수를 사용합니다. 개별 변수를 나타내는 방법은 데이터셋이름$변수이름 입니다. 아래의 통계에 대한 자세한 것은 6 장 기술적 통계에서 배울 겁니다.\n\nlibrary(ggplot2)\nmean(msleep$sleep_total)      # 평균\nmedian(msleep$sleep_total)    # 중앙값\nmax(msleep$sleep_total)       # 최대값\nmin(msleep$sleep_total)       # 최소값\nsd(msleep$sleep_total)        # 표준편차\nvar(msleep$sleep_total)       # 분산\nquantile(msleep$sleep_total)  # 사분위값\n\n[1] 10.43373\n[1] 10.1\n[1] 19.9\n[1] 1.9\n[1] 4.450357\n[1] 19.80568\n   0%   25%   50%   75%  100% \n 1.90  7.85 10.10 13.75 19.90 \n\n\n하루 8시간 이상 자는 포유 동물의 빈도나 비율을 알려면 아래처럼 합니다.\n\nsum(msleep$sleep_total &gt; 8)   # 빈도 (숫자)\nmean(msleep$sleep_total &gt; 8)  # 상대빈도 (비율)\n\n[1] 61\n[1] 0.7349398\n\n\n결측값이 있을 때 옵션을 넣어야 해요. 그냥 하면 NA가 나옵니다.\n\nmean(msleep$sleep_rem)\n\n[1] NA\n\n\n결측값을 무시하라는 조건을 넣습니다.\n\nmean(msleep$sleep_rem, na.rm = TRUE)\n\n[1] 1.87541\n\n\n변수가 두 개 이상이 연관되는 함수의 결측값 조건은 use를 써요. 아래는 변수 하나라도 결측값이 있으면 그 쌍은 통계에 포함하지 말라는 옵션이에요.\n\ncor(msleep$sleep_total, msleep$sleep_rem, use = \"complete.obs\")\n\n[1] 0.751755\n\n\n\n\n3.6.2 범주형 자료\n범주형 자료 categorical data 의 예입니다. vore와 conservation 변수는 범주형입니다. 이런 범주형 변수는 평균, 최대값 같은 건 의미가 없어요. 테이블을 만들어 빈도를 보는 게 좋아요. 범주형 변수는 R에서 요인 factor 이라고 부르기도 합니다. 테이블을 만드는 함수는 table입니다.\n\ntable(msleep$vore)\n\n\n  carni   herbi insecti    omni \n     19      32       5      20 \n\n\n빈도 테이블을 비율/상대빈도로 변환하는 함수는 proportions에요.\n\nproportions(table(msleep$vore))\n\n\n     carni      herbi    insecti       omni \n0.25000000 0.42105263 0.06578947 0.26315789 \n\n\n교차 테이블을 만드는 데도 table 함수를 사용합니다. margin의 null, 1, 2는 전체, 행, 열 중에 어느 것이 100%인지 선택하는 조건입니다.\n\n# 빈도\ntable(msleep$vore, msleep$conservation) \n# 비율, margin=1은 행으로 per row:\nproportions(table(msleep$vore, msleep$conservation),\n            margin = 1) \n# 비율, margin=2는 열로 per column: \nproportions(table(msleep$vore, msleep$conservation),\n            margin = 2)"
  },
  {
    "objectID": "base-r.html#sec-bas-num-plot",
    "href": "base-r.html#sec-bas-num-plot",
    "title": "3  R 기본",
    "section": "3.7 숫자형 자료의 그래프",
    "text": "3.7 숫자형 자료의 그래프\n주장이나 논리를 펼 때 근거를 제시해야 합니다. 특히 숫자나 통계를 근거로 제시하는 건 최고죠. 그런데 이걸 그림으로 제시하는 것, 특히 한 눈에 확 이해가 되도록 제시하는 것은 근거인 동시에 최상의 논리라고 말할 수 있습니다. 그래서 시각적 그래프는 중요합니다. Financial Times에서 제공한 Visual Vocabulary 를 보면 숫자로 주장하는 시각에 따라 다양한 그래프가 있음을 알게 됩니다.\n\n\n\nFT의 Chart Doctor: Visual Vocabulary\n\n\n그래프를 그릴 때 주로 ggplot2 패키지를 사용합니다. 이 패키지는 소위 그래프 문법이란 걸 이용합니다. 그래프 문법은 여러 종류의 그래프를 그릴 때 동일한 논리와 함수를 사용하는 걸 의미합니다.\n그래프 문법의 중요한 삼 요소는 아래와 같아요.\n\n데이터: 데이터셋\n미학 aesthetics: 그래프의 시각적인 아름다움 (축의 길이나 기호들의 크기 등)\n기하학 geom : 기하학적 객체 geometric objects\n\n\n3.7.1 그래프\n그냥 기본 패키지로 그린다면,\n\nplot(msleep$sleep_total, msleep$sleep_rem)\n\n\n\n\n더 멋있게 그린다면,\n\nlibrary(ggplot2)\nggplot(msleep, aes(x = sleep_total, y = sleep_rem)) + \n   geom_point()\n\nWarning: Removed 22 rows containing missing values (`geom_point()`).\n\n\n\n\n\n여기서 그래프 문법의 삼 요소는 데이터: msleep, 미학: aes 함수(x축, y축), 기하학: geom_point로 각각 나타납니다. 물론 기본 패키지의 plot 함수로 아래처럼 유사하게 그릴 수 있어요.\n\nplot(msleep$sleep_total, msleep$sleep_rem, pch = 16)\ngrid()\n\n\n\n\n그러나 ggplot2 패키지를 사용하면 여러 조건을 주지 않고 쉽게 그리지요. 기본 형식인 ggplot(data, aes) + geom 을 사용하기 때문입니다. 앞의 ggplot 그래프에서 x=과 y=을 생략하고 코드를 만들면 아래와 같고 결과는 동일합니다.\n\nggplot(msleep, aes(sleep_total, sleep_rem)) + geom_point()\n\n\n\n3.7.2 색깔, 모양, 축의 이름표\n축 이름표는 앞의 ggplot 코드 뒷부분에 +를 이용해 덧붙이면 됩니다. xlab 과 ylab 함수를 사용합니다.\n\nggplot(msleep, aes(sleep_total, sleep_rem)) + \n   geom_point() + \n   xlab(\"Total sleep time (h)\")\n\n\n\n\n실행 결과에 결측값에 관한 경고가 나오니까 #| warning: false를 넣어 안 나오게 합니다.\n그래프 안의 점에 색깔을 넣는다면 geom_point에서 color=\"색깔이름\"을 사용합니다.\n\nggplot(msleep, aes(sleep_total, sleep_rem)) + \n   geom_point(colour = \"blue\") + \n   xlab(\"Total sleep time (h)\")\n\n\n\n\n색깔 이름을 찾으려면 콘솔 패널에서 colors( ) 함수를 실행하세요. 복사해서 코드에 이름을 넣는 순간 색깔이 나타나니까 어떤 색인지 볼 수 있어요. “#FF5733” 같은 헥사 코드로 넣어도 됩니다.\n위의 숫자형 변수 두 개에 범주형 변수인 vore를 하나 추가해서 그래프를 그릴 수 있어요. 그럴 때 범주형 변수의 범주 네 종류의 색깔을 다르게 하는 색깔 조건을 aes에 넣어야 합니다. 바로 colour = vore 입니다.\n\nggplot(msleep, aes(sleep_total, sleep_rem, colour = vore)) + \n   geom_point() + \n   xlab(\"Total sleep time (h)\")\n\n\n\n\n숫자형 변수를 추가하고 색깔을 넣으면 어떻게 될까요? 가능할까요?\n\nggplot(msleep, aes(sleep_total, sleep_rem, colour = sleep_cycle)) + \n      geom_point() + \n      xlab(\"Total sleep time (h)\")\n\n\n\n\n오! 됩니다. 색깔을 달리하지 않고 한 가지 색을 농도의 옅고 짙은 정도로 숫자의 크기를 표시해서 그립니다. 대단하지요?\n색깔 colour= 옵션 동일한 용도와 형식으로 모양 shape=, 크기 size= 등의 옵션을 사용합니다.\n\n\n3.7.3 축의 한계와 크기\nggplot 함수에 + xlim 과 ylim을 사용합니다. 아래 둘을 비교해봅시다.\n\nggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + \n      geom_point() + \n      xlab(\"Brain weight\") + \n      ylab(\"Total sleep time\")\n\n\n\n\n\nggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + \n      geom_point() +\n      xlab(\"Brain weight\") +\n      ylab(\"Total sleep time\") +\n      xlim(0, 1.5)\n\n\n\n\n둘째 그래프의 x축 한계가 5에서 1.5로 되어 보기가 더 좋지요. 물론 아웃라이어/극단값 두 개가 빠져버린 것은 아쉽지만.\n좀 어렵지만, brainwt 변수를 로그로 변환하면 더 좋아집니다. aes함수 안에 log 함수를 넣습니다.\n\nggplot(msleep, aes(log(brainwt), sleep_total, colour = vore)) + \n      geom_point() +\n      xlab(\"log(Brain weight)\") +\n      ylab(\"Total sleep time\")\n\n\n\n\n그런데 로그로 변환한 brainwt변수는 잘 이해가 되지 않으니까 brainwt 변수는 놔두고 그냥 x축을 로그 스케일로 바꾸는 게 더 이해가 잘 될 겁니다. 뒤에 + scale_x_log10( ) 조건을 붙입니다.\n\nggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + \n      geom_point() +\n      xlab(\"Brain weight (logarithmic scale)\") +\n      ylab(\"Total sleep time\") +\n      scale_x_log10()\n\n\n\n\nx축 길이는 로그 스케일이지만 숫자(변수값)는 그대로여서 이해하기가 훨씬 편합니다.\n\n\n3.7.4 집단 비교하기\n집단을 비교하는 그래프를 잘 그리는 방법은 포세팅 facetting 입니다. 포세팅은 다면체에서 각 면을 나타내는 기하학 기법을 말하는데, 그래프에서는 각 집단 별로 산포도를 각각 그리는 기법을 의미합니다. 예를 들어, 범주형 변수인 vore 는 네 개 범주가 있는데 각 범주 별로 산포도 그래프를 각각 그리는 방법입니다.\n\nggplot(msleep, aes(brainwt, sleep_total)) + \n      geom_point() +\n      xlab(\"Brain weight (logarithmic scale)\") +\n      ylab(\"Total sleep time\") +\n      scale_x_log10() +\n      facet_wrap(~ vore)\n\n\n\n\n\n\n3.7.5 박스플롯\n집단을 비교하는 또다른 방법은 박스플롯 boxplot 입니다. ggplot2 패키지의 ggplot 함수를 이용합니다. R 기본 패키지의 boxplot 함수를 이용해도 좋아요.\n\n# R 기본 패키지:\nboxplot(sleep_total ~ vore, data = msleep)\n\n\n\n\n\n# ggplot2 패키지:\nggplot(msleep, aes(vore, sleep_total)) +\n      geom_boxplot()\n\n\n\n\n박스 그래프는 summary 함수가 되주는 수치와 유사한 시각 정보를 줍니다. 여기에 포함하는 건 중앙값, 1사분위, 3사분위, 최소값, 최대값, 아웃라이어 등입니다\n그래프 문법의 삼요소는 데이터: msleep, 미학: aes, 지옴: geom_boxplot 등입니다.\n\n\n3.7.6 히스토그램\n서로 붙은 막대그래프를 히스토그램이라고 합니다. R 기본 패키지와 ggplot2 패키지를 비교해봅시다.\n\n# R 기본 패키지:\nhist(msleep$sleep_total)\n\n\n\n\n\nggplot(msleep, aes(sleep_total)) +\n      geom_histogram()"
  },
  {
    "objectID": "base-r.html#범주형-데이터-그래프",
    "href": "base-r.html#범주형-데이터-그래프",
    "title": "3  R 기본",
    "section": "3.8 범주형 데이터 그래프",
    "text": "3.8 범주형 데이터 그래프\n범주형 데이터를 시각화할 때 각 범주별로 빈도를 보여주는 경향이 높습니다. 대개 막대 그래프를 이용합니다.\n\n3.8.1 막대 그래프\n아래 두 개를 비교해봅시다.\n\n# R 기본 패키지:\nbarplot(table(msleep$vore))\n\n\n\n\n\n# ggplot2 패키지: \nggplot(msleep, aes(vore)) +\n      geom_bar()"
  },
  {
    "objectID": "base-r.html#그래프-저장하기",
    "href": "base-r.html#그래프-저장하기",
    "title": "3  R 기본",
    "section": "3.9 그래프 저장하기",
    "text": "3.9 그래프 저장하기\nggplot2를 이용해서 그래프를 그리면, 그 결과를 R 안에서 저장할 수 있어요. 마치 변수나 데이터셋처럼.\n\nmyPlot &lt;- ggplot(msleep, aes(sleep_total, sleep_rem)) +\n      geom_point()\n\n이제 myPlot라는 이름으로 그래프가 R 안에 저장이 되었어요. 콘솔에 myPlot를 적고 실행하면 (엔터 치면) Plots 패널에 그래프가 나타날 거에요.\n이렇게 저장하면 뭐가 좋을까요? 다시 그래프를 그릴 필요가 없어요. 이름에 xlab함수만 추가하면 x축 레이블이 바뀌어서 그려질 거에요.\n\nmyPlot + xlab(\"이건 x 라벨\")\n\n\n\n\n이미지 파일로 그래프를 저장할 수 있어요.\n\nggsave(\"filename.pdf\", myPlot, width = 5, height = 5)\n\n만일 그래프 이름을 넣지 않으면 맨 마지막에 생성한 ggplot2 그래프를 저장합니다. 여기서 단위는 인치니까 만일 단위를 바꾸려면 units을 사용하세요. 파일 형태도 jpg, tif, png 등으로 바꿀 수 있어요.\npdf나 png 함수를 사용해 그래프를 저장할 수 있는데 마지막에 dev.off를 넣어야 해요.\n\npdf(\"filename.pdf\", width = 5, height = 5)\nmyPlot\ndev.off()\n\n\npng(\"filename.png\", width = 500, height = 500)\nplot(msleep$sleep_total, msleep$sleep_rem)\ndev.off()\n\n워킹 폴더에서 파일들이 저장이 되었나 확인해보세요. filename.pdf 나 filename.png 파일이 있으면 성공한 거지요. 아마도 실제로 일할 때는 파일 이름을 제대로 Plots 패널에서 Export 버튼을 클릭해서 저장하지만, 코드를 이용해서 저장하는 게 효율적이에요. 왜냐하면 나중에 추가하거나 고치기가 아주 쉽죠."
  },
  {
    "objectID": "base-r.html#문제-해결하기",
    "href": "base-r.html#문제-해결하기",
    "title": "3  R 기본",
    "section": "3.10 문제 해결하기",
    "text": "3.10 문제 해결하기\n코드 실행에 문제가 생기면 두 경우가 가장 많아요. 첫째 스펠링이 틀리거나 둘째 사용한 함수를 포함한 패키지를 설치하지 않거나 활성화하지 않는 것.\n에러가 났을 때 에러 메시지를 주의깊게 읽고 파악하는 게 좋아요. 자꾸 에러 메시지를 읽고 고치다보면 에러 메시지를 파악하는 데에 익숙해질 거에요."
  },
  {
    "objectID": "write-quarto.html#quarto로-보고서-작성",
    "href": "write-quarto.html#quarto로-보고서-작성",
    "title": "4  Quarto 사용하기",
    "section": "4.1 Quarto로 보고서 작성",
    "text": "4.1 Quarto로 보고서 작성\n마크업 Markup 이라는 컴퓨터 언어가 있습니다. 컴퓨터 언어지만 워드프로세서 기능을 하므로 일반 컴퓨터 언어와 달리 사용하기가 매우 쉽습니다. 그걸 쉽게 개선한 언어가 마크다운 Markdown 이고, 그걸 R용으로 더 쉽게 개선한 것이 R 마크다운입니다. 그러니 R 마크다운은 사용하기가 정말로 편합니다. 이걸 한 번 더 개선해서 R뿐만 아니라 다양한 컴퓨터 언어에 사용하도록 만든 범용이 Quarto입니다. “Quarto”는 출판업계 용어이며, 인쇄에 사용하는 큰 종이를 두 번 접어 1/4 크기로 만든, 책 크기를 뜻한답니다. 복사에 흔히 사용하는 A4 용지보다 약간 큰 크기입니다.\n콰르토는 워드 프로세서입니다. 말하자면, 아래한글이나 MS 워드와 같은 기능을 합니다. 그러나 일반 워드프로세서는 글을 작성하는 즉시 출력 형태가 화면에 그대로 보이지만, 콰르토는 그걸 실행하고 (render) 난 결과물이 출력물이라는 겁니다. 즉 실행하고 출력물을 봐야 비로소 결과를 알 수 있습니다. 물론 R Studio의 Visual 모드를 사용하면 출력물의 형태를 어느 정도 실시간으로 미리 볼 수 있으나 한계가 존재합니다.\n콰르토의 좋은 점은 그 안에서 R 이나 파이썬을 포함한 몇 개의 컴퓨터 언어를 사용할 수 있다는 겁니다. 그래서 보고서 안에서 R을 실행하고 그 결과를 표나 그래프로 즉각적으로 포함할 수 있습니다. 또 다른 특징은 포맷이 일정한 틀을 지닌다는 점입니다. 즉 미리 정한 표준 포맷을 사용하므로 시간과 노력을 절약하고 다른 이들과 협업이 쉽다는 겁니다. 그래서 앞으로 직장에서 콰르토를 많이 사용할 것으로 예상합니다. 물론 미리 정한 포맷을 사용하므로 어느 정도 개성있는 포맷은 포기해야 합니다. 그렇지만 일반 사용자가 만들 수 있는 포맷보다는 아주 훨씬 훌륭합니다.\n\n4.1.1 콰르토의 작동 단계\n콰르토로 문서를 작성하고 렌더 Render를 클릭하면 원하는 최종 문서로 출력합니다. 이때 .qmd 파일이 .md (Markdown) 파일이 되고 또 pandoc 파일로 번역되어 최종 문서를 출력합니다. 최종 문서는 주로 웹페이지인 .html 파일로 출력하지만 .pdf 나 MS 워드 .docx 파일로 출력할 수도 있습니다.\n\n\n\nFigure 4.1: Quarto 작동 단계: R Studio\n\n\n\n\n4.1.2 콰르토 시작하기\n새 콰르토 문서를 만드는 가장 편한 방법이 RStudio를 이용하는 겁니다. RStudio를 열고 메뉴 왼쪽 위 File &gt; New File &gt; Quarto Document 를 차례로 클릭하면 새 문서를 가져옵니다.\n콰르토는 R 스튜디오에 포함되어서 별도로 설치할 필요가 없습니다. 혹시 New File 에서 나타나지 않으면 설치가 안 된 것일 수 있으니, 콰르토 사이트에 가서 다운로드해 설치하면 R 스튜디오에 나타납니다. (https://quarto.org)\nR스튜디오에서 File &gt; New File &gt; Quarto Document 를 클릭하면 콰르토 파일이 형성되니까 바로 사용합니다. 콰르토 파일을 맨 처음 생성하면 관련 패키지를 설치해야 (install) 할 수도 있습니다. 만일 그렇다면 그냥 설치하면 됩니다.\n콰르토 새 파일을 열면 제일 위에 아래와 같이 YAML 언어가 써 있습니다. 이것은 ---로 아래 위로 둘러싸인 부분입니다. ---와 첫 줄 사이에 빈 줄이 없어야 합니다.\n---\ntitle: \"Untitled\"\n---\nYAML 언어는 두 가지 기능을 합니다. 첫째는 한 컴퓨터 언어에서 다른 컴퓨터 언어로 데이터를 전해주는 역할입니다. 여기서는 콰르토 언어에서 마크다운 언어를 거쳐 최종 아웃풋을 만드는 Pandoc 언어로 포맷과 관련한 메타 데이터를 전달합니다. 둘째는 전달하는 정보를 사람이 알아보기 쉬운 형태로 작성하는 겁니다. 위의 YAML 언어도 척 보면 무슨 말인지 알 수 있습니다. R 마크다운의 단점 중 하나가 YAML 언어를 다루기 힘든 것이었는데 콰르토에서는 다루기 쉽게 되었습니다.\n사실 새 문서 첫 머리의 YAML 부분이 없어도 문제없이 작동합니다. 여러분이 작성하는 파일은 기본적인 것이니까요. YAML은 주로 콰르토 파일의 아웃풋에 관련한 내용이며, 현재 단계에서는, 그냥 그런 것이 있다고 받아들이면 됩니다.\n아래는 세줄 짜리 YAML 예입니다. html은 웹페이지로 출력하라는 명령이고 visual은 R 스튜디오에서 Visual 에디터 모드를 사용한다는 겁니다. R 스튜디오에서 에디터 모드는 언제든 바꿀 수 있습니다. 만일 워드 파일 docx 로 출력하려면 format: html을 format: docx로 수정합니다.\n---\ntitle: \"Hello, Quarto\"\nformat: html\neditor: visual\n---\n아래는 Quarto 새 파일을 열었을 때 나오는 화면입니다. 위의 둘은 각각 Source 모드와 Visual 모드이고, 아래는 편집 창 바로 위 가운데의 Render 버튼을 눌렀을 때 Viewer 탭 패널에 나타나는 최종 출력물입니다. Rendering은 Quarto 파일이 저장되어야 가능하므로 아마도 파일이름을 넣어 저장하라는 창이 먼저 뜰 겁니다.\n\n\n\n콰르토 새 파일: Source 편집 모드\n\n\n\n\n\n콰르토 새 파일: Visual 편집 모드\n\n\n\n\n\n콰르토 새 파일: html 형태의 최종 출력물\n\n\n위의 편집화면이 둘 다 까맣게 나오지요? 그건 눈부심을 방지하려고 편집 화면의 테마를 그렇게 설정한 겁니다. 아래 그림에서 Editor theme을 Tomorrow Night Bright로 선택한 결과입니다. Editor font도 D2 coding ligature로, default가 아닌 걸로 따로 설치하고 선택했습니다. 한글은 편집 화면 글자가 그게 예쁘게 나온다고 합니다. 혹시 여러분도 변경하려면 R Studio 맨위 메뉴 띠에서 Tools &gt; Global Options.. &gt; Appearandce 창으로 가서 해당 옵션을 선택하고 OK 버튼을 클릭하세요.\n\n\n\nQuarto 편집 화면 옵션"
  },
  {
    "objectID": "write-quarto.html#콰르토-편집-방법",
    "href": "write-quarto.html#콰르토-편집-방법",
    "title": "4  Quarto 사용하기",
    "section": "4.2 콰르토 편집 방법",
    "text": "4.2 콰르토 편집 방법\n여기에 나오는 편집 방법은 Quarto/Markdown에서 사용하는 방법입니다. R Studio를 보면 스크립트 패널 바로 위 왼쪽 끝에 Source 와 Visual 에디터 버튼이 있습니다. 여기에 지금부터 나오는 내용은 Source 모드에서 사용하는 것입니다. Visual 모드에서는 그 줄에 나타나는 여러 버튼들을 사용하면 편리합니다. 물론 두 에디터 모드는 언제든지 버튼을 눌러서 서로 편집방법을 바꿀 수 있습니다. 초보자는 Visual 모드를 사용하는 게 편리합니다. 익숙해지면 아마도 Source 모드가 더 편해질 겁니다.\n\n4.2.1 본문 내용, 줄바꿈\n본문은 그냥 타이핑해서 넣으면 됩니다. 출력문의 폰트와 크기는 원래 디폴트로 정한 것으로 나타납니다. 다르게 하려면 YAML 파일이나 옵션을 변경해야 하는데 좀 복잡할 수 있으니 그냥 디폴트를 사용하는 걸 권장합니다.\n띄어쓰기를 할 때 편집하는 본문에서 한 칸을 띄나 두 칸을 띄나 Quarto는 출력문에서 한 칸을 띕니다. 즉 .qmd 파일에서는 두 칸 또는 그 이상 칸을 띈 부분은 html 등 출력문에서는 한 칸 띈 것으로 나타납니다.\n마찬가지로 본문에서 Enter 키를 쳐서 줄을 바꾸어도 Quarto는 줄을 바꾸지 않은 것으로 인식합니다. 즉 Enter 키를 쳐서 줄을 바꾼 것이나 바꾸지 않고 그냥 한 줄로 죽 쓴 것이나 출력물은 동일합니다.\n문단을 나누고 싶으면, 즉 아래한글이나 MS 워드에서 Enter 키를 친 것과 동일한 결과를 가져오고 싶으면, Enter 키를 두 번 쳐서 앞 줄과 뒷 줄 사이에 빈 줄이 하나 들어가면 됩니다. 빈 줄이 하나건 둘이건 출력물은 동일한 결과가 나옵니다.\n만일 문단을 나누지 않고 그냥 줄바꿈을 하고 싶으면, 즉 아래한글이나 MS 워드에서 Shift+Enter 키를 친 것과 동일한 결과를 가져오고 싶으면, 줄바꿈 전의 줄 마지막에 빈칸을 두 개나 그 이상 넣으면 줄바꿈을 합니다. 또는 줄바꿈 전의 줄 마지막에 &lt;br&gt; 이라는 html 태그를 직접 넣으면 됩니다.\n\n\n\n\n\n\nImportant\n\n\n\n위에 적은 것처럼 Quarto에서 빈칸이, 일반적인 아래한글이나 워드를 사용할 때와 역할이 좀 다른 경우가 있습니다. 주의하세요!\n\n\n\n\n4.2.2 섹션 제목\nh1부터 h6까지 표현할 수 있으며, #의 갯수로 표현합니다. 6개까지 가능합니다.\n# chapter title\n## section title\n### subsection title\n#### header4 title\nchapter title은 장 chapter의 제목이며 제일 큰 폰트로 나타납니다. section title은 절 section 의 제목이며 장보다는 작은 폰트입니다. 그 아래 소제목들도 #의 갯수에 따라서 폰트의 크기가 상대적으로 작아집니다.\n\n\n4.2.3 코드청크\n```를 아래 위로 넣어서 표시합니다. `는 백틱 backtick 이라 부르고 자판 왼쪽 위 구석에 있습니다. 코드청크 블락은 단축키 Ctrl+Alt+i 를 누르면 자동으로 본문에 삽입됩니다. 또는 메뉴의 Code &gt; Insert Chunk 를 사용합니다.\nVisual 에디터 모드에서는 에디터 창 바로 위의 Insert 단추를 클릭해서 코드청크를 넣어도 됩니다. 대체로 단축키 Ctrl+Alt+i 의 사용이 가장 간편합니다.\n옵션의 종류는 아래와 같습니다. 모두 Render 단추를 눌렀을 때 출력의 결과에 대한 옵션입니다. 옵션 앞에는 모두 #|가 붙어야 합니다. 코드청크 오른 위의 조그만 삼각형 실행버튼을 누르면 코드청크가 실행하는데, 그때는 옵션과 관계없이 실행합니다.\n\ninclude: false : 코드를 실행하지만 코드와 결과는 마지막 아웃풋에 출력하지 않는다. 코드의 결과는 다른 청크에서 사용할 수 있다. (예: 변수나 그래프를 만들고 그걸 다른 청크에서 사용)\necho: false : (코드를 실행하지만) 코드를 아웃풋에 출력하지 않는다.\neval: false : 코드를 실행하지 않는다. (코드는 아웃풋에 나타난다.)\nwarning: false : 코드를 실행해서 나타난 경고를 아웃풋에 출력하지 않는다.\nerror: true : 청크에서 에러가 나도 R Markdown 문서를 계속 실행한다\ncollapse: true : 청크 안의 각 코드 실행 결과를 나누지 않고 한 곳으로 몰아 output에 출력한다\nmessage: false : 코드를 실행해서 나타난 메시지를 아웃풋에 출력하지 않는다.\nresult: \"hide\" 문자로 된 실행 결과물을 output에 안 넣는다.\nfig-show: \"hide\" : 그래프를 output에 안 넣는다\nfig-cap: \"내용\" : 코드를 실행해서 얻은 그래프에 캡션을 단다.\n\n아래 두 개의 청크 옵션 결과를 비교해봅시다.\n```{r}\n#| echo: false\nsummary(cars)\n```\n위와 같이 echo: false 옵션을 주면 아래처럼 코드는 출력하지 않고 결과만 출력합니다.\n\n\n     speed           dist       \n Min.   : 4.0   Min.   :  2.00  \n 1st Qu.:12.0   1st Qu.: 26.00  \n Median :15.0   Median : 36.00  \n Mean   :15.4   Mean   : 42.98  \n 3rd Qu.:19.0   3rd Qu.: 56.00  \n Max.   :25.0   Max.   :120.00  \n\n\n이번에는 eval: false 옵션을 봅니다. 아래처럼 적습니다. 그러면 eval: false는 코드는 출력하지만 실행하지 않으므로 결과는 나타나지 않습니다.\n\n```{r}\n#| eval: false\nsummary(cars)\n```\n\n코드 청크에 이름(id)을 붙일 수 있고, 캡션(제목)을 붙여 나중에 자동으로 그래프에 번호가 붙습니다. 이때 그래프 이름(id)은 반드시 fig- 가 앞에 붙어야 합니다. 만일 코드청크가 테이블을 그리는 것이라면 이름(id) 앞에 반드시 tbl- 가 붙어야 합니다.\n이름을 붙인 것은 본문 다른 곳에서 링크할 수 있습니다. 이렇게 코드 청크에 이름을 붙이고, 본문의 다른 곳에서 @fig-pressureplot라고 적으면 Figure 4.2 로 출력합니다. 클릭하면 그 플롯으로 이동합니다.\n\n```{r}\n#| label: fig-pressureplot\n#| fig-cap: \"이것은 플롯 제목\"\n\nplot(pressure)\n```\n\n\n\n\nFigure 4.2: 이것은 플롯 제목\n\n\n\n\n\n\n4.2.4 폰트 스타일\n_나 *가 한 번이면 기울인 이탤릭체, 두 번이면 굵은 볼드체입니다.\n__굵게__\n**굵게**\n_기울여 쓰기_\n*기울여 쓰기*\n~~취소선~~\n윗첨자^2^\n아래첨자~2~\n굵게  굵게  기울여 쓰기  기울여 쓰기  취소선  윗첨자2  아래첨자2\n\n\n4.2.5 링크 넣기\n아래의 첫 줄처럼 적으면 뒷 줄처럼 출력합니다. 여기서는 “쿼르토 가이드”란 글귀가 인터넷 콰르토 사이트와 링크되었습니다. 링크된 글자들을 클릭하면 그 사이트로 이동합니다. []와 () 사이에 빈칸이 있으면 안됩니다.\n[쿼르토 가이드](https://quarto.org/docs/guide/)를 참조하세요\n쿼르토 가이드를 참조하세요.\n같은 사이트를 여러 번 링크할 때 아래처럼 이름/번호를 넣어주고 나중에 본문 아무곳이나 그 이름/번호를 정의해주면 편합니다. 청크 아래에 출력이 나와있는데, 출력에서 [1]과 [1]: https://commonmark.org/help/는 나타나지 않습니다.\n아주 간단히 마크다운을 배우려면 [여기][1]를 클릭해주세요. \n[1]: https://commonmark.org/help/\n아주 간단히 마크다운을 배우려면 여기를 클릭해주세요.\n\n\n4.2.6 그림 넣기\n아래처럼 그림을 넣을 수 있습니다. 아래 첫 줄은 사이트에서 그림을 가져오는 코드고 그 아래 그림이 가져온 그림입니다. 둘째 줄처럼 자신의 폴더에서 그림을 넣어도 됩니다. []와 (), 그리고 {}는 붙여야 합니다. 즉 사이에 빈칸이 있으면 안됩니다.\n![Quarto 로고](https://quarto.org/quarto.png){fig-align='left'}\n\n\n\nQuarto 로고\n\n\n![Quarto 로고](quarto.png){fig-align='left'}\n그림에 링크를 걸 수 있습니다. 아래의 첫 줄처럼 콰르토 파일에 적고 출력한 다음에, 출력한 그림을 클릭하면 그 사이트로 갑니다. 만일 그림의 제목을 넣지않고 그냥 []을 적으면 그림만 출력합니다. 아래의 그림은 제목이 없이 그림만 있는 예이며, 그래서 그림을 클릭하면 Quarto 사이트로 갑니다.\n[![Quarto](https://quarto.org/quarto.png)](https://quarto.org)\n\n\n\n\n\n\n\n4.2.7 인라인 코드 넣기\n일반글 속에 r 코드를 넣을 수 있습니다. 코드 앞뒤에 `를 붙이면 됩니다. 이것은 간단한 계산을 한다던지, 특히 변수를 불러와서 변수값을 출력할 때 아주 편리합니다. r 코드는 앞에 r을 붙입니다. 만일 python이면 `python code`라고 적습니다. 아래는 청크에서 계산하고 그 값을 본문에 출력하는 예입니다.\n```{r}\nmonth_sale &lt;- 18,000,000\n```\n\"이번 달의 매출액은 `r month_sale`원입니다.\"로 적어 넣으면, \n\"이번 달의 매출액은 18,000,000 원입니다.\"로 출력합니다. \n\n\n4.2.8 수식 넣기\n수식을 넣는 방식은 두 가지가 있습니다. 하나는 일반 문장 속에 들어가는 겁니다 $를 수식 양 끝에 하나씩 넣으면 됩니다. 별도의 줄에 들어가는 방식은 $$를 수식 양 끝에 넣은 겁니다.\n\n$a^2 + b ^ 2 = c^2$ : 문장 안에 수식을 LaTEx 를 이용해서 이처럼 \\(a^2 + b ^ 2 = c^2\\) 넣는다\n$$a^2 + b ^ 2 = c^2$$ : 새 줄을 만들어 그 중앙에 수식을 넣는다\n\n\\[a^2 + b ^ 2 = c^2\\]\n\n\n4.2.9 수평선 넣기\n---를 입력하면 수평선을 그릴 수 있습니다.\n결과는 아래와 같습니다.\n\n\n\n4.2.10 리스트, 표, 그림 넣기\n글머리 기호와 들여쓰기를 자동으로 하는 걸 리스트 list 라고 합니다.\n* 하나 1\n* 하나 2\n  + 아래하나 1\n  + 아래하나 2\n* 하나 3\n위처럼 적으면 아래처럼 출력합니다.\n\n하나 1\n하나 2\n\n아래하나 1\n아래하나 2\n\n하나 3\n\n글머리 번호를 붙이려면 문장 맨처음에 숫자와 마침표를 차례로 넣습니다.\n1. 하나 1\n2. 하나 2\n    i) 아래하나 1\n    ii) 아래하나 2\n1. 하나 3\n첫 머리에 숫자만 붙으면 번호가 달라도 알아서 순서대로 번호를 답니다. 여기서 i)의 들여쓰기는 반드시 네 자, 또는 두 탭을 해야합니다. 글머리 기호는 두 자 들여쓰면 되지만, 숫자는 네 자 들여쓰기입니다.\n\n하나 1\n하나 2\n\n아래하나 1\n아래하나 2\n\n하나 3\n\n\n\n4.2.11 테이블 넣기\n아래처럼 하여 표를 그릴 수 있습니다. | 로 구분하고 -(하이픈)에 각각 왼쪽, 양쪽, 오른쪽에 : 을 붙여서 왼쪽 정렬, 가운데 정렬, 오른쪽 정렬을 합니다. :을 붙이지 않으면 디폴트는 왼쪽 정렬입니다.\n|제목|내용1|내용2|내용3|\n|:---|:---: |---:|---|\n|왼 정렬|중앙 정렬|오른 정렬|디폴트(왼)|\n|왼 정렬|**볼드체 가능**|오른 정렬|디폴트(왼)|\n|왼 정렬|[색 가능]{style=\"color: green\"}|오른 정렬|디폴트(왼)|\n  \n: 테이블 제목 {#tbl-table-id}\n위 내용 중에 색가능은 본문의 일부글 색을 지정할 때 사용합니다. 맨 아래 줄은 테이블의 제목입니다. 아래가 결과입니다.\n\n\nTable 4.1: 테이블 제목\n\n\n제목\n내용1\n내용2\n내용3\n\n\n\n\n왼 정렬\n중앙 정렬\n오른 정렬\n디폴트(왼)\n\n\n왼 정렬\n볼드체 가능\n오른 정렬\n디폴트(왼)\n\n\n왼 정렬\n색 가능\n오른 정렬\n디폴트(왼)\n\n\n\n\n테이블 제목은 없어도 됩니다. 테이블 제목은 두고 번호만 붙이지 않으려면 위에서 {#tbl-table-id} 를 안 넣으면 됩니다. 테이블 제목과 테이블 id 사이에 한 칸 이상의 빈칸이 있어야 합니다. 줄 양 옆 맨끝의 |는 없어도 상관없습니다. 없어도 동일한 출력을 합니다.\n위의 표 그리기는 단순 표 그리기입니다. 격자 표 그리기 Grid Table 를 이용하면 더 정교한 표를 그립니다.\n+---------------------+----------+\n| Property            | Earth    |\n+=============+=======+==========+\n|             | min   | -89.2 °C |\n| Temperature +-------+----------+\n| 1961-1990   | mean  | 14 °C    |\n|             +-------+----------+\n|             | max   | 56.7 °C  |\n+-------------+-------+----------+\n\n: Grid Table 의 예\n\nGrid Table 의 예\n\n\n\n\n\n\n\nProperty\nEarth\n\n\n\n\nTemperature 1961-1990\nmin\n-89.2 °C\n\n\nmean\n14 °C\n\n\nmax\n56.7 °C\n\n\n\n위의 테이블은 격자 테이블 중에서도 좀 복잡한 형태의 예입니다. 칸 수를 조정한 형태입니다. 물론 칸 수가 동일한 형태도 더 쉽게 가능합니다. 단순 격자 테이블과 달리 격자 테이블은, 위의 예처럼, 네모난 형태를 정확하게 맞춰야 출력이 제대로 될 수도 있습니다.\n\n\n4.2.12 다이아그램 넣기\n쿼르토는 mermaid 언어를 이용해서 다이아그램을 넣을 수 있습니다. 만일 위에서 아래로 그리려면 LR (left \\(\\rightarrow\\) right) 대신에 TD를 (top \\(\\rightarrow\\) down) 넣습니다.\n```{mermaid}\n%%| label: fig-diagram-exm\n%%| fig-cap: \"다이어그램 예\"\n%%| fig-align: \"left\"\n\nflowchart LR\n  A[Hard edge] --&gt; B(Round edge)\n  B --&gt; C{Decision}\n  C --&gt; D[Result one]\n  C --&gt; E[Result two]\n```\n\n\n\n\n\nflowchart LR\n  A[Hard edge] --&gt; B(Round edge)\n  B --&gt; C{Decision}\n  C --&gt; D[Result one]\n  C --&gt; E[Result two]\n\n\nFigure 4.3: 다이어그램 예\n\n\n\n\n\n\n\n\n\n\n옵션 표현이 달라요\n\n\n\n여기 코드청크 mermaid 언어에서 옵션을 주는 표현은 %%|입니다. 코멘트는 %%입니다. #|를 사용하는 r과 살짝 다르니까 혼동하지 말고 사용하세요."
  },
  {
    "objectID": "data-transform.html#데이터-프레임과-데이터-종류",
    "href": "data-transform.html#데이터-프레임과-데이터-종류",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.1 데이터 프레임과 데이터 종류",
    "text": "5.1 데이터 프레임과 데이터 종류\n\n5.1.1 데이터 형과 데이터 구조\n데이터 종류가 다르면 사용하는 통계 방법도 달라집니다. 숫자형 데이터를 이용하여 우리는 박스플롯을 그리고 평균을 계산합니다. 범주형 데이터를 이용하여 우리는 막대 그래프를 그리고 빈도표를 보여줍니다. 당연히 R도 데이터 종류가 다르면 다르게 다룹니다.\nR은 6가지 데이터 형 data type 이 있습니다. 대개는 앞 세 개만 알면 됩니다.\n\n숫자형 numeric : 숫자 1 또는 35.124 (double)\n논리형 logical : 참/거짓 값을 가진다. TRUE 또는 FALSE\n문자형 character : 문자 “b” , “여자” “경기도”\n정수형 integer : 정수. R에서 L로 표시한다: 1L, 45L\n허수형 complex : 허수. 2+3i\nraw : raw bytes. 거의 이것을 사용할 일이 없다.\n\n이런 데이터형들이 모여서 데이터 구조 data structure 를 만듭니다. 데이터 구조는 벡터, 데이터 프레임, 팩터 factor, POSIXct 등을 말합니다. POSIXct 는 날짜와 시간을 저장하는 방식입니다.\nR에서 작업의 대상을 객체 object 라고 부르는데 객체는 변수, 벡터, 데이터 프레임, 플롯 등등이 있습니다. 객체가 어떤 종류인지 알려면 typeof나 class 함수를 씁니다. typeof는 데이터 저장형태를 알려주는데 초점이 있고 class는 해당 데이터를 관리하는 방식에 초점이 있습니다.\n\nx &lt;- 6  \ny &lt;- \"파랑\"  \n하 &lt;- TRUE\n\ntypeof(x)\nclass(x) \ncat(\"\\n\")  # 줄바꿈\ntypeof(y)\nclass(y)\ncat(\"\\n\")  # 줄바꿈\ntypeof(하)\nclass(하)\n\n[1] \"double\"\n[1] \"numeric\"\n\n[1] \"character\"\n[1] \"character\"\n\n[1] \"logical\"\n[1] \"logical\"\n\n\n데이터 구조가 벡터일 때는 데이터형이 뭐로 나올까요? 숫자형만 있을 때는 당연히 numeric 으로 나옵니다.\n\n나벡터 &lt;- c(6, 9, 12)\nclass(나벡터)\n\n[1] \"numeric\"\n\n\n벡터에 숫자형, 문자형, 논리형 등 여러 데이터형을 섞어 넣으면 어떻게 될까요? 문자형이 벡터에 포함되면, R은 벡터에 포함한 모든 객체를 강제로 문자형 데이터로 만듭니다. 숫자형이나 논리형은 문자형으로 전환이 가능하지만, 문자형은 숫자형으로 전환이 불가능하기 때문입니다.\n\nall_together &lt;- c(6, \"파랑\", TRUE)\nall_together\nclass(all_together)\n\n[1] \"6\"    \"파랑\" \"TRUE\"\n[1] \"character\"\n\n\n만일 숫자형과 논리형 데이터만 포함한다면 어떨까요? 그러면 R이 숫자형 데이터로 통일합니다. FALSE는 0, TRUE는 1 이 됩니다. 역시 논리형은 숫자형으로 전환이 가능하지만 숫자는 그렇지 못하기 때문입니다.\n\n숫자_논리 &lt;- c(5, TRUE)\n숫자_논리\nclass(숫자_논리)\n\n[1] 5 1\n[1] \"numeric\"\n\n\n이렇게 다른 결과가 나오니까 벡터에 다른 종류의 데이터형을 섞을 때 주의해서 사용해야 합니다. 벡터는 그 안에 포함한 데이터가 모두 동일한 종류 class 입니다. 만일 다른 종류가 섞였으면 통일이 가능한 쪽으로 강제로 한 종류로 통일합니다.\n\n\n5.1.2 테이블 종류\nR에서 사용하는 거의 모든 데이터 분석을 위한 데이터 구조는 데이터프레임입니다. 열과 행을 지닌 테이블의 한 종류입니다. 아래처럼 벡터에서 데이터프레임을 만들어 봅니다.\n\n이름 &lt;- c(\"김\", \"이\", \"권\", \"박\", \"류\", \"홍\", \"차\", \"길\", \"천\" )\n나이 &lt;- c(28, 48, 47, 71, 22, 80, 48, 30, 31)\n구매 &lt;- c(20, 59, 2, 12, 22, 160, 34, 34, 29)\n서점 &lt;- data.frame(이름, 나이, 구매)\n서점\n\n  이름 나이 구매\n1   김   28   20\n2   이   48   59\n3   권   47    2\n4   박   71   12\n5   류   22   22\n6   홍   80  160\n7   차   48   34\n8   길   30   34\n9   천   31   29\n\n\n데이터프레임은 각 열(세로 줄) column 이 변수를 나타내고 각 행(가로 줄) row 이 사례를 나타내는 테이블입니다. 이런 테이블에서 변수는 열과 동일하게 여겨집니다.\n테이블의 종류는 대개 네 가지가 있습니다.\n\n행렬 matrix : 모든 열이 동일한 종류의 객체를 가집니다. 즉 모두 숫자형이거나 모두 문자형이거나. 메모리 용량도 작고 계산도 빠릅니다.\n데이터.프레임 data.frame : 가장 보편적 형태. 데이터프레임의 다른 열은 다른 종류를 가질 수 있습니다. 즉 숫자형의 열, 문자형의 열 등.\n데이터.테이블 data.table : 개선한 형태의 데이터프레임\n티블 tbl_df (tibble) : 또 다른 개선한 형태의 데이터프레임\n\n우선 대부분 경우에 이 네 가지는 매우 유사해서 이들 중 어느 것을 사용하던 이용자는 별로 구분할 필요가 없습니다. 예를 볼까요? R 기본에 있는 데이터셋 두 개입니다.\n매트릭스 형태입니다.\n\n?WorldPhones\nclass(WorldPhones)\nView(WorldPhones)\n\n데이터 프레임입니다.\n\n?airquality\nclass(airquality)\nView(airquality)\n\n티블입니다. ggplot2 패키지에서 데이터셋을 불러와서 살펴봅니다.\n\nlibrary(ggplot2)\n?msleep\nclass(msleep)\nView(msleep)\n\n데이터셋은 다른 종류로 변환이 가능합니다.\n\nWorldPhonesDF &lt;- as.data.frame(WorldPhones)\nclass(WorldPhonesDF)\n\nairqualityMatrix &lt;- as.matrix(airquality)\nclass(airqualityMatrix)\n\n[1] \"data.frame\"\n[1] \"matrix\" \"array\" \n\n\n\n\n\n\n\n\n데이터 변환하면 속성만 바뀌고 구조는 그대로\n\n\n\n변환할 때 객체의 속성만 변환하고 실제 테이블 형태는 변환되지 않아요. WorldPhones 매트릭스가 WorldPhonesDF 데이터프레임으로 속성은 변환되었지만 자료 구성 형태는 그대로 있으므로 통계프로그램에 사용하지 못해요. 일반적인 데이터셋 형태로 자료 구성 구조를 바꾸어야 합니다.\n\n\n아래는 WorldPhone 데이터를 이용해서 비교한 것입니다. 왼쪽이 원래 매트릭스 구조이고 이걸 as.data.frame 함수을 사용해서 변환해도 속성만 매트릭스에서 데이터프레임으로 바뀌고 구조는 아래 왼쪽 테이블과 동일하게 유지합니다.\n이걸 통계에 사용하는 데이터 구조로 바꾸려면 오른쪽처럼 다시 정리해야 합니다. 네 번 관찰이므로 사례가 넷입니다. 북아메리가에서 1951년에 한 번 관찰, 1956년에 또 관찰. 유럽에서 1951년에 한 번 관찰, 1956년에 또 관찰. 그래서 관찰값(사례)이 네 개가 됩니다.\n\n\nTable 5.1: 매트릭스 구조와 통계분석에 사용하는 일반적 테이블 구조의 비교\n\n\n\n\n(a) 원래 매트릭스 구조\n\n\n\n\nN.Amer\nEurope\n\n\n\n\n1951\n|\n45939\n21574\n\n\n1956\n|\n60423\n29990\n\n\n\n\n\n\n(b) 통계에 사용하는 구조\n\n\n번호\n전화대수\n지역\n연도\n\n\n\n\n1\n45939\nN.Amer\n1951\n\n\n2\n60423\nN.Amer\n1956\n\n\n3\n21574\nEurope\n1951\n\n\n4\n29990\nEurope\n1956"
  },
  {
    "objectID": "data-transform.html#데이터프레임-안의-벡터",
    "href": "data-transform.html#데이터프레임-안의-벡터",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.2 데이터프레임 안의 벡터",
    "text": "5.2 데이터프레임 안의 벡터\n여기서는 뉴욕의 대기 질을 조사한 airquality 데이터셋을 이용합니다.\n\n5.2.1 벡터와 요소에 접근하기\n3 장의 숫자형 자료 에서 mean 함수를 사용해서 벡터의 평균을 계산하는 법을 배웠습니다. 이번에는 데이터프레임 속의 벡터의 평균을 계산하는 걸 배워봅시다. 데이터프레임 속의 벡터는 이렇게 표현합니다: 데이터프레임_이름$벡터_이름\n\nmean(airquality$Temp)\n\n[1] 77.88235\n\n\n벡터 속의 요소 하나를 끄집어내려면 요소의 번호를 특정합니다.\n\nairquality$Temp[5]\n\n[1] 56\n\n\n데이터셋에서 벡터를 특정하지 않고 행과 열 번호만으로 요소를 끄집어낼 수 있어요. 우선 airquality 데이터셋의 벡터(변수)가 어떤 순서인지 알아봅니다.\n\nnames(airquality)\n\n[1] \"Ozone\"   \"Solar.R\" \"Wind\"    \"Temp\"    \"Month\"   \"Day\"    \n\n\n결과에서 Temp가 넷째 열이라는 것을 알았습니다. 우리가 원하는 건 Temp의 5번째 요소입니다.\n\nairquality[5, 4]\n\n[1] 56\n\n\n아래처럼 요소를 끄집어내는 방법은 다양합니다.\n\nairquality[5, 4] 5번째 행, 4번째 열 요소\nairquality[5,] 5번째 행 전부\nairquality[,4] 4번째 열 전부\nairquality[[4]] 4번째 열 전부\nairquality[, c(2, 4, 6)] 둘째, 넷째, 여섯째 열 전부\nairquality[, -2] 둘째 열을 뺀 나머지 열 전부\nairquality[, c(\"Temp\", \"Wind\")] Temp와 Wind 열 전부\n\n\n\n5.2.2 “$” 기호 사용\n\n나이 &lt;- c(28, 48, 47, 71, 22, 80, 48, 30, 31)\n구매 &lt;- c(20, 59, 2, 12, 22, 160, 34, 34, 29)\n서점 &lt;- data.frame(나이, 구매)\n\n서점$나이[2] &lt;- 18\n서점$나이\n\n[1] 28 18 47 71 22 80 48 30 31\n\n\n위에서 나이의 둘째 요소가 48 \\(\\rightarrow\\) 18 로 바뀌었어요.\n\n서점$나이 &lt;- 서점$나이 * 12\n서점$나이\n\n[1] 336 216 564 852 264 960 576 360 372\n\n\n나이가 몇 년에서 몇 개월로 단위가 바뀌었어요.\n데이터프레임에 벡터(변수)를 추가해볼게요.\n\n서점$방문_기간 &lt;- c(5, 2, 20, 22, 12, 31, 9, 10, 11)\n서점\n\n  나이 구매 방문_기간\n1  336   20         5\n2  216   59         2\n3  564    2        20\n4  852   12        22\n5  264   22        12\n6  960  160        31\n7  576   34         9\n8  360   34        10\n9  372   29        11\n\n\n\n\n5.2.3 조건 사용하기\n최대값을 알고 싶을 때\n\nmax(airquality$Temp)\n\n[1] 97\n\n\n최대값이 어디 있는지 알고 싶을 때\n\nwhich.max(airquality$Temp)\n\n[1] 120\n\n\nTemp의 요소가 90 이상인지 알고싶을 때. 각 요소가 90이상이면 TRUE, 아니면 FALSE 값을 되줍니다.\n\nairquality$Temp &gt; 90\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE FALSE\n [73] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE\n[121]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n\n\n아래는 데이터셋에서 Temp가 90 이상인 사례만 뽑아서 볼 때\n\nairquality[airquality$Temp &gt; 90, ]\n\n    Ozone Solar.R Wind Temp Month Day\n42     NA     259 10.9   93     6  11\n43     NA     250  9.2   92     6  12\n69     97     267  6.3   92     7   8\n70     97     272  5.7   92     7   9\n75     NA     291 14.9   91     7  14\n102    NA     222  8.6   92     8  10\n120    76     203  9.7   97     8  28\n121   118     225  2.3   94     8  29\n122    84     237  6.3   96     8  30\n123    85     188  6.3   94     8  31\n124    96     167  6.9   91     9   1\n125    78     197  5.1   92     9   2\n126    73     183  2.8   93     9   3\n127    91     189  4.6   93     9   4\n\n\nTemp 가 90도 이상인 사례/행 번호들을 되줍니다.\n\nwhich(airquality$Temp &gt; 90)\n\n [1]  42  43  69  70  75 102 120 121 122 123 124 125 126 127\n\n\n아래는 Temp의 모든 요소가 90이상이면 TRUE, 아니면 FALSE.\n\nall(airquality$Temp &gt; 90)\n\n[1] FALSE\n\n\n하나라도 90 이상이면 TRUE, 아니면 FALSE.\n\nany(airquality$Temp &gt; 90)\n\n[1] TRUE\n\n\n아래는 Temp 요소 중에서 90 이상인 것의 비율. 왜냐면 TRUE는 1, FALSE는 0으로 하여 평균을 계산하니 그게 비율이 됩니다.\n\nmean(airquality$Temp &gt; 90)\n\n[1] 0.09150327"
  },
  {
    "objectID": "data-transform.html#sec-tra-list",
    "href": "data-transform.html#sec-tra-list",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.3 리스트",
    "text": "5.3 리스트\n리스트 list 는 벡터나 데이터프레임처럼 데이터 구조 형태의 하나입니다. 벡터나 데이터프레임이 일정한 틀을 갖는데 비해서 리스트는 좀 형태가 난잡합니다. 아무거나 넣는 형태라고 할까요? 아래의 리스트 예를 봅시다.\n\nli &lt;- list(보호자=\"영희\", 아이_수=3, 아이_나이=c(4, 7, 9), 아이_이름=c(\"수동\", \"길동\", \"신혜\") )\nli\n\n$보호자\n[1] \"영희\"\n\n$아이_수\n[1] 3\n\n$아이_나이\n[1] 4 7 9\n\n$아이_이름\n[1] \"수동\" \"길동\" \"신혜\"\n\n\n리스트 변수인 li는 그 안에 네 개의 데이터를 품고 있는데 심지어 이름도 붙어 있습니다. 네 개의 데이터 형태는 문자형, 숫자형, 벡터, 벡터 등입니다. 이런 리스트 형태는 나중에 분산분석이나 회귀분석 등의 R 통계함수 결과를 변수로 되줄 때 그 변수의 형태가 주로 리스트입니다.\n리스트 등 변수가 생기면 환경 패널에 나타나므로 그것을 보고 요소를 찾을 수 있습니다. 예를 들어, 위의 li$아이_수의 값을 부르려면 li[[2]] 또는 li[[\"아이_수\"]]로 표시합니다. 위의 li$아이_나이의 둘째 요소 값을 구하려면 li[[3]][2]로 표기합니다.\n\nli[2]             # 괄호가 하나면 이름과 값을 되준다\nli[[2]]           # 괄호가 둘이면 값을 되준다\nli[[\"아이_수\"]]   # 번호 대신 요소 이름을 적어도 된다\nli[[3]][2]        # 요소가 벡터일 때 그 안의 하위요소 값을 추출한다 \n\n\n\n$아이_수\n[1] 3\n\n\n[1] 3\n\n\n[1] 3\n\n\n[1] 7\n\n\n\n\n참고로 여러 데이터 형태를 간단히 보면 (청크 옵션 layout-ncol: 4 )\n\nve &lt;- c(1, 2, 3, 4)  # 벡터\nve\nma &lt;- matrix(c(5, 6, 7, 8), nrow=2)  # 매트릭스\nma\nli &lt;- list(보호자=\"영희\", 아이_수=3, 아이_나이=c(4, 7, 9), 아이_이름=c(\"수동\", \"길동\", \"신혜\") )  # 리스트\nli\n키 = c(174, 182, 167, 164, 161)\n무게 = c(72, 74, 65, 62, 59)\nda &lt;- data.frame(키, 무게)  # 데이터 프레임\nda\n\n\n\n[1] 1 2 3 4\n\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n\n\n$보호자\n[1] \"영희\"\n\n$아이_수\n[1] 3\n\n$아이_나이\n[1] 4 7 9\n\n$아이_이름\n[1] \"수동\" \"길동\" \"신혜\"\n\n\n   키 무게\n1 174   72\n2 182   74\n3 167   65\n4 164   62\n5 161   59"
  },
  {
    "objectID": "data-transform.html#sec-tra-get-data",
    "href": "data-transform.html#sec-tra-get-data",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.4 데이터 가져오기",
    "text": "5.4 데이터 가져오기\nR에서 간단한 변수를 만들거나 또는 내장된 데이터셋을 가져와 사용할 수 있습니다. 그러나 통계분석의 대부분은 외부에서 데이터를 가져와 분석합니다. 많이 사용되는 형태는 .csv 이거나 .xlsx 입니다. .csv 파일은 쉼표로 값을 구분하는 파일이고 .xlsx 파일은 엑셀 파일입니다.\n\n5.4.1 csv 파일 가져오기\n파일을 R에 가져오려면 그 파일의 경로를 지정하거나 작업 폴더 working firectory 에 존재해야 합니다. 작업폴더와 경로를 보려면 콘솔 패널에 아래 코드를 칩니다.\n\ngetwd()\n\n[1] \"C:/Users/Choon/Naver MYBOX/Quarto/StaAna-QBook\"\n\n\n작업 폴더를 지정할 때 setwd 를 사용하거나 또는 메뉴의 Session &gt; Set Working Directory &gt; Choose Directory를 사용합니다. 또는 파일 패널의 파일 탭에서 맨 오른쪽의 …을 클릭해서 원하는 폴더로 가고, 중간의 톱니바퀴를 클릭해서 Set as Working Directory 를 선택합니다.\n요즘에는 csv 파일도 엑셀을 사용해서 만들고 저장하고 수정할 수 있어서 편합니다. 아래처럼 코드를 이용하여 외부 데이터를 가져와 내부 데이터셋으로 지정합니다.\n\nimported_data &lt;- read.csv(\"../file_name.csv\") \n\n더 편한 방법이 있어요. 파일 패널 창의 (주로 오른쪽 아래 창) 메뉴에서 …를 클릭해서 열려는 파일이 있는 폴더로 갑니다. 그리고 그 파일을 클릭하면 메뉴 창이 뜨는데 Import Dataset를 선택합니다. 이때 파일 이름이 데이터셋 이름이 되는데 수정해도 됩니다.\n인터넷에서 다운받을 수 있습니다. 아래는 WHO 세계보건기구의 결핵 보고서입니다.\n\n# WHO 결핵 데이터 다운받기\ntb_data &lt;- read.csv(\"https://tinyurl.com/whotbdata\")\n\n\n\n5.4.2 엑셀 파일 가져오기\n우리가 흔히 사용하는 엑셀 파일을 가져와 내부 데이터셋으로 만듭니다.\n\n# install.packages(\"openxlsx\")\nlibrary(openxlsx)\nimported_from_Excel &lt;- read.xlsx(\"../file_name.xlsx\")\n\n여기에서도 더 편한 방법이 있어요. 파일 패널 메뉴의 …를 이용해서 가져오려는 파일이 있은 폴더로 이동한 다음에 그 파일을 클릭하면 메뉴 창이 나옵니다. 그때 Import Dataset를 선택하면 됩니다. 이때 필요한 패키지가 없으면 자동적으로 그 패키지를 설치합니다. 이때 아마도 설치되는 건 readxl 패키지고 명령어는 read_excel입니다.\n데이터를 다운받으면 아래처럼 함수를 이용해서 파일을 획인해 보는 습관을 갖는 게 좋습니다.\n\nView(imported_from_Excel)\nstr(imported_from_Excel)"
  },
  {
    "objectID": "data-transform.html#데이터의-저장과-내보내기",
    "href": "data-transform.html#데이터의-저장과-내보내기",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.5 데이터의 저장과 내보내기",
    "text": "5.5 데이터의 저장과 내보내기\nR에서 데이터를 저장하거나 내보낼 때 .csv 파일이나 .xlsx 또는 .RData를 사용합니다.\n\n5.5.1 데이터를 내보내기\n먼저 데이터를 만듭니다.\n\nage &lt;- c(28, 48, 47, 71, 22, 80, 48, 30, 31)\npurchase &lt;- c(20, 59, 2, 12, 22, 160, 34, 34, 29)\nbookstore &lt;- data.frame(age, purchase)  # 두 변수의 요소 숫자가 일치해야 한다\n\n.csv 파일로 외부에 내보냅니다.\n\nwrite.csv(bookstore, \"bookstore.csv\")\n\n.xlsx 파일로 외부에 내보냅니다.\n\nlibrary(openxlsx)\nwrite.xlsx(bookstore, \"bookstore.xlsx\")\n\n\n\n5.5.2 R 데이터의 저장과 불러오기\nRData 형태로 저장하고 불러오는 방법이에요. 위의 bookstore 데이터셋을 저장하는 걸 예로 듭니다.\n(만일 R을 새로 시작했으면 위에서 bookstore를 생성해 주세요.)\n\nsave(bookstore, age, file = \"myData.RData\")\n\n모든 것(모든 객체)을 저장할 때는 save.image 를 사용합니다.\n\nsave.image(file = \"allMyData.RData\")\n\n저장한 객체를 불러올 때는 load 함수를 사용합니다. 외부 파일은 형태가 외부에서 규정한 것(.csv, xlsx 등)이지만 객체는 R에서 규정한 형식이므로 불러오면 바로 사용할 수 있습니다.\n\nload(file = \"myData.RData\")"
  },
  {
    "objectID": "data-transform.html#rstudioquarto-프로젝트-만들기",
    "href": "data-transform.html#rstudioquarto-프로젝트-만들기",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.6 RStudio/Quarto 프로젝트 만들기",
    "text": "5.6 RStudio/Quarto 프로젝트 만들기\n각 데이터 분석마다 새 폴더를 만들어서 코드, 데이터, 분석결과 outputs 등을 저장하는 게 좋습니다. RStudio에서는 새 프로젝트를 생성하면 새 폴더를 만들어 거기에 프로젝트를 연결시킵니다. 그래서 그 프로젝트를 불러오면 자동으로 그 폴더가 작업 폴더가 됩니다. 프로젝트에서 생성하는 프로그램과 자료, 글, 데이터 등이 언제나 연관된 프로젝트 폴더에 저장이 되므로 편리하고 혼동되지 않습니다. 여러 프로젝트를 실행하면 여러 작업폴더를 각각 사용할 수 있습니다.\n새 프로젝트를 만들려면 메뉴에서 File &gt; New Project 를 선택하면 됩니다. 새 프로젝트는 기존의 폴더와 연관할 수 있고 또는 새 폴더를 만들어 연관한 수 있습니다. 프로젝트 파일은 .Rproj 입니다.\n프로젝트를 실행할 때, 데이터를 하위 폴더에 저장하면 좋아요. 이때 상대적 경로를 변수로 지정하면 편하게 사용합니다. 상대적 경로란 작업폴더까지는 적을 필요가 없고 하위 폴더와 파일 이름만 적으면 된다는 의미입니다. 예를 들어.\nfile_path &lt;- \"하위폴더_이름/bookstore.csv\"\n이것은 작업폴더 아래의 하위폴더_이름 폴더에 있는 bookstore.csv 파일을 file_path 란 변수에 저장하는 명령입니다. 앞으로 file_path를 사용하면 그 파일을 불러올 수 있습니다.\n만일 현재 작업폴더의 상위 폴더에 데이터 파일이 존재한다면 아래처럼 코드를 실행해서 상대경로를 file_path 변수에 저장합니다. 현재 폴더의 상위 폴더는 “..”라고 표현합니다.\nfile_path &lt;- \"../bookstore.csv\""
  },
  {
    "objectID": "data-transform.html#sec-tra-tte",
    "href": "data-transform.html#sec-tra-tte",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.7 t 검정 실행하기",
    "text": "5.7 t 검정 실행하기\nR은 통계적 가설 검정을 위한 함수를 많이 보유합니다. 앞으로 자세한 것을 배우지만 여기서는 간단한 t 검정을 실시합니다. t 검정은 Student t-test 라고 불립니다. t 검정은 두 표본 집단의 평균 차이가 단순한 우연인지 아니면 정말로 의미있는 차이인지 확률적으로 검정하는 통계기법입니다.\n육식동물(canivores)과 초식동물(herbivores)의 잠 시간 평균을 비교한다고 합시다. ggplot2 패키지의 msleep 데이터셋을 사용하고 두 벡터 변수를 투입합니다. vore 변수는 carni(육식)과 herbi(초식)의 두 종류 동물 집단을 대표하는 두 개 변수값을 가지고 sleep_total은 잠 시간을 측정한 숫자값을 변수값으로 가집니다.\n\nlibrary(ggplot2)\n육식동물 &lt;- msleep[msleep$vore == \"carni\",]\n초식동물 &lt;- msleep[msleep$vore == \"herbi\",]\nt.test(육식동물$sleep_total, 초식동물$sleep_total)\n\n\n    Welch Two Sample t-test\n\ndata:  육식동물$sleep_total and 초식동물$sleep_total\nt = 0.63232, df = 39.31, p-value = 0.5308\nalternative hypothesis: true difference in means is not equal to 0\n95 percent confidence interval:\n -1.911365  3.650509\nsample estimates:\nmean of x mean of y \n10.378947  9.509375 \n\n\n위의 것은 육식동물과 초식동물의 평균 잠 시간이 차이가 있는가 하는 가설을 검정하는 것이에요. 조건을 더 자세하게 줄 수 있어요. 아래는 육식동물이 더 잠을 많이 잔다는 가설을 95%의 확률로 검정하는 것이에요.\n\nt.test(육식동물$sleep_total, 초식동물$sleep_total,\n       conf.level = 0.95,\n       alternative = \"greater\",\n       var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  육식동물$sleep_total and 초식동물$sleep_total\nt = 0.62514, df = 49, p-value = 0.2674\nalternative hypothesis: true difference in means is greater than 0\n95 percent confidence interval:\n -1.462515       Inf\nsample estimates:\nmean of x mean of y \n10.378947  9.509375 \n\n\nt 검정은 뒤에 더 자세하게 공부할 겁니다."
  },
  {
    "objectID": "data-transform.html#sec-tra-lm",
    "href": "data-transform.html#sec-tra-lm",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.8 선형 회귀분석 모델",
    "text": "5.8 선형 회귀분석 모델\nmtcars 데이터는 R이 기본으로 제공합니다. 1970년대 차에 관한 것인데, 연료소비와 실린더 수 등 여러 정보를 포함합니다. 데이터셋을 살펴봅니다.\n\n?mtcars\nView(mtcars)\n\n여기서는 총마력(hp)과 연료비(mpg)의 관계를 살펴봅니다.\n\nlibrary(ggplot2)\nggplot(mtcars, aes(hp, mpg)) +\n      geom_point()\n\n\n\n\n그래프에 나타난 점들이 완벽한 직선은 아니지만, 그래도 선형회귀모형은 그려볼 수 있어 보입니다. 총마력(hp)이 독립/설명 변수, 연료비(mpg)가 종속/결과 변수입니다.\n\nm &lt;- lm(mpg ~ hp, data = mtcars)\nsummary(m)\n\n\nCall:\nlm(formula = mpg ~ hp, data = mtcars)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-5.7121 -2.1122 -0.8854  1.5819  8.2360 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 30.09886    1.63392  18.421  &lt; 2e-16 ***\nhp          -0.06823    0.01012  -6.742 1.79e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.863 on 30 degrees of freedom\nMultiple R-squared:  0.6024,    Adjusted R-squared:  0.5892 \nF-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n\n\\(mpg = \\alpha + \\beta * hp\\) : 이 선형 모델은 총마력(hp)이 연료비(mpg)를 예측하는 모형입니다. 즉 hp가 1 만큼 높아질수록 mpg가 \\(\\beta\\)만큼 높아지고, hp가 낮아질수록 mpg도 낮아진다는 걸 나타냅니다. lm 함수의 결과가 summary 함수를 통해서 나타납니다. \\(\\beta\\) 숫자가 나와 있는데 그 외에 여러 정보도 알려줍니다.\ngeom_abline 함수를 이용해서 산포도 위에 회귀선을 그릴 수 있고, coef 함수를 사용해서 회귀계수를 구할 수 있습니다.\n\n# 위의 선형회귀모형을 확인한다\ncoef(m)\n\n(Intercept)          hp \n30.09886054 -0.06822828 \n\n# 회귀선을 산포도에 추가한다\nggplot(mtcars, aes(hp, mpg)) +\n      geom_point() + \n      geom_abline(aes(intercept = coef(m)[1], slope = coef(m)[2]),\n                colour = \"red\")\n\n\n\n\n잔차 그래프를 그릴 수도 있습니다.\n\nplot(m)\n\n\n\n\n\n\n\n\n\n\n\n\n\n독립변수를 추가해서 다중회귀분석을 할 수도 있습니다. 여기서는 자동차 무게(wt)를 추가합니다. 독립변수는 여러 개를 추가할 수 있어요.\n\nm2 &lt;- lm(mpg ~ hp + wt, data = mtcars)\nsummary(m2)\n\n\nCall:\nlm(formula = mpg ~ hp + wt, data = mtcars)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-3.941 -1.600 -0.182  1.050  5.854 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 37.22727    1.59879  23.285  &lt; 2e-16 ***\nhp          -0.03177    0.00903  -3.519  0.00145 ** \nwt          -3.87783    0.63273  -6.129 1.12e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.593 on 29 degrees of freedom\nMultiple R-squared:  0.8268,    Adjusted R-squared:  0.8148 \nF-statistic: 69.21 on 2 and 29 DF,  p-value: 9.109e-12"
  },
  {
    "objectID": "data-transform.html#집단-별로-요약하기",
    "href": "data-transform.html#집단-별로-요약하기",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.9 집단 별로 요약하기",
    "text": "5.9 집단 별로 요약하기\naggregate 함수는 집단 별로 요약합니다. 예를 들어, 한국의 기온 통계를 계산할 때, 모든 측정 기간 전체의 기온 평균을 계산하는 것도 좋지만, 각 월 별로 평균을 계산한다면 일 년 동안의 기온을 예측하는 데 더 도움이될 것입니다. 이렇게 한 해 전체의 기온을 측정한 데이터에서 월 별로 평균을 각각 계산할 때 aggregate를 사용합니다. grouped summary 라고 봐도 됩니다.\nR 기본에 포함한 airquality 데이터셋을 사용합니다.\n\naggregate(Temp ~ Month, data = airquality, FUN = mean)\n\n  Month     Temp\n1     5 65.54839\n2     6 79.10000\n3     7 83.90323\n4     8 83.96774\n5     9 76.90000\n\n\n여기서 평균을 계산할 때 디폴트로 결측값은 제외합니다. 두 변수의 표준편처를 동시에 계산할 수도 있어요.\n\naggregate(cbind(Temp, Wind) ~ Month, data = airquality, FUN = sd)\n\n  Month     Temp     Wind\n1     5 6.854870 3.531450\n2     6 6.598589 3.769234\n3     7 4.315513 3.035981\n4     8 6.585256 3.225930\n5     9 8.355671 3.461254\n\n\nby 함수도 비슷한 기능이지만 평균을 계산할 때는 아웃풋 포맷이 aggregate가 더 좋아요. 상관계수처럼 두 변수가 동시에 연결되는 통계분석에는 by 함수가 더 나아요. 아래는 R 기본에 포함한 airquality 데이터셋을 이용한 예입니다.\n\nnames(airquality)  # 3과 4열에 있는 Temp와 Wind 변수를 확인한다.\n\n[1] \"Ozone\"   \"Solar.R\" \"Wind\"    \"Temp\"    \"Month\"   \"Day\"    \n\nby(airquality[, 3:4], airquality$Month, cor)\n\nairquality$Month: 5\n          Wind      Temp\nWind  1.000000 -0.373276\nTemp -0.373276  1.000000\n------------------------------------------------------------ \nairquality$Month: 6\n           Wind       Temp\nWind  1.0000000 -0.1210353\nTemp -0.1210353  1.0000000\n------------------------------------------------------------ \nairquality$Month: 7\n           Wind       Temp\nWind  1.0000000 -0.3052355\nTemp -0.3052355  1.0000000\n------------------------------------------------------------ \nairquality$Month: 8\n           Wind       Temp\nWind  1.0000000 -0.5076146\nTemp -0.5076146  1.0000000\n------------------------------------------------------------ \nairquality$Month: 9\n           Wind       Temp\nWind  1.0000000 -0.5704701\nTemp -0.5704701  1.0000000"
  },
  {
    "objectID": "data-transform.html#파이프를-이용하기",
    "href": "data-transform.html#파이프를-이용하기",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.10 %>% 파이프를 이용하기",
    "text": "5.10 %&gt;% 파이프를 이용하기\n방문시간(visit_lenghth)으로 구매(purchase)를 나누어서 시간당 구매(rev_per_minute)를 구할 때\nbookstore$rev_per_minte &lt;- bookstore$purchase / bookstore$visit_length\nbookstore$ 를 자꾸 적은 건 불편해요. 파이프는 이걸 해소합니다.\n\n5.10.1 파이프\nmagrittr 패키지는 pipes 라는 도구를 R에 추가합니다. pipes는 코드를 읽고 편집하기 편하게 합니다.\n\ninstall.packages(\"magrittr\")\n\n통상적으로 우리가 하는 방식:\n\n# 더운 날을 추출한다:\nairquality2 &lt;- airquality[airquality$Temp &gt; 80, ]\n# 바람 속도을 초속으로 변환한다\nairquality2$Wind &lt;- airquality2$Wind * 0.44704\n# 각 월의 바람 속도의 평균을 계산한다:\nhot_wind_means &lt;- aggregate(Wind ~ Month, data = airquality2,\n                            FUN = mean)\n\n이건 코드 자체는 문제가 없지만, airquality를 아주 여러 번 적는다는 게 문제예요. 아래처럼 aggregate 를 사용하면 좀 줄일 수 있지만, 그러면 코드를 이해하기가 좀 어려워지지요.\n\n# 더 간단한 유형\nhot_wind_means &lt;-  aggregate(Wind*0.44704 ~ Month,\n                           data = airquality[airquality$Temp &gt; 80, ],\n                           FUN = mean)\n\nmagrittr는 pipe라고 부르는 %&gt;%를 도입해서 잇단 함수를 편하게 사용합니다.\n\nnew_variable &lt;- function_2(function_1(your_data))\n\n위의 것을 아래처럼 적습니다.\n\nyour_data %&gt;% function_1 %&gt;% function_2 -&gt; new_variable\n\n자, 예를 들어봅시다. 아래 것은 통상적 방법입니다. subset 함수로 화씨 80도 넘는 더운 날의 데이터만 뽑아내고 magrittr 의 inset 함수로 바람 속도를 마일에서 미터로 고쳤습니다. aggregate 로 평균을 변수로 만들었구요.\n\nlibrary(magrittr)\n# 더운 날을 추출한다:\nairquality2 &lt;- subset(airquality, Temp &gt; 80)\n# 바람 속도을 초속으로 변환한다\nairquality2 &lt;- inset(airquality2, \"Wind\",\n                     value = airquality2$Wind * 0.44704)\n# 각 월의 바람 속도의 평균을 계산한다:\nhot_wind_means &lt;- aggregate(Wind ~ Month, data = airquality2,\n                            FUN = mean)\n\n아래 것은 pipe를 이용한 겁니다. 왼쪽 것 (데이터) 안에서 오른쪽 것(데이터)이 행해지니까 airquality 나 airquality2를 지정할 필요가 없어졌습니다. 즉 왼쪽이 오른쪽의 실행 범위를 지정/제한해주는 거지요.\n\nairquality %&gt;%\n      subset(Temp &gt; 80) %&gt;% \n      inset(\"Wind\", value = .$Wind * 0.44704) %&gt;%\n      aggregate(Wind ~ Month, data = ., FUN = mean) -&gt;\n      hot_wind_means"
  },
  {
    "objectID": "data-transform.html#두-개의-r-base-and-tidyverse",
    "href": "data-transform.html#두-개의-r-base-and-tidyverse",
    "title": "5  데이터의 변환, 요약, 분석",
    "section": "5.11 두 개의 R: Base and tidyverse",
    "text": "5.11 두 개의 R: Base and tidyverse\nbase R은 원래 R을 말하고 tidyverse R은 여러 종류의 데이터를 다루기 쉽게 추가적인 패키지를 첨가한 것입니다. 둘 다 상호 호환적이니 사용에 문제는 없습니다. tidyverse는 ggplot2와 magrittr 패키지를 모두 포함합니다.\n최근에 사용자들은 tidyverse R을 modern R이라 부르며 사용하기 편하다고 더 선호하는 경향을 보입니다. 사실 tidyverse는 통상적인 조건이나 파라미터를 디폴트로 사용하는 함수들이 많아서 편하기는 합니다. 그러나 디폴트를 사용하다보면 통계 결과를 분석할 때 그 의미를 놓칠 수 있습니다. 그래서 tidyverse의 편리함을 이용하면서도 base의 원칙도 익히는 게 바람직합니다.\n더구나 수많은 패키지들이 지금도 만들어지므로 base를 익히는 게 미래의 R에 적응하는데 도움이 됩니다. 시간을 좀 투자해서 base R의 조건(옵션)을 공부하는 것도 좋습니다."
  },
  {
    "objectID": "descriptive-statistics.html#빈도분포",
    "href": "descriptive-statistics.html#빈도분포",
    "title": "6  기술통계",
    "section": "6.1 빈도분포",
    "text": "6.1 빈도분포\n빈도 frequency 는 측정 단위의 숫자, 관찰의 숫자, 혹은 사례의 숫자를 말합니다. 만일 사람 20명의 키를 측정했다면 관찰 빈도는 20입니다. 키가 170cm인 사람이 15명이면 키 170cm의 값에 해당하는 빈도는 15가 됩니다. 빈도를 나타내는 데 도수라는 용어도 많이 사용합니다. 빈도와 도수, 빈도분포와 도수분포는 같은 뜻입니다. 상대빈도 relative frequency 는 해당 빈도를 전체 빈도로 나눈 것입니다. 만일 전체 10명에서 여자가 4명, 남자가 6명이라면 여자의 상대빈도는 0.4 또는 40%, 남자는 0.6 또는 60%입니다.\n빈도분포 frequency distribution 는 측정한 점수를 크기 순서대로 체계화해서 측정 척도에 맞도록 범주화한 것입다. 예를 들어, 측정한 키가 각각 159, 161, 162,168 171, 173, 175, 177, 182, 183이라면 아래 표와 같이 보기 좋게 범주화해서 정리합니다. 이러한 표를 빈도분포표라고 합니다.\n\n\nTable 6.1: 빈도분포표의 예\n\n\n키 x\n빈도 \\(f\\)\n상대빈도\n\n\n\n\n150-160cm\n1\n0.1\n\n\n160-170cm\n3\n0.3\n\n\n170-180cm\n4\n0.4\n\n\n180-190cm\n2\n0.2\n\n\n합\n10\n1\n\n\n\n\n빈도분포에서 총합은 x값과 그 값의 빈도를 곱해서 모두 더하면 됩니다.\n\\[총합 = \\sum xf\\]\n참고로 위의 수식을 표현하는 콸토 방법은,\n$$총합 = \\sum xf$$\n위의 빈도분포표처럼 수치를 범주화해서 정리했다면 중간 값을 취해서 빈도를 곱한 다음에 모두 더합니다.\n\nExample 6.1  \n\n위 빈도분포표(Table 6.1)의 키 총합을 구하세요.\n\n\n답\n\n총합 &lt;- sum(155*1, 165*3, 175*4, 185*2)\ncat(\"총합은 \", 총합, \"입니다.\")\n\n총합은  1720 입니다.\n\n\n중앙을 중심으로 서로 닯은 꼴인 분포를 대칭 분포라고 하고, 중앙을 중심으로 서로 다른 것을 비대칭 분포라고 합니다. 분포의 양끝은 대개 좁고 길게 늘어지게 마련인데 그것을 꼬리 tail 라고 부릅니다. 꼬리가 오른쪽이 더 길면 정적 비대칭이고, 왼쪽이 더 길게 늘어지면 부적 비대칭입니다.\n빈도, 도수, 상대빈도, 빈도분포표, 대칭분포, 비대칭분포, 꼬리"
  },
  {
    "objectID": "descriptive-statistics.html#집중화-경향치",
    "href": "descriptive-statistics.html#집중화-경향치",
    "title": "6  기술통계",
    "section": "6.2 집중화 경향치",
    "text": "6.2 집중화 경향치\n기술 통계의 목적 중 하나는 집단을 대표하는 값을 산출하는 것입니다. 평균이 가장 흔하게 이런 목적으로 쓰입니다. 평균처럼 집단의 속성을 나타내는 대표성을 가지는 값을 집중화 경향치 central tendency (or measure of central tendency) 라고 합니다. 평균, 중앙값, 최빈값 등이 자주 사용되는 집중화 경향치입니다.\nR에는 각 기본패키지를 비롯하여 여러 패키지가 데이터셋을 내장한 경우가 많습니다. 기본패키지가 내장한 iris 데이터셋의 Pedal.Length라는 변수를 이용하여 집중화 경향치를 산출해 봅니다.\n\nmean(iris$Petal.Length)      # 평균\nmedian(iris$Petal.Length)    # 중앙값\nmax(iris$Petal.Length)       # 최대값\nmin(iris$Petal.Length)       # 최소값\nsd(iris$Petal.Length)        # 표준편차\nvar(iris$Petal.Length)       # 분산\nquantile(iris$Petal.Length)  # 사분위값\n\n[1] 3.758\n[1] 4.35\n[1] 6.9\n[1] 1\n[1] 1.765298\n[1] 3.116278\n  0%  25%  50%  75% 100% \n1.00 1.60 4.35 5.10 6.90 \n\n\n\n6.2.1 평균\n평균 average 은 산술평균 arithmatic mean 이라고 부르기도 합니다. 모든 측정값의 합을 측정값의 갯수로 나눈 값입니다. 집중화 경향치로 가장 많이 사용합니다. 계산법은 아래와 같습니다. 위는 모집단의 평균이고 아래는 표본의 평균이지요. 방법은 둘이 동일합니다.\n\\[ \\mu = \\frac{1}{N}\\sum_{i=1}^{N}x_i = (\\frac{1}{N})(x_1 + x_2 + x_3 + ... +x_N)\\]\n\\[ \\bar x = \\frac{1}{n}\\sum_{i=1}^{n}x_i = (\\frac{1}{n})(x_1 + x_2 + x_3 + ... +x_n)\\]\n참고: 총합인 \\(\\sum x\\) 를 \\(\\frac{1}{n}\\) 로 곱한 것은 총합 \\(\\sum x\\) 를 \\(n\\) 로 나눈 것과 마찬가지입니다.\n\\[\\frac{1}{n}\\sum x = \\frac{\\sum x}{n}\\]\n가중평균 weighted average 은 이미 평균을 산출한 여러 집단을 합친 전체 집단의 평균을 계산할 때 사용합니다. 예를 들어, 한국대학의 남자 키 평균과 여자 키 평균이 있을 때 그 둘을 더해서 2로 나눈다고 전체 평균이 되지 않습니다. 남자 수와 여자 수가 다르기 때문에 그것을 고려해야 합니다.\n\\[\\bar x_w = \\frac{\\sum_{i=1}^{k}w_i\\bar x_i}{\\sum_{i=1}^{k}w_i}\\]\n여기에서 \\(k\\): 평균의 수, \\(\\bar x_i\\): \\(i\\) 번째 평균, \\(w_i\\): \\(i\\) 번째 평균의 가중치.\n\nExample 6.2  \n\n남자 100명 여자 150명으로 구성한 어떤 집단에서, 남자 키 평균이 175cm고 여자 평균이 165cm라면 전체 평균은 얼마가 되어야 할까요?\n\n\n답: 남자 평균 가중치는 100, 여자 평균 가중치는 150입니다. 따라서 전체 평균은 169cm.\n\\[가중평균 \\; \\bar{x}_w = \\frac{(100*175) + (150*165)}{100 + 150}=169\\]\n참고로 위의 Quarto 수식을 표현하는 방법은,\n$$가중평균 \\; \\bar{x}_w = \\frac{(100*175) + (150*165)}{100 + 150}=169$$\n\n참고: \\bar{x}, \\bar{x}_w, \\frac{}{}\n\n\n6.2.2 중앙값\n중앙값 median 은 분포를 정확하게 반으로 나누는 측정값을 말합니다. 즉 측정값들을 크기 순서로 늘어놓았을 때 가운데 오는 값이 중앙값입니다. 측정값의 수가 홀수라면 가운데 값이 중앙값입니다. 즉 측정값이 1, 2, 2, 4, 5, 이렇게 다섯이라면 세번째의 2가 중앙값입니다. 짝수라면 가운데 값이 두 개가 될 수도 있어요. 즉 측정값이 1, 2, 2, 4, 5, 6, 이렇게 여섯이라면 세번째의 2와 네번째의 4가 달라서 곤란합니다. 이럴 때 두 수의 평균을 중앙값으로 합니다. 여기서는 \\(\\frac{2+4}{2} = 3\\) 이므로 3이 중앙값입니다.\n극단값은 대부분의 값에서 멀리 떨어진 예외적인 값들을 말합니다. 평균이 극단값의 영향을 크게 받는 경우에 평균보다 중앙값이 더 대표성을 갖게 됩니다. 또 비대칭분포가 심할 경우에도 역시 중앙값의 대표성이 평균의 대표성보다 높습니다. 일반적으로 한 국가의 개인소득에서 부유한 극소수가 평균 소득을 높이게 되므로 한 국가의 일반적인 개인소득은 평균보다 중앙값으로 대표하는 게 적절합니다.\n\n\n6.2.3 최빈값\n분포에서 빈도가 가장 높은 값이 최빈값 mode 입니다. 빈도 분포표가 계급구간으로 구성된 경우 빈도가 가장 높은 구간값을 최빈값으로 합니다. 예를 들어, 측정값이 1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 6, 6, 이렇다면 6이 5개로 가장 많으니 최빈값은 6입니다. 최빈값은 그 특성상 여러 개가 있을 수 있습니다. 최빈값은 명목척도를 대표할 때 자주 사용합니다. 예를 들어, “옷 색깔에서 파란색을 선택한 사람이 가장 많았다”는 표현은 명목척도에서 최빈값의 대표성을 이용한 것입니다.\n사람의 수명을 말할 때도 평균 수명보다 유용합니다. 신생아의 상대적 사망율이 높아서 평균이 왜곡되기 때문입니다. 사망 나이의 최빈값을 택하는 것이 성인의 사망나이를 추정할 때 효율적입니다. 또 이산변수일 때도 소수점 아래를 말하기 어려울 때 유용합니다. 주택을 말할 때 3.6 채보다는 4채가 더 익숙합니다.\n\n\n6.2.4 집중화경향치의 비교\n빈도분포가 대칭적이면 집중화경향치는 평균, 중앙값, 최빈값이 상당히 비슷합니다. 이때는 평균이 대표성이 가장 높습니다. 그러나 비대칭분포일 때는 세 집중화경향치가 차이가 있습니다. 극단적인 비대칭분포일 때 중앙값은 극단값의 영향을 잘 받지 않기 때문에 중앙값의 대표성이 더 우수합니다. 최빈값은 명목척도나 대략적인 경향을 알아보려 할 때 좋습니다.\n위키피디아의 집중경향치 비교도 클릭해서 참고로 보면 좋습니다."
  },
  {
    "objectID": "descriptive-statistics.html#분포와-분산도",
    "href": "descriptive-statistics.html#분포와-분산도",
    "title": "6  기술통계",
    "section": "6.3 분포와 분산도",
    "text": "6.3 분포와 분산도\n집중경향치는 전체 측정값을 대표하는 값으로 대체로 측정값의 중심을 나타냅니다. 측정값이 어떤 형태로 분포되어 있는가 하는 것은 또 다른 방법이 필요합니다. 측정값이 넓게 또는 좁게 퍼져 있는 정도를 나타내는 게 분산도 dispersion, variability, scatter 다. 분산도를 보여주는 방법은 범위, 표준편차, 분산, 사분위편차 등이 있습니다.\n분산도\n\n6.3.1 범위\n범위 range 는 측정값에서 최대값 maximum 과 최소값 minimum 의 차이를 말합니다. 극단값이 있는 경우에 범위가 크기 증가하므로 적절한 방법이 되지 못합니다. 극단값이 아니라도 최소값과 최대값의 단 두 개 값이 크기를 좌우하므로 바람직하지 않습니다.\n범위, 최대값, 최소값\n\n\n6.3.2 표준편차와 분산\n표준편차 standard deviation 는 분산도를 나타내는 가장 대표적인 방법입니다. 측정값들이 평균에서 멀리 흩어진 정도를 알려줍니다. 표준편차는 분산의 제곱근입니다. 분산 variance 은 측정값과 평균의 차이를 제곱해서 모두 합한 것을 총 빈도로 나눈 것입니다. 측정값과 평균의 편차를 그대로 더하지 않고 제곱해서 더 한 이유는 편차가 \\(+\\) 와 \\(-\\) 가 섞여 있므로 총합이 언제나 0가 되기 때문입니다. 편차의 절대값을 다 더해서 평균을 낸 평균편차 mean deviation 라는 방법도 있으나 통계에서 거의 사용하지 않습니다. 평균과 표준편차는 자료를 가장 흔하게 대표하는 두 방법입니다. 자료의 중심과 흩어진 정도를 각각 알려줍니다.\n\\(\\sigma\\): 모집단 표준편차, \\(N\\): 모집단 측정값의 빈도, \\(\\mu\\): 모집단 측정값의 평균\n\\[ 모집단  \\; 분산 \\;  \\;  \\sigma^{2} = \\frac{1}{N}\\sum_{i=1}^{N} (x_i-\\mu)^{2} = \\frac{\\sum_{i=1}^{N} (x_i-\\mu)^{2}}{N}\\]\n\\[ 모집단  \\; 표준편차 \\; \\; \\sigma =\\sqrt{\\frac{1}{N}\\sum_{i=1}^{N} (x_i-\\mu)^{2}}=\\sqrt{\\frac{\\sum_{i=1}^{N} (x_i-\\mu)^{2}}{N}}\\]\n참고: 위 계산식의 Quarto 표현\n$$ 모집단 분산 \\sigma^{2} = \\frac{1}{N} \\sum_{i=1}^{N} (x_i-\\mu)^{2} = \\frac{\\sum_{i=1}^{N} (x_i-\\mu)^{2}}{N}$$\n\n$$ 모집단 표준편차 \\sigma =\\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (x_i-\\mu)^{2}}=\\sqrt{\\frac{\\sum_{i=1}^{N} (x_i-\\mu)^{2}}{N}}$$\n\n$$, \\sigma, \\sigma^{}, \\frac{}{}, \\sum_{}^{}, \\sum, \\mu, ^{}, \\sqrt{}, \\bar x, x_i\n문장 안에서는 양쪽에 $ 하나씩, 별도의 줄 가운데에 놓으려면 맨앞과 맨뒤에 각각 $$\n$n$, $n-1$\n\\(s\\): 표본 표준편차, \\(n\\): 표본 크기, \\(\\bar x\\): 표본 평균\n\\[ 표본  \\; 분산  \\;  \\; s^{2} =\\frac{1}{n-1}\\sum_{i=1}^{n} (x_i-\\bar x)^{2}=\\sqrt{\\frac{\\sum_{i=1}^{n} (x_i-\\bar x)^{2}}{n-1}}\\]\n\\[ 표본  \\; 표준편차  \\;  \\; s =\\sqrt{\\frac{1}{n-1}\\sum_{i=1}^{n} (x_i-\\bar x)^{2}}=\\sqrt{\\frac{\\sum_{i=1}^{n} (x_i-\\bar x)^{2}}{n-1}}\\]\n표준편차와 분산은 모집단을 위한 공식과 표본을 위한 공식이 다릅니다. 이것은 표본의 표준편차가 모집단의 표준편차를 추론하려는 방법인데, 똑같이 측정값의 빈도로 나누면 추론에서 왜곡이 생기기 때문입니다. 표본 크기가 작을수록 왜곡이 크고 표본 크기가 커질수록 왜곡이 작아지는데 이걸 보정해서 정확하게 추론하는 방법이 \\(n\\) 대신에 \\(n-1\\) 로 나누는 겁니다. 나중에 확률 부분에서 다시 논의합니다.\n표본의 표준편차를 계산할 때 사용한 \\(n-1\\) 을 자유도 degree of freedom 라고 합니다. 표준편차의 계산 과정에서 평균과의 편차를 산출하는 데, 이때 모평균을 사용해야 이론적으로 맞습니다. 왜냐하면 표본의 표준편차를 구하는 이유가 모표준편차를 추정하려는 것이므로 모평균을 넣어야 하는 겁니다. 하지만 우리는 모평균을 모르므로 표본평균을 대신 사용했습니다. 표본평균을 대신 사용하는 순간 자유도가 하나 줄어들어서 \\(n\\)이 아닌 \\(n-1\\) 이 됩니다.\n예를 들어, a, b, c, 세 수의 평균이 5 라고 합시다. a=4, b=5 라면 c는 반드시 6이 되어야 합니다. a=3, b=9 라면 c는 반드시 3이 되어야 합니다. 이처럼 평균이 정해져도 두 수는 자유롭게 값을 정하지만 마지막 하나는 일정한 값을 가져야하므로 자유가 없는 겁니다. 그래서 모평균 대신에 표본평균을 이용하는 순간 자유도가 \\(n-1\\) 이 되었습니다.\n현실적인 예를 들어보죠. 철수, 영희, 복길이의 나이가 각각 20살, 22살, 24살입니다. 나이평균은 (20+22+24)/3 = 22. 분산은 (20-22)2 + (22-22)2+(24-22)2인데 이것은 중간이 0이므로 (20-22)2 + (24-22)2과 같습니다. 즉 사례가 하나 없어진 것과 마찬가지죠. 그래서 표본 평균이 모집단 평균을 대체할 때 편차 제곱의 합에서 사례가 하나 적어진 것 같은 편향이 생깁니다.\n표준편차, 분산, 평균편차, 자유도\n\n\n6.3.3 사분위편차\n측정값을 큰 순서대로 늘어놓았을 때 측정값들이 사등분되는 즉 각각25%, 50%, 75% 되는 위치의 측정값을 사분위수 quartile 라고 합니다. 25% 위치를 제1사분위 \\(Q_1\\), 50% 위치를 제2사분위 \\(Q_2\\), 75% 위치를 제3사분위 \\(Q_3\\) 라고 합니다. 제2사분위를 중위수라고 부르기도 합니다. 제1사분위와 제3사분위의 차이를 2로 나눈 값이 사분위편차 quantile deviation 입니다. 2로 나누지 않은 값을 사분위범위 interquantile range 라고 구분합니다. 사분위편차는 양끝에 존재하는 극단값을 배제하므로 예외적인 사례의 영향을 더 받는 게 장점입니다. 그러나 빈도가 25보다 적다면 다소 불안하므로 적정한 빈도가 되는 게 바람직합니다.\n사분위편차: \\(Q = \\frac{Q_3-Q_1}{2}\\), 사분위범위: \\(IRQ = Q_3-Q_1\\)\n박스플롯은 사분위편차와 밀접한 관련이 있습니다. 박스플롯은 중앙값, 1사분위, 3사분위, 최소값, 최대값, 극단값 등을 나타냅니다. 아래는 ggplot2 패키지의 msleep 데이터셋을 이용해서 그룹의 박스플롯을 보여줍니다.\n\nlibrary(ggplot2)\nlibrary(dplyr)\nmsleep &lt;- na.omit(msleep) # 결측값 사례를 제거\nmsleep$식성 &lt;- recode(msleep$vore, \"carni\" = \"육식\", \"herbi\" = \"초식\", \"insecti\" = \"곤충식\", \"omni\" = \"잡식\")\nggplot(msleep, aes(식성, sleep_total)) +\n      geom_boxplot() +\n      xlab(\"식성\") +\n      ylab(\"전체 잠 시간\")\n\n\n\n\n사분위수, 제1사분위, 제2사분위, 제3사분위, 사분위편차, 사분위범위\n\n\n6.3.4 변동계수와 사분위 분산계수\n변동계수 coefficient of variation 는 표준편차를 평균으로 나눈 것입니다. 상대 표준편차 relative standard deviation 라고도 합니다. 표준편차는 크기가 측정단위에 영향을 받습니다. 그래서 측정 단위가 다른 자료를 비교할 때 변동계수를 사용하지요. 변동계수는 0이 의미를 가지는 비율척도에만 사용해야 합니다. 등간척도에 사용하면 왜곡된 결과가 나올 가능성이 높으므로 사용하지 않습니다.\n\\[ CV = \\frac{\\sigma}{\\mu} \\rightarrow \\frac{s}{\\bar x}\\]\n참고로 위의 표현식은\n$$ CV = \\frac{\\sigma}{\\mu} \\rightarrow \\frac{s}{\\bar x}$$\n그래서 사분위분산계수 quantile coefficient of dispersion 를 더 선호하기도 합니다. 사분위분산계수는 극단값에 영향을 덜 받는 장점도 있습니다.\n\\(QCD = \\frac{Q_3-Q_1}{Q_3+Q_1}\\)\n변동계수, 상대표준편차, 사분위분산계수"
  },
  {
    "objectID": "descriptive-statistics.html#sec-des-z",
    "href": "descriptive-statistics.html#sec-des-z",
    "title": "6  기술통계",
    "section": "6.4 Z값과 분포의 표준화",
    "text": "6.4 Z값과 분포의 표준화\n측정 단위가 다른 자료를 비교하기는 어렵고, 평균과 표준편차가 다를 때 역시 자료를 비교하기가 곤란합니다. 이럴 때 표준화한 측정값을 사용하면 여러 자료를 비교하는 것이 가능해집니다. 그래서 z값은 여러 곳에서 유용하게 사용합니다. 예를 들어, 중간시험과 기말시험의 평균과 표준편차가 다르다면 성적이 공정하지 못할지 모릅니다. 상대적으로 중간고사를 잘 본 학생이 유리하거나 아니면 역으로 기말고사를 잘 본 학생이 유리해지기 때문입니다. 이럴 때 중간시험 점수와 기말시험 점수를 각각 z값으로 표준화해서 둘을 합산한다면 그냥 합산해서 처리하는 것보다 더 공정한 절차가 될 수 있습니다.\n측정값들이 정규분포를 한다고 가정할 때, 말하자면 아주 많은 측정값들이 존재한다고 가정할 때, 우리는 z값을 이용하여 어떤 측정값이 상위 혹은 하위 몇 %에 속하는 위치에 있는지 추정할 수 있습니다. 평균이나 표준편차는 전체 측정값을 대상으로 산출하지만 x값은 하나의 측정값을 대상으로 계산합니다. z값은 측정값에서 평균을 빼고 표준편차로 나누면 됩니다. 따라서 z값은 측정값과 평균의 편차를 표준편차와 상대적 크기로 계산합니다.\nz값은 표준화되었기 때문에 언제나 평균은 0이고 표준편차는 1입니다. 아래는 측정값을 표준화한 Z값으로 변환하는 공식입니다.\n\\[ 모집단에서 \\; \\; Z = \\frac{X - \\mu}{\\sigma} \\]\n\\[ 표본에서 \\; \\; z = \\frac{x - \\bar x}{s} \\]\n\nExample 6.3  \n\n\niris 데이터셋의 Petal.Length 변수에서 5.5의 z값은 얼마인가요?\nPetal.Length가 정규분포를 한다면 5.5는 길이에서 상위 몇 %에 속하는가요? (긴 것이 상위)\nPetal.Length 변수 전체를 z값을 바꾸어서 Petal.Length.z 변수로 저장하세요.\n\n\n\n참고로 Iris Versicolor 그림이 이 페이지에 있어요.\n답:\n\nx_5.5 &lt;- 5.5\nm.x &lt;- mean(iris$Petal.Length)\nsd.x &lt;- sd(iris$Petal.Length)\n# 1) 답\nz_5.5 &lt;- (x_5.5 - m.x) / sd.x\n# 2)답   옵션; lower.tail = FALSE\np_5.5 &lt;- pnorm(x_5.5, m.x, sd.x, lower.tail = FALSE) * 100\np_5.5 &lt;- round(p_5.5, 2)\n# 3)답\nz &lt;- scale(iris$Petal.Length)   # 표준화\n\ncat(\" 1) 5.5의 z값은 \", z_5.5, \"입니다. \\n\",\n    \"2) 정규분포라면, 5.5는 상위 \", p_5.5, \"%입니다. \\n\",\n    \"3) 앞 다섯 개 값만 출력\", z[1:5]\n)\n\n 1) 5.5의 z값은  0.9868021 입니다. \n 2) 정규분포라면, 5.5는 상위  16.19 %입니다. \n 3) 앞 다섯 개 값만 출력 -1.335752 -1.335752 -1.392399 -1.279104 -1.335752"
  },
  {
    "objectID": "descriptive-statistics.html#비대칭도",
    "href": "descriptive-statistics.html#비대칭도",
    "title": "6  기술통계",
    "section": "6.5 비대칭도",
    "text": "6.5 비대칭도\n비대칭도 skewness 는 분포가 한쪽으로 치우친 정도를 나타내는 수치입니다. 피어슨 비대칭계수 Pearson’s coefficient of skewness 가 그 하나입니다. 0일 때 완전 대칭분포고 음이나 양의 값이면 한쪽으로 치우친 비대칭분포입니다. 아래는 계산 공식입니다.\n\\[ 피어슨  \\; 비대칭계수 \\; \\; S_k = \\frac{3(\\bar x-M_d)}{s} : M_d; 중앙값\\]\n비대칭계수는 위 공식을 사용해서 계산할 수 있습니다. 만일 비대칭계수를 자주 계산한다면, R에는 직접 계산하는 함수가 없으므로, 여러분이 함수를 간단히 만들어 사용할 수 있습니다. function 함수를 사용해서 사용자 정의 함수를 만듭니다.\n\nExample 6.4 (사용자 정의 함수를 만들기)  \n\n“비대칭계수_계산”이라는 함수를 만들어 Petal.Length의 비대칭계수를 계산하세요.\n\n\n답:*\n\n# 사용자 정의 함수를 만듭니다. \n비대칭계수_계산 &lt;- function(x) {\n  mean_x &lt;- mean(x)\n  sd_x &lt;- sd(x)\n  median_x &lt;- median(x)\n  skewness &lt;- 3 * (mean_x - median_x) / sd_x\n  return(skewness)\n}\n\n\n# 만든 함수를 사용해서 계산합니다. \n비대칭계수_계산(iris$Petal.Length)\n\n[1] -1.006062\n\n\n환경 패널의 Environment Tab의 Functions에 비대칭계수_계산이라는 함수가 나타났읍니다. 이제 RStudio를 종료하기 전까지 이 함수를 사용할 수 있습니다.\n비대칭도, 피어슨 비대칭계수"
  },
  {
    "objectID": "exploratoy-analysis.html#ggplot2-그래프를-보기-좋게",
    "href": "exploratoy-analysis.html#ggplot2-그래프를-보기-좋게",
    "title": "7  탐색적 데이터 분석",
    "section": "7.1 ggplot2 그래프를 보기 좋게",
    "text": "7.1 ggplot2 그래프를 보기 좋게\nggplot2 를 수준 높게 이용해서 그래프를 보기 좋게 그립니다.\n\nlibrary(ggplot2) # 여기서 필요한 패키지 부르기\n\n\n7.1.1 테마 이용\n예전에 3 장의 숫자형 자료의 그래프에서 그렸던 그래프를 다시 봅니다. 그 아래에 테마를 붙여 그래프를 발전시킵니다. 아래 일곱 개는 각각 그래프를 그립니다. 아래를 복사해서 실행해 보세요. R 스크립트 파일을 만들어 사용하거나 Quarto 파일을 만들어 코드 청크에 넣고 사용하세요.\n만일 경고메시지가 나타나고 그걸 없애고 싶으면 청크옵션에 #| warning: false를 넣습니다.\n\np &lt;- ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + \n      geom_point() +\n      xlab(\"Brain weight (logarithmic scale)\") +\n      ylab(\"Total sleep time\") +\n      scale_x_log10() +\n      facet_wrap(~ vore)\n\n# 다양한 테마로 그래프를 그린다\np + theme_grey() # The default theme\n\n\n\np + theme_bw()\n\n\n\np + theme_linedraw()\n\n\n\np + theme_light()\n\n\n\np + theme_dark()\n\n\n\np + theme_minimal()\n\n\n\np + theme_classic()\n\n\n\n\n\n\n7.1.2 칼라 팔레트\n배경색 같은 것과는 달리, 칼라 팔페트는 테마의 부분이 아닙니다. 팔레트는 그래프에서 점을 그릴 때 사용하는 일련의 색깔을 말합니다. 팔레트를 사용한 그래프는 색깔을 통해서 직관적으로 이해하기 좋습니다.\nscale_colour_brewer 을 이용해서 칼라 팔레트를 바꿉니다. 세 종류의 팔레트가 있습니다.\n\nSequential palettes: 한 색깔에서 하얀 색으로 점점 바뀝니다. 순위척도 변수나 등간 및 비율 척도 변수에 사용하면 좋습니다.\nDiverging palettes:한 색깔에서 다른 색까로 점점 바뀌는데 중간에 하얀 색을 거칩니다. 변수값 중간에 의미 있는 0을 가진 변수에 좋습니다.\nQualitative palettes: 다양한 색으로 된 팔레트인데, 명목척도의 변수에 좋습니다.\n\n?scale_colour_brewer를 이용하거나 http://www.colorbrewer2.org를 방문해서 팔레트의 목록을 알 수 있습니다. 아래 밑 부분에 예를 세 개 들었습니다. 그래프에 사용한 변수 vore 는 명목척도변수이므로 qualitative 팔레트가 가장 어울린다고 봅니다. 한 번 시행해 보세요.\n\np &lt;- ggplot(msleep, aes(brainwt, sleep_total, colour = vore)) + \n      geom_point() +\n      xlab(\"Brain weight (logarithmic scale)\") +\n      ylab(\"Total sleep time\") +\n      scale_x_log10()\n\n# Sequential palette:\np + scale_colour_brewer(palette = \"OrRd\")\n# Diverging palette:\n# p + scale_colour_brewer(palette = \"RdBu\")\n# Qualitative palette:\np + scale_colour_brewer(palette = \"Set1\")\n\n\n\n\n\n\nSequential Palette\n\n\n\n\n\n\n\nQualitative palette"
  },
  {
    "objectID": "exploratoy-analysis.html#테마-맞춤",
    "href": "exploratoy-analysis.html#테마-맞춤",
    "title": "7  탐색적 데이터 분석",
    "section": "7.2 테마 맞춤",
    "text": "7.2 테마 맞춤\n테마는 색깔과 글자 등 여러 요소를 잘 어울리게 미리 선택한 것입니다. 따라서 theme을 사용하면 시간과 노력을 절약합니다. 하지만 원한다면 테마의 요소를 입맛에 맞게 변경할 수 있습니다. 테마는 미학적 aes 요소에 관련이 없는 모든 시각적 요소를 통제합니다. 위 청크에서 생성한 객체(그래프) p를 사용합니다.\n\n# 범례가 없으려면 \"none\"\n# 범례가 그림 아래에 있다:\np + theme(legend.position = \"bottom\")\n# 범례가 플롯 안에 있다:\np + theme(legend.position = c(0.9, 0.7))\n\n\n\n\n\n\n범례가 아래에\n\n\n\n\n\n\n\n범례가 안에\n\n\n\n\n\n\n마지막 예의 벡터 c(0.9, 0.7)는 범례의 상대적 위치를 말합니다. c(0, 0)은 그래프의 왼쪽 아래 모서리의 위치고 c(1, 1)은 그래프의 오른쪽 위 모서리의 위치를 의미합니다. 따라서 상대적 위치는 0에서 1 사이 값을 선택하면 됩니다.\n아래의 예를 보고 theme 을 사용해 봅시다.\n\np + theme(panel.grid.major = element_line(colour = \"black\"),\n          panel.grid.minor = element_line(colour = \"purple\",\n                                          linetype = \"dotted\"),\n          panel.background = element_rect(colour = \"red\", size = 2),\n          plot.background = element_rect(fill = \"yellow\"),\n          axis.text = element_text(family = \"mono\", colour = \"blue\"),\n          axis.title = element_text(family = \"serif\", size = 14))\n\n테마의 조건을 알려면 ?theme 을 이용하거나, ?element_line (줄), ?element_rect (경계선과 배경), ?element_text (글자), 그리고 element_blank (그래프 요소의 제외) 등을 사용한다. colors() 를 이용해서 이미 있는 색깔 이름을 사용하거나 색깔의 헥사코드를 사용합니다."
  },
  {
    "objectID": "exploratoy-analysis.html#극단값과-결측값",
    "href": "exploratoy-analysis.html#극단값과-결측값",
    "title": "7  탐색적 데이터 분석",
    "section": "7.3 극단값과 결측값",
    "text": "7.3 극단값과 결측값\n여기서는 ggplot2 에 있는 diamonds 데이터셋을 이용합니다.\n\n7.3.1 극단값 탐지\n박스 그래프나 산포도 그래프는 뭔가 수상한 사례값을 찾아내는 데 도움을 줍니다. 극단값은 측정 실수나 타이핑 실수일 수 있지만,독특한 예외 사례일 수도 있습니다. 예외 사례는 가끔 중요한 정보나 통찰을 제공하기도 해서 주의깊게 살펴보는 게 좋습니다.\n다이아몬드 캐럿과 가격의 산포도를 봅시다.\n\nggplot(diamonds, aes(carat, price)) +\n      geom_point()\n\n극단값이 여럿 있지요? 예를 들어, 드문 사례인 5캐럿이지만 값이 비슷한 사례가 하나 있습니다. 3캐럿인데 여러 개 싼 것도 있고요. 이런 걸 어떻게 특정할 수 있을까요?\n상호작용적 그래프를 출력하는 plotly 패키지가 한 방법이 될 수 있습니다.\n\ninstall.packages(\"plotly\")\n\nggplot2 에서 plotly 를 사용하려면 그래프를 변수에 저장하고 ggplotly 함수를 활용해 이용합니다. 결과를 불러오는 데 시간이 좀 걸리지만 상호작용적 그래프니까 그럴 가치가 있지요.\n\nmyPlot &lt;- ggplot(diamonds, aes(carat, price)) +\n      geom_point()\n\nlibrary(plotly)\nggplotly(myPlot)\n\nplotly의 디폴트는 단지 캐럿과 가격만 보여주는 거지만 문자로 정보를 주도록 할 수도 있습니다.\n\nmyPlot &lt;- ggplot(diamonds, aes(carat, price, text = paste(\"Row:\",\n                                            rownames(diamonds)))) +\n                                            geom_point()\nggplotly(myPlot)\n\n자, 상호작용적 그래프를 활용해서 조사해 봅시다.\n\n\n7.3.2 극단값에 라벨 붙이기\n상호작용적 그래프에서 극단값 정보를 얻지만 다른 그래프나 인쇄물일 때는 그렇지 못합니다. 이때 geom_text 가 대안이 될 수 있어요. 예를 들어, 극단값을 가진 사례의 번호를, 즉 행 row 번호를 점에 넣을 수 있습니다. geom_text 를 사용하면서 조건을 붙이면 됩니다. 코드는 ifelse() 입니다.\n\n## 사레(행) 번호를 알 때 (5캐럿 사례는 27,416행에 있다)\nggplot(diamonds, aes(carat, price)) +\n      geom_point() +\n      geom_text(aes(label = ifelse(rownames(diamonds) == 27416,\n                                   rownames(diamonds), \"\")),\n                hjust = 1.1)\n## (hjust=1.1 글자가 점의 왼쪽에 위치하도록 한다)\n\n## 4 캐럿 이상의 사례는 점에 글자를 붙인다\nggplot(diamonds, aes(carat, price)) +\n     geom_point() +\n     geom_text(aes(label = ifelse(carat &gt; 4, rownames(diamonds), \"\")),\n               hjust = 1.1)\n\n## 3 캐럿이면서 값이 7500 이하인 점에 글자를 붙인다\nggplot(diamonds, aes(carat, price)) +\n      geom_point() +\n      geom_text(aes(label = ifelse(carat == 3 & price &lt; 7500,\n                                   rownames(diamonds), \"\")),\n                hjust = 1.1)"
  },
  {
    "objectID": "exploratoy-analysis.html#산포도-그래프의-추세",
    "href": "exploratoy-analysis.html#산포도-그래프의-추세",
    "title": "7  탐색적 데이터 분석",
    "section": "7.4 산포도 그래프의 추세",
    "text": "7.4 산포도 그래프의 추세\n동물의 뇌 크기와 잠 시간의 관계를 봅시다.\n\nggplot(msleep, aes(brainwt, sleep_total)) + \n      geom_point() +\n      xlab(\"Brain weight (logarithmic scale)\") +\n      ylab(\"Total sleep time\") +\n      scale_x_log10()\n\n\n\n\n점들이 내리막인 경향이 있지요? 더 확실히 확인하려면 geom_smooth 를 이용해 부드러운 선을 긋습니다.\n\nggplot(msleep, aes(brainwt, sleep_total)) + \n      geom_point() +\n      geom_smooth() +\n      xlab(\"Brain weight (logarithmic scale)\") +\n      ylab(\"Total sleep time\") +\n      scale_x_log10()\n\n\n\n\n선이 예측값이고 검은 부분이 예측값의 신뢰구간입니다. 통상 geom_smooth는 95% 신뢰구간을 사용합니다."
  },
  {
    "objectID": "exploratoy-analysis.html#애니메이션",
    "href": "exploratoy-analysis.html#애니메이션",
    "title": "7  탐색적 데이터 분석",
    "section": "7.5 애니메이션",
    "text": "7.5 애니메이션\nR의 놀라운 기능 중 하나는 애니메이션 플롯을 만드는 겁니다. 이건 먼저 plotly 패키지를 설치해야 합니다.\n“숫자로 말하라”는 말이 있습니다. 그만큼 숫자, 즉 통계는 사람을 설득하는 힘이 있습니다. 거기에 애니메이션을 더하면 설득의 힘이 아주 강하겠지요.\n\n# install.packages(plotly)\nlibrary(ggplot2)\nlibrary(plotly)\n\ndf &lt;- data.frame(\n  x = c(1,2,3,4,5), \n  y = c(1,2,3,4,5), \n  f = c(1,2,3,4,5)\n)\np1 &lt;- ggplot(df, aes(x, y)) +\n    geom_point(aes(frame=f))\nggplotly(p1)\n\ndf &lt;- data.frame(\n  x = c(1,2,3,4, 4), \n  y = c(1,2,2,3, 4), \n  f = c(1,2,3,4,5)\n)\np2 &lt;- ggplot(df, aes(x, y)) +\n    geom_point(aes(frame=f))\nggplotly(p2)\n\n\nFigure 7.1: 간단한 애니메이션 플롯\n\n\n\n\nlibrary(plotly)\nlibrary(ggplot2)\n# install.packages(gapminder)\nlibrary(gapminder)  # 데이터 패키지\n\nhead(gapminder)\ntail(gapminder)\n\np3 &lt;- ggplot(gapminder, aes(gdpPercap, lifeExp, color = continent)) +\n  geom_point(aes(size = pop, frame = year, ids = country)) +\n  scale_x_log10()\n\nggplotly(p3)\n\n방금 본 것처럼, 의외로 위의 코드가 어렵지 않습니다. 애니메이션 플롯은 적절한 데이터를 구하는 게 어렵지 코딩하는 건 오히려 간단합니다. 위의 예가 나온 Plotly ggplot2 Open Source Graphing Library 를 방문해 보세요. 애니메이션 플롯은 맨 아래에 있으니 클릭하면 애니메니션 페이지로 갑니다."
  },
  {
    "objectID": "probabilistic-distribution.html#확률",
    "href": "probabilistic-distribution.html#확률",
    "title": "8  확률분포와 표집분포",
    "section": "8.1 확률",
    "text": "8.1 확률\n확률 probability 은 어떤 사건 event 이 일어날 가능성을 말합니다. 동전을 던져 앞면이 나올 가능성, 주사위를 두 번 던져서 합이 10이 되는 가능성, 통계시험을 80점 이상 받을 가능성 등등이 확률입니다. 확률은 0부터 1 사이의 숫자나 0%부터 100% 사이의 퍼센트로 나타냅니다.\n통계에서 확률 공간 probability space 은 무작위 과정 random process 또는 ‘실험’ experience’ 을 통해 모델을 규정하는 수학적 개념입니다. 확률 공간은 반드시 세 개의 요소를 가집니다. (여기서 말하는 ’실험’과 ’표본’은 우리가 통상 사용하는 것과 좀 다릅니다. 확률론에서 정의한 용어니까, 사회과학적 용어와 약간 다릅니다.)\n\n표본 공간 sample space, \\(\\Omega\\), 실험이나 실행에서 모든 가능한 결과들 outcomes 의 집합이다.\n사건 공간 event space, \\({\\mathcal F}\\), 사건들의 집합, 사건은 결과의 한 하위집합 subset 에 속해 있다.\n확률 함수 probability function, \\(P\\), 사건 공간이 포함한 각 개별 사건들에게 확률을 부여한다.\n\n이 세 가지 요소를 통해 우리는 아래처럼 ’실험’의 확률을 예측합니다.\n\n만일 ’실험’을 실행했는데 실행의 결과가 사건공간에 속한다면, 그 사건은 발생한 것이다. 이 과정을 아주 많이 반복한다면 확률 함수 \\(P\\)가 부여한 확률대로 사건이 발생하는 경향을 보인다.\n\n어려워보이지만 사실 쉬운 설명입니다. 예를 들어 봅시다. 주사위를 던지는 ’실험’에서 표본공간은 {1, 2, 3, 4, 5, 6}입니다. 모든 가능한 결과를 포함하니까요. 우리가 원하는 게 2 이하 숫자가 나오는 것이면 사건공간은 {1, 2}입니다. 그리고 {1, 2}는 {1, 2, 3, 4, 5, 6}의 집합에 속하는 하위집합입니다. 주사위를 던지면 결과가 나옵니다. 즉, 여섯 숫자 중 하나가 나옵니다. 만일 1이나 2가 나오면 우리가 원하는 사건이 일어난 것입니다. 이걸 아주 많이 반복하면, 우리가 원하는 사건의 확률은 결국 \\((\\frac{1}{6}+\\frac{1}{6})=\\frac{1}{3}\\) 가 된다는 겁니다. 여기서 \\(\\frac{1}{6}\\) 이 주사위 개별 숫자가 가지는 확률함수입니다.\n학률, 확률공간, 표본공간, 사건공간, 확률함수\n\nExercise 8.1  \n\n\n주사위를 굴렸을 때 표본 공간은 무엇입니까?\n주사위 숫자가 2와 같거나 적게 나올 사건 공간은 무엇입니까?\n주사위 숫자가 \\(x\\)와 같거나 적게 나올 사건의 확률 함수 \\(f(x)\\)를 작성하세요. 즉 \\(P(X \\le x)=f(x)\\)\n\n\n\n해답 가기"
  },
  {
    "objectID": "probabilistic-distribution.html#확률변수",
    "href": "probabilistic-distribution.html#확률변수",
    "title": "8  확률분포와 표집분포",
    "section": "8.2 확률변수",
    "text": "8.2 확률변수\n확률변수는 무작위적 변수라는 이름이 더 잘 어울리며 모든 측정값이 무작위적 특성을 갖는다고 설명했습니다. ( 2 장의 확률변수 참고) 그런데 앞으로 변수값이란 용어가 등장하므로 혼동하지 않기 바랍니다. 측정값은 동일한 확률은 갖지만 변수값은 동일한 확률이 아닌데 확률변수라면 둘다 무작위적 확률을 가지는 겁니다.\n예를 들어, 한국대 미디어학과 {철수, 영희, 복길, 희동, 경희} 5명 있고 각각의 키는 {160, 165, 170, 170, 175} 라고 합시다. 그러면 측정값이 다섯 개가 있는 겁니다. 모든 사람마다 키를 측정했으니까 사람 수만큼 측정값이 나오겠지요. 이 중에 한 사람을 무작위로 뽑는다면 모두가 동일한 확률을 가지므로 한 학생마다 선택 가능성이 \\(\\frac{1}{5}=0.2\\)의 확률이 되고 마찬가지로 측정값이 뽑힐 확률도 0.2가 됩니다. 그런데 170cm인 측정값은 둘이지만 변수값으로 따지면 동일하므로 변수값 170cm가 선택될 확률은 \\(0.2+0.2=0.4\\) 가 됩니다. 각각의 측정값의 선택 가능성은 동일하고 특정한 변수값이 뽑힐 가능성은 해당 측정값의 빈도 수에 따라서 다르지만, 둘 다 확률은 무작위적입니다.\n측정값 \\(x_i\\) 은 \\(i\\)번째 사람이 갖는 값이고 모두 동일한 선택 확률을 갖습니다. 변수값 \\(x\\)는 사람(사례, 관찰)과 연관이 없는 그저 척도의 크기만을 나타내는 숫자입니다. 해당 변수값을 측정값으로 갖는 사람이 몇 명이냐 하는 빈도에 따라서 확률이 결정됩니다. 그래서 측정값의 확률을 알고 해당 빈도를 알면 변수값의 확률도 결정됩니다.\n아래의 그래프는 25명의 사람의 키를 측정한 것입니다. 따라서 측정값의 수, 즉 빈도는 25입니다. 변수값 166cm의 빈도가 1, 변수값 168cm의 빈도가 3, 변수값 170cm의 빈도가 5 등등입니다. 이것이 확률변수라면 모든 측정값의 선택 확률이 동일하므로 어떤 사람이 뽑혀서 키가 측정될 확률은 \\(\\frac{1}{25}\\)입니다. 따라서 168cm의 변수값이 뽑힐 확률은 그래프의 빈도가 3이므로 \\(\\frac{3}{25}\\)입니다. 170cm의 변수값이 선택될 확률은 \\(\\frac{5}{25}\\)입니다. 개별 측정값의 확률이 결정되면 빈도에 따라 특정 변수값의 확률이 결정됩니다. 이것이 확률변수이고 이것이 확률분포입니다. 확률분포는 상대빈도가 확률을 나타냅니다 (왜냐하면 각 개체의 확률이 동일하니까.)\n\n키 &lt;- c(170, 166:174, 167:173, 168:172, 169:171)\n키 &lt;- 키 + 0.1  # 그래프 모양을 예쁘게 하려고 0.1을 더하다. \n# freq=FALSE는 상대빈도를 사용하는 옵션\nhist(키, freq=FALSE, main=\"키의 상대빈도\", xlab=\"키, x 값\", ylab=\"상대빈도\", col=\"magenta\", xlim=c(166,176), ylim=c(0,0.22), labels = TRUE)  \npoints(x1, y1, pch = 16, col = \"green\") # 각 측정값을 나타낸다\n\n\n\n\n측정값, 변수값"
  },
  {
    "objectID": "probabilistic-distribution.html#이항확률분포",
    "href": "probabilistic-distribution.html#이항확률분포",
    "title": "8  확률분포와 표집분포",
    "section": "8.3 이항확률분포",
    "text": "8.3 이항확률분포\n동전을 던졌을 때, 앞면이 나타나거나 뒷면이 나타나는 단 두개의 결과만 존재합니다. (아, 물론 옆면으로 우뚝 서는 기적의 사건은 제외합니다.) 앞면이 나타는 확률은 0.5, 뒷면도 0.5입니다. 동전을 한 번 던졌을 때 앞면이 나타나는 횟수가 0이면 확률은 0.5, 횟수가 1이면 0.5입니다. 동전을 두 번 던졌을 때, (뒷,뒷) (뒷,앞) (앞,뒷) (앞,앞) 등 네 경우가 있습니다. 네 경우 모두 확률은 \\(\\frac{1}{2} \\times \\frac{1}{2}=\\frac{1}{4}\\) 입니다. 앞면이 나타나는 횟수는 각각 0, 1, 1, 2가 됩니다. 따라서 변수값(앞면 횟수)에 따라 정리하면 0은 빈도가 1, 1은 빈도가 2, 2는 빈도가 1이 됩니다. 확률은 각각 \\(\\frac{1}{4}\\), \\(\\frac{1}{4} + \\frac{1}{4} = \\frac{1}{2}\\), \\(\\frac{1}{4}\\) 입니다.\n이렇게 앞면이 나타나는 횟수의 빈도와 확률에 따른 분포를 이항분포라고 합니다. 동전을 던져 나오는 결과가 무작위적이고 그 결과에 따라 앞면 횟수의 확률이 결정됩니다. 따라서 앞면이 나오는 횟수로 만들어지는 변수는 확률변수가 되고 그것의 분포인 이항분포는 확률분포가 되는 것입니다.\n동전 던지기처럼 단 두 개의 사건만 무작위적으로 일어나는 것을 베르누이 시행 bernoulli trial 이라고 합니다. 베르누이 시행은 ’무작위적 실험’이므로 언제나 ’성공’과 ’실패’의 확률은 일정합니다. 두 사건만 존재하므로 ’성공’의 확률을 \\(p\\)라고 하면 ’실패”의 확률은 \\(1-p\\)입니다. 동전 실험이라면, 던졌을 때 앞면이 나올 확률이 \\(p\\)라고 하면 뒷면의 확률은 \\(1-p\\)가 됩니다. 베르누이 시행을 여러 번 했을 때 성공의 횟수를 빈도로 나타낸 분포를 이항분포 binominal distribution 라고 합니다. 베르누이 시행의 횟수를 \\(n\\), ’성공의 빈도를 \\(x\\), 성공의 확률을 \\(p\\)라고 할 때, 아래의 함수는 \\(x\\)의 확률(상대빈도)을 나타냅니다. \\(n\\) 번 시행하면 \\(x\\)는 0부터 \\(n\\)까지 존재하므로 그것을 모두 대입한 결과값을 그래프로 그리면 이항분포가 됩니다.\n\n이항분포의 확률함수\n\n\\[f(x) = \\binom{n}{x} p^{x} (1-p)^{n-x}\\]\n이항분포는 위의 이항분포 확률함수에 따라 분포를 아니까 이론적으로 평균과 표준편차 등을 계산할 수 있습니다.\n\\[평균: \\; \\mu=E(x)=np, \\; \\; 표준편차: \\; \\sigma=\\sqrt{np(1-p)}\\]\n이항분포의 계산은 dbinom(x,n,p)함수로 가능하고, 직접 하려면 조합을 계산하는 choose 함수를 이용하여 choose(n,x) * p^x * (1-p)^(n-x)로 가능합니다.\n베르누이 시행, 이항분포, 확률변수, 확률분포\n\nExercise 8.2  \n\n\n동전을 12번 던졌을 때 앞면이 7번 나올 확률은 얼마일까요?\n동전을 12번 던졌을 때 앞면이 나오는 갯수를 X라고 하면 X의 평균과 표준편차는 얼마일까요?\n\n\n\n해답 가기"
  },
  {
    "objectID": "probabilistic-distribution.html#확률함수와-확률분포",
    "href": "probabilistic-distribution.html#확률함수와-확률분포",
    "title": "8  확률분포와 표집분포",
    "section": "8.4 확률함수와 확률분포",
    "text": "8.4 확률함수와 확률분포\n확률함수는 확률변수의 변수값을 대입하여 결과값을 확률(상대빈도)로 나타내는 함수입니다. 바로 앞에서 배운 이항분포의 함수가 바로 확률함수입니다. 확률함수의 결과값들로 이루어진 분포가 확률분포입니다. 따라서 확률분포는 확률변수의 변수값과 그 변수값의 확률(상대도수)로 구성된 분포입니다. 확률분포에서 그래프 안의 면적, 즉 확률함수로 그린 선과 밑면 사이의 면적이 확률입니다.\n이산변수가 확률변수일 때 이산 확률분포 discrete probability distribution 를 이룹니다. 앞의 이항분포는 변수값이 정수이므로 이산 확률분포를 가집니다. 이산 확률함수를 확률질량함수 probability mass function 라고도 부릅니다. 확률분포에서 그래프 안의 면적이 확률입니다.\n이항분포를 예로 들어 봅시다. 동전을 2번 던져서 앞면이 나오는 횟수를 변수라고 할 때, 변수값은 0, 1, 2, 세 가지가 있습니다. 확률은 각각 \\(\\frac{1}{4}\\), \\(\\frac{1}{2}\\), \\(\\frac{1}{4}\\)입니다. 변수값이 정수이고 정수는 1씩 늘어나니까 밑변의 길이는 1입니다. 면적은 ’밑변x높이’니까 변수값 0의 면적이자 확률은 1x\\(\\frac{1}{4}\\)이고 변수값 1의 면적이자 확률은 1x\\(\\frac{1}{2}\\)이 됩니다. 그래프의 면적을 다 합하면 확률의 특성상 1이 되겠지요. 변수값이 정수면 밑변이 1이므로 1을 곱해도 마찬가지니까 높이인 상대도수가 그대로 확률이 되는 겁니다.\n연속변수가 확률변수일 때 연속 확률분포 continuous probability distribution 를 이룹니다. 연속 확률함수는 확률밀도함수 probability density funcition 라고도 부르는데 사실 연속확률함수는 잘 안 쓰고 확률밀도함수라는 용어를 거의 사용합니다. 그리고 연속확률분포는 그냥 확률분포라는 용어를 사용합니다. 그러니 여러분도 확률밀도함수와 확률분포라는 용어의 의미에 주목해야합니다.\n연속확률분포도 확률분포이므로 역시 그래프의 면적이 확률을 의미합니다. 그런데 이번에는 문제가 있습니다. 연속변수는 정수가 아니고 실수라서 무한한 수의 변수값이 존재합니다. 170cm가 5명, 171cm가 4명, 이렇게 되지 않고 170.1cm가 1명, 173.578cm가 1명, 173.785247cm가 1명, 이렇게 무한한 변수값에 대응해서 한 명씩 존재하게 됩니다. 즉 밑변의 길이가 \\(\\frac{1}{\\infty}\\)이어서 0라고 봐야합니다. 그래서 밑변x높이는 0이 나옵니다. 따라서 확률을 구하고 싶어서 변수값을 말할 때 구간을 명시해야합니다. 170cm-173cm 사이의 변수값에 해당하는 확률(상대도수), 이렇게 해야합니다. 바로 확률밀도함수를 그 구간으로 적분한 결과값이지요.\n왜 이름이 확률밀도함수인지 궁금하지 않아요? 왜 이산변수는 ‘질량’이고 연속변수는 ’밀도’인지도 궁금하지 않나요? 비유해서 말하자면, 질량은 밑변이 있고 밀도는 밑면이 없는 것입니다. 중력을 예로 듭니다. 지구의 중력가속도는 9.8\\(m/s^{2}\\)입니다. 그럼 나를 당기는 힘이 9.8\\(m/s^{2}\\) 인가요? 아닙니다. 중력은 질량에 비례하므로 질량이 있어야 ’질량x중력가속도’ 해서 당기는 힘을 계산합니다. 따라서 “나는 70kg인데 지구가 나를 당기는 힘이 얼마인가요?” 이렇게 물으면 답이 나옵니다.\n그러나 “나의 밀도가 0.9인데 나를 당기는 힘이 얼마인가요?” 이것은 답이 없습니다. 질량은 ’밀도x부피’로 계산하니까 부피를 알아야 질량이 나옵니다. 밀도가 0.9일 때 부피가 10\\(l\\)면 질량은 9kg, 부피가 100\\(l\\)이면 질량은 90kg입니다. 부피가 100\\(l\\)일 때는 부피가 10\\(l\\)일 때보다 중력은 10배로 작용합니다. 그래서 어린아이가 내 배 위에 올라도 버티지만 뚱뚱한 어른이 올라가면 버티지 못합니다. 확률질량함수는 변수값을 가지고 확률을 계산할 수 있고, 확률밀도함수는 변수값의 ’구간’을 정해줘야 확률을 구할 수 있습니다.\n확률분포는 확률밀도함수로 표시될 수 있습니다다. X가 연속확률변수고 아래의 조건을 충족할 때 \\(f(x)\\)를 X의 확률밀도함수라 합니다.\n\\[ 1.\\; P(X=x)=0 \\]\n연속확률변수 \\(X\\)가 특정한 변수값 \\(x\\)가 될 확률은 0입니다. (즉 밑변이 없습니다) 연속확률변수는 연속한 살수값을 가지므로 취할 수 있는 값이 무한히 많아서 그 중에 특정한 하나의 값을 가질 가능성은 없다고 봐야합니다. 따라서 구간으로 확률을 구해야 합니다.\n\\[ 2.\\; 모든 \\; X에 \\; 대하여 \\; f(x) \\ge 0 \\]\n확률밀도함수는 항상 0이거나 양수 값을 갖습니다\n\\[ 3.\\; \\int_{-\\infty}^{\\infty} f(x) \\; dx=1 \\]\n확률밀도함수를 적분하면 전체 면적은 1입니다.\n\\[ 4.\\; \\mathrm{P}( a\\le X \\le b)=\\int_{a}^{b} f(x) \\; dx \\; (단 -\\infty \\le a \\lt b \\le \\infty) \\]\n\n\n\nFigure 8.1: 확률밀도함수와 구간의 확률\n\n\n연속확률변수 X가 특정한 값 \\(a\\)와 \\(b\\) 사이에 있을 확률은 그 구간의 확률밀도함수 적분한 값, 즉 확률밀도함수 곡선과 밑변 사이의 면적과 같습니다.\n이산확률분포, 확률질량함수, 연속확률분포, 확률밀도함수"
  },
  {
    "objectID": "probabilistic-distribution.html#확률분포의-종류",
    "href": "probabilistic-distribution.html#확률분포의-종류",
    "title": "8  확률분포와 표집분포",
    "section": "8.5 확률분포의 종류",
    "text": "8.5 확률분포의 종류\n이론적으로 확립된 확률분포는 여러 가지가 있습니다. 이론적으로 확립된 분포는 분포가 알려져 있으므로 분포를 이용해서 여러 가지 통계적 분석을 할 수 있습니다. 대표적인 것이 정규분포, t 분포, \\(\\chi^{2}\\) 분포, F 분포 등이 있습니다. 이들은 추론통계에 사용될 수 있으며 가설을 검증하거나 신뢰구간을 정하거나 모델을 검증할 수 있습니다."
  },
  {
    "objectID": "probabilistic-distribution.html#정규분포",
    "href": "probabilistic-distribution.html#정규분포",
    "title": "8  확률분포와 표집분포",
    "section": "8.6 정규분포",
    "text": "8.6 정규분포\n통계에서 가장 많이 활용하는 분포는 정규분포 normal distribution 입니다. 정규분포는 가우스가 물리 계측의 오차에 대한 확률분포로서 처음 소개하였습니다. 정규분포는 자연적인 환경에서 많이 발생하는 분포입니다. 정규분포는 대칭이며 아래가 넓고 위가 좁은 종 모양과 비슷합니다. 정규분포의 확률밀도함수는 아래와 같습니다. 즉 이렇게 생긴 확률분포가 정규확률분포입니다.\n\\[X \\sim N(\\mu, \\; \\sigma^{2}) \\]\n\\[{\\displaystyle f(x)={\\frac {1}{\\sigma {\\sqrt {2\\pi }}}}e^{-{\\frac {1}{2}}\\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}}}\\;, \\; -\\infty \\lt x \\lt \\infty\\]\n여기서 \\(\\pi\\)=3.141592…, \\(e\\)= 2.71828…\n정규분포는 정규확률밀도함수에 의해 이루어지므로 분포를 알 수 있습니다. 평균을 중심으로 해서 표준편차의 거리의 사이에 있는 측정값의 확률은, 즉 상대도수는, 68.3%입니다. 표준편차의 2배 거리 사이에 있는 확률은 95.4%이고, 3배 거리의 사이에 있는 확률은 99.7%입니다. 추론통계에서 그걸 이용하는 법을 배웁니다.\ni정규분포에서 평균과 표준편차로 본 구간 확률 {#fig-pro-of-nor align=‘left’}\n아래는 \\(\\mu\\) = 0, \\(\\sigma\\) = 1 인 표준정규분포 곡선입니다. 정규분포곡선을 z값으로 표준화한 것입니다. z값을 계산하는 공식은;\n\\[Z= {\\frac {X-\\mu}{\\sigma}}\\]\n\n# 표준정규분포\nx &lt;-seq(-4, 4, length = 500)\nf &lt;- dnorm(x, mean = 0, sd = 1)\nplot(x, f, type = \"l\", col = \"black\", lwd = 2.0, ylim = c(0, 0.5), main = \"표준정규분포\")\n\n\n\n\nFigure 8.2: 표준정규분포\n\n\n\n\n평균m과 표준편차 sd를 다르게 넣으면 달라집니다. 모두 정규분포곡선입니다.\n\nx &lt;-seq(-4, 4, length = 500)\ny0 &lt;- dnorm(x, mean = 0, sd = 1)\ny1 &lt;- dnorm(x, mean = 0, sd = 0.6)\ny2 &lt;- dnorm(x, mean = 0, sd = 2)\ny3 &lt;- dnorm(x, mean = 1, sd = 1)\ny4 &lt;- dnorm(x, mean = 2, sd = 1)\n\nplot(x, y0, type = \"l\", col = \"black\", lwd = 2.0, ylim = c(0, 0.7), main = \"표준정규분포곡선(검정), 다른 표준편차(빨강), 다른 평균(녹색)\")\nlines(x, y1, type = \"l\", lwd = 2.0, col = \"red\")\nlines(x, y2, type = \"l\", lwd = 2.0, col = \"red\")\nlines(x, y3, type = \"l\", lwd = 2.0, col = \"green\")\nlines(x, y4, type = \"l\", lwd = 2.0, col = \"green\")\n\n\n\n\nFigure 8.3: 여러 정규분포곡선\n\n\n\n\n이항분포에서 시행횟수가 커질 때 이항분포는 정규분포를 닮아갑니다. 이걸 이항분포의 정규근사 The normal approximation of the binomial distribution 라고 합니다.\n\npar(mfrow = c(1,2))  # 그래프 둘을 옆으로 나란히 그린다. \n\n# 이항분포: 동전 앞면 확률은 p=0.5, 시행횟수는 n=10번일 때 앞면 횟수는 x\nn &lt;- 10\np &lt;- 0.5\nx &lt;- seq(0, n, by = 1)\nlabels = c(\"0\", \"\", \"\", \"3\", \"\", \"5\", \"\", \"7\", \"\", \"\", \"10\" )\n\n# 앞면의 횟수에 따른 확률질량함수. 즉 이론적인 실험의 기대값, y는 확률함수\ny &lt;- dbinom(x, size = n, prob = p)\n\nbarplot(y, names.arg = labels, xlab=\"앞면 나온 횟수\", xlim = c(-0.2, 10.5), ylim = c(-0.006, 0.27), ylab=\"상대빈도\", main=\"이항분포 n=10 (기대값)\")\n\n# 이항분포: 앞면 확률이 0.5, 시행횟수가 20번일 때 -- 실제 실험\np &lt;- 0.5 \nn &lt;- 20\n\n# 이항본포의 난수를 천 개 뽑는다. 즉 10번 시행해서 앞면이 몇 개 나오는가? 하는 실험을 천 번 한다. \nx &lt;- rbinom(1000, n, p)\n\nhist(x, breaks=seq(-0.5, n+0.5, by=1), freq=FALSE, xlab=\"앞면 나온 횟수\", ylim = c(0, 0.20), ylab=\"상대빈도\", main=\"이항분포 n=20 (천번 실험)\")\ncurve(dnorm(x, mean = 10, sd = 2.236), 0, 20,  col = \"red\", add = T) # 붉은 색 정규분포곡선을 추가로 넣는다\n\n\n\n\nFigure 8.4: 정규근사:기대값 vs 표본 추출\n\n\n\n\n정규분포, 표준정규분포, 정규근사\n\nExample 8.1  \n\n통계점수가 평균이 60, 표준편차가 8인 정규분포를 하는 집단에서 통계점수가 55점이라면 z값은 얼마인가요? 상위에서 몇 %에 들어갈까요?\n\n\n답:\n풀이: 정규분포에서 55점에 대한 누적확률을 구한다 (상위 %를 구한다.)\n\nz &lt;- (55-60)/8\np &lt;- pnorm(55, 60, 8, lower.tail = FALSE)  # lower.tail = FALSE 는 상위 %\ncat(\"z=\", z, \",\", \" 상위\", round(p, 2)*100, \"%\")\n\nz= -0.625 ,  상위 73 %\n\n\n\nExercise 8.3  \n\n평균이 3, 표준편차가 2인 정규분포 곡선을 그리고 거기에 동일한 조건의 누적분포 곡선을 넣으세요. 색을 달리하세요.\n\n\n해답 가기"
  },
  {
    "objectID": "probabilistic-distribution.html#t-분포",
    "href": "probabilistic-distribution.html#t-분포",
    "title": "8  확률분포와 표집분포",
    "section": "8.7 t 분포",
    "text": "8.7 t 분포\n분포는 변수값에 따른 빈도를 나타낸 것입니다. 확률분포는 확률변수의 분포이고요. t 분포는 Gosset가 student라는 익명으로 발표해서 student’s t 라는 이름으로 불립니다. t 분포는 정규분포와 모양이 아주 비슷한데 정규분포를 좀더 일반화한 것이라고 볼 수 있습니다. t 분포는 정규분포와 마찬가지로 좌우 대칭이며 종 모양의 형태를 가집니다. t 분포는 정규분포보다 더 넓게 분산되어 있습니다. 뒤에 배울 표집분포에서 표본의 크기가 30보다 작을 때 정규분포와 비슷하지만 분산이 넓어서 오차를 더 허용하는 t 분포를 자주 사용합니다.\nt 분포를 사용하는 방식은 표준정규분포의 Z값을 사용하는 방식과 거의 같습니다. 아래는 표집분포에서 평균 \\(\\bar X\\) 의 T값을 계산하는 공식입니다. T 값을 계산한 뒤에 해당 자유도를 찾아 확률을 검정합니다. T값은 Z값과 공식이 동일하지만 대응하는 분포의 값이 약간 다릅니다.\n\\[\\displaystyle  T= {\\frac {{\\bar {X}}-\\mu_\\bar X }{S_\\bar X}}\\]\n참고로, 확률변수 \\(T\\)가 자유도 \\(n\\)인 \\(t\\) 분포를 가질 때 \\(T\\) 의 확률밀도 함수는 이렇습니다.\n\\[\\displaystyle f(t)={\\frac {\\Gamma ({\\frac {n +1}{2}})}{{\\sqrt {n \\pi }}\\,\\Gamma ({\\frac {n }{2}})}}\\left(1+{\\frac {t^{2}}{n}}\\right)^{-(n +1)/2}   \\]\n\n# 표준정규분포와 여러 t 분포\nx &lt;-seq(-4, 4, length = 500)\ny &lt;- dnorm(x, mean = 0, sd = 1)\ny1 &lt;- dt(x, df =1)\ny2 &lt;- dt(x, df =2)\ny3 &lt;- dt(x, df =3)\ny4 &lt;- dt(x, df =4)\n\nplot(x, y, type = \"l\", col = \"red\", lwd = 2.0, ylim = c(0, 0.5), main = \"표준정규분포(빨강)과 여러 자유도의 t 분포(녹색)\")\n\nlines(x, y1, type = \"l\", lwd = 2.0, col = \"green\")\nlines(x, y2, type = \"l\", lwd = 2.0, col = \"green\")\nlines(x, y3, type = \"l\", lwd = 2.0, col = \"green\")\nlines(x, y4, type = \"l\", lwd = 2.0, col = \"green\")\nlines(x, y, type = \"l\", lwd = 2.0, col = \"red\")  # 빨강 줄이 맨 나중에 나오게\n\n\n\n\nFigure 8.5: 여러 t 분포\n\n\n\n\n참고로 t 분포는 바로 다음에 배우는 \\(\\chi_2\\) 분포와 연관이 있습니다. T가 자유도 df를 가지고 \\(\\chi^2\\) 역시 자유도 df를 가진다면 아래 공식이 성립합니다. T와 \\(\\chi^2\\) 는 서로 독립적입니다.\n아래 공식에 따라 t 값을 계산하는데 그대로는 어려우니까 \\(\\chi^2\\) 값을 그 아래의 공식에 따라서 대체합니다. \\[ T={\\frac {Z}{\\sqrt {\\chi^2/df }}}=Z{\\sqrt {\\frac {df }{\\chi^2}}} \\]\n\\[ S_{n}^{2}={\\frac {1}{n-1}}\\sum _{i=1}^{n}\\left(X_{i}-{\\overline {X}}_{n}\\right)^{2} \\]\n\\[  \\chi^2 = (n-1)\\frac{S_n^2}{\\sigma^2}, \\; \\; 여기서 \\chi^2 는 자유도 (n-1) 을 가진다 \\]\n\\[ Z=\\left({\\overline {X}}_{n}-\\mu \\right){\\frac {\\sqrt {n}}{\\sigma }} \\]\n위의 \\(Z\\)와 \\(\\chi^2\\) 를 아래 좌측에 대입하면 우측이 나옵니다. \\[ T\\equiv {\\frac {Z}{\\sqrt {\\chi^{2}/df }}}=\\left({\\overline {X}}_{n}-\\mu \\right){\\frac {\\sqrt {n}}{S_{n}}}\\]\n위의 공식에서 두 가지를 주목해야 합니다. 첫째는 알려지지 않는 \\(\\sigma^2\\) 가 분자와 분모에서 서로 상쇄되어 없어져 t값의 계산이 가능해졌습니다. 둘째는 \\(S_n\\) 을 주목해야합니다. 통상 S는 단일한 값이지만 여기서는 표본 크기 \\(n\\)에 따라서 표집분포가 달라지게 되었습니다. 그래서 student’s t가 자유도에 따라 분포가 달라지게 됩니다.\nt 분포\n\nExample 8.2  \n\n키 평균이 170cm이고 표준편차가 8cm인 집단이 있습니다. 키 관찰값이 자유도 15인 t 분포를 갖는다면 키 163cm에 해당하는 t값은 얼마인가요? 이 집단에서 163cm 이하의 사람을 만날 확률은 얼마인가요?\n\n\n답:\n\n(163-170)/8\n## [1] -0.875\npt(-0.875,15)\n## [1] 0.1976844\n\n\\(t = (x - \\mu) / \\sigma = (163-170)/8 = -0.875, \\; \\;p = pt(-0.875,15) = 0.197\\)\n$t = (x - \\mu) / \\sigma = (163-170)/8 = -0.875, \\; \\;p = pt(-0.875,15) = 0.197$ \n\nExercise 8.4  \n\n평균이 3, 표준편차가 2이고 자유도가 30인 t 분포 곡선을 그리고 거기에 동일한 조건에 자유도가 4인 분포 곡선을 넣으세요. 색을 달리하세요.\n\n\n해답 가기"
  },
  {
    "objectID": "probabilistic-distribution.html#카이제곱-분포",
    "href": "probabilistic-distribution.html#카이제곱-분포",
    "title": "8  확률분포와 표집분포",
    "section": "8.8 카이제곱 분포",
    "text": "8.8 카이제곱 분포\n카이제곱 분포 \\(\\chi^{2}\\) distribution 는 표준정규분포인 확률변수에서 서로 독립적이고 무작위적인 \\(k\\)개의 값을 꺼내어 제곱한 뒤에 그 합으로 이루어진 분포입니다. \\(k\\)는 자유도로 부르며 분포는 당연히 자유도에 따라서 달라집니다. 조금 아래에 자유도에 따른 \\(\\chi^{2}\\) 분포 그래프가 있습니다.\n예를 들어, 표준정규분포인 \\(N(0,1)\\)에서 3개의 Z값을 선택해 제곱의 합으로 \\(Q\\)라는 확률변수를 만든다면 \\(Q\\)=\\(Z_{1}^{2}+Z_{2}^{2}+Z_{3}^{2}\\)가 됩니다. 3개 선택해서 \\(Q_1\\) 만들고 또다른 세 개를 선택해서 \\(Q_2\\)를 만들고 … 이렇게 무한하게 \\(Q_i\\)를 만들면 그런 게 무한히 모인 \\(Q\\)는 자유도가 3인 \\(\\chi^{2}\\) 분포를 한다는 겁니다.\n참고로 \\(\\chi^{2}\\) 분포는 감마분포의 특별한 경우입니다. 확률변수 X가 자유도 \\(k\\)인 \\(\\chi^{2}\\) 분포 \\(\\chi^{2}(k)\\)를 따를 때 \\(\\chi^{2}\\) 분포의 확률밀도함수는 아래와 같습니다.\n\\[{\\displaystyle f(x;\\,k)={\\begin{cases}{\\dfrac {x^{{\\frac {k}{2}}-1}e^{-{\\frac {x}{2}}}}{2^{\\frac {k}{2}}\\Gamma \\left({\\frac {k}{2}}\\right)}},&x&gt;0 \\end{cases}}}\\]\n\\(\\chi^{2}\\) 의 자유도 \\(k\\) 는 \\(\\chi_k^{2}\\) 나 \\(\\chi^{2}(k)\\) 로 표기합니다.\n참고로 임의의 \\(a\\)에 대해서 감마함수는 아래처럼 정의됩니다.\n\\[\\displaystyle \\Gamma (a)=\\int _{0}^{\\infty }x^{a-1}e^{-x}\\,dt,\\; 단 \\; a &gt;0 \\]\n위의 식이 복잡하다면, 지금부터 말하는 표집분포에 사용되는 방법만 생각하면 됩니다. 정규분포인 모집단 \\(N(\\mu,\\sigma^{2})\\)에서 크기가 \\(k\\)인 표본 {\\(X_{1}, X_{2}, \\cdots , X_{n}\\)}을 추출했을 때 아래 식에 의한 \\(\\chi^{2}\\) 값은 자유도 \\(k-1\\)인 \\(\\chi^{2}\\)분포를 따른다는 사실을.\n\\[\\chi^{2}=\\sum Z_i^{2} = \\frac{\\sum_{i=1}^{k} (X_i-\\bar X)^{2}}{\\sigma^{2}} = \\frac{(k-1)S^{2}}{\\sigma^{2}} \\sim \\chi^{2}_{k-1}\\]\n\n# 자유도\ndf &lt;- 5\n\n# 분포를 그리기 위한 카이제곱의 값\nx &lt;- seq(0, 10, length=100)\n\n# 카이제곱분포의 값 (확률밀도함수에 카이제곱을 넣어서 구한 값)\ny &lt;- dchisq(x, df)\n\n# 카이제곱분포 그리기\nplot(x, y, type=\"l\", col = \"purple\", xlim = c(0, 10), ylim = c(0, 0.5), xlab=\"카이제곱\", ylab=\"확률밀도\", main=\"카이제곱분포\")\n\n#여기까지가 AI chatGPT가 코딩\n\ny1 &lt;- dchisq(x, 1)\ny2 &lt;- dchisq(x, 2)\ny3 &lt;- dchisq(x, 3)\ny4 &lt;- dchisq(x, 4)\n\nlines(x, y1, type = \"l\", lwd = 2.0, col = \"red\")\nlines(x, y2, type = \"l\", lwd = 2.0, col = \"orange\")\nlines(x, y3, type = \"l\", lwd = 2.0, col = \"green\")\nlines(x, y4, type = \"l\", lwd = 2.0, col = \"blue\")\n\nlegend(\"top\", ncol = 3, col = c(\"red\", \"orange\", \"green\", \"blue\", \"purple\"), lwd = 2.0, lty = 1, bty = \"n\", \n       legend = c(\"자유도 1\", \"자유도 2\", \"자유도 3\", \"자유도 4\", \"자유도 5\"))\n\n\n\n\nFigure 8.6: 카이제곱분포\n\n\n\n\n참고: 위의 코드는 챗지피티를 일부 이용했어요\n\nknitr::include_graphics('images/chi-distr-by-chatgpt.png')\n\n\n\n\nFigure 8.7: AI chatGPT가 작성한 카이제곱 그래프의 코드\n\n\n\n\n아래는 4종류의 자유도와 범례(legend)를 갖춰 만들라는 부탁을 받은 chatGPT의 코딩\n\n# Set the degrees of freedom for the chi-square distributions\ndf &lt;- c(1, 2, 3, 4)\n\n# Create a sequence of x values to plot the distributions\nx &lt;- seq(0, 15, length=100)\n\n# Calculate the probability density function of the chi-square distributions\ny1 &lt;- dchisq(x, df[1])\ny2 &lt;- dchisq(x, df[2])\ny3 &lt;- dchisq(x, df[3])\ny4 &lt;- dchisq(x, df[4])\n\n# Plot the chi-square distributions with colored legends\nplot(x, y1, type=\"l\", col=\"red\", lwd=2, xlab=\"x\", ylab=\"Probability Density\", main=\"Chi-Square Distributions with Different Degrees of Freedom\")\nlines(x, y2, col=\"green\", lwd=2)\nlines(x, y3, col=\"blue\", lwd=2)\nlines(x, y4, col=\"purple\", lwd=2)\nlegend(\"topright\", legend=c(paste(\"df=\", df[1]), paste(\"df=\", df[2]), paste(\"df=\", df[3]), paste(\"df=\", df[4])), col=c(\"red\", \"green\", \"blue\", \"purple\"), lwd=2)\n\n\n\n\nFigure 8.8: 챗지피티가 그린 카이제곱 그래프\n\n\n\n\n카이제곱 분포"
  },
  {
    "objectID": "probabilistic-distribution.html#f-분포",
    "href": "probabilistic-distribution.html#f-분포",
    "title": "8  확률분포와 표집분포",
    "section": "8.9 F 분포",
    "text": "8.9 F 분포\nF 분포는 각각 \\(\\chi^{2}\\) 분포를 하는 2개의 독립적 확률변수로 이루어진 분포이며 따라서 2개의 자유도를 가지고 그것에 따라 분포가 달라집니다. 확률독립변수를 각각 \\(V_1\\), \\(V-2\\) 라고 하고 자유도를 \\(d_1\\)\\(d_2\\) 라고 할 때 아래의 식이 성립합니다.\n\\[\\displaystyle F={\\frac {V_{1}/d_{1}}{V_{2}/d_{2}}} \\;=\\; \\sim F(d_1, d_2) \\]\n\\(X\\)에 대한 확률밀도함수는 아래와 같이 표시됩니다.\n\\[ f(x) = \\frac{\\Gamma(\\frac{d_1 + d_2}{2})}{\\Gamma(\\frac{d_1}{2}) \\Gamma(\\frac{d_2}{2})} \\left(\\frac{d_1}{d_2}\\right)^{\\frac{d_1}{2}} \\frac{x^{\\frac{d_1}{2}-1}}{\\left(1+\\frac{d_1}{d_2}x\\right)^{\\frac{d_1+d_2}{2}}} \\]\n여기서 \\(x \\gt 0\\), \\(\\Gamma\\)는 \\(\\Gamma\\) 함수입니다.\nF 분포"
  },
  {
    "objectID": "probabilistic-distribution.html#각-분포에-대한-r-함수",
    "href": "probabilistic-distribution.html#각-분포에-대한-r-함수",
    "title": "8  확률분포와 표집분포",
    "section": "8.10 각 분포에 대한 R 함수",
    "text": "8.10 각 분포에 대한 R 함수\n지금까지 정규분포, t 분포, \\(\\chi^2\\) 분포, F 분포 등 분포 4 종류를 배웠습니다. R에는 각 분포마다 4개의 함수가 있습니다.\n\n\nTable 8.1: 각 분포에서 사용하는 R 함수\n\n\n\n\n\n\n\n\n\n함수\n정규분포\nt 분포\n\\(\\chi^2\\) 분포\nF 분포\n\n\n\n\n확률밀도함수\ndnorm(x, mu, sigma)\ndt\ndchisq\ndf\n\n\n누적밀도함수\npnorm(x, mu, sigma)\npt\npchisq\npf\n\n\n역누적밀도함수\nqnorm(k, mu, sigma)\nqt\nqchisq\nqf\n\n\n난수발생함수\nrdorm(n, mu, sigma)\nrt\nrchisq\nrf\n\n\n\n\n\nd는 확률밀도함수: density function. 준 값의 확률(상대빈도)을 알려준다. 통상 분포 곡선을 그릴 때 사용한다.\np는 누적밀도함수: cumulative density function. 준 값에 대한 누적확률을 알려준다. 추정과 검정에서 대개 이것을 사용한다.\nq는 역누적밀도함수: inverse cumulative density function. upper k % of quantile of distribution. 준 누적확률에 대한 해당 값을 알려준다.\nr은 난수발생함수: random numbers. 해당 분포에 따라서 난수들을 발생시킨다. (즉 표본을 뽑아준다)\n\n누적밀도함수에서 오른쪽부터 누적을 하려면 lower.tail = FALSE를 넣으면 됩니다. 예를 들어,\n\n# 자유도 14를 갖는 t 분포에서 t값 -0.785 에 해당하는 누적확률은 (왼쪽 면적)\npt(-0.785, 14)\n# 오른쪽 면적을 구하려면 1에서 빼면 된다 (오른쪽 면적 = 1-왼쪽 면적)\n1-pt(-0.785, 14)\n# 오른쪽 면적을 직접 구하려면 (오른쪽 면적)\npt(-0.785, 14, lower.tail = FALSE)\n\n이 외에도 이항분포 binominal distribution 의 함수 dbinom(p-, q-, r-), 균일분포 uniform distribution 의 함수 dunif (p-, q-, r-), 지수분포 expotential distribution 의 함수 dexp (p-, q-, r-) 등 여러 분포에 대한 함수가 같은 방식으로 더 있습니다."
  },
  {
    "objectID": "probabilistic-distribution.html#표집분포",
    "href": "probabilistic-distribution.html#표집분포",
    "title": "8  확률분포와 표집분포",
    "section": "8.11 표집분포",
    "text": "8.11 표집분포\n표집분포 sampling distribution 는 한국에서 표본분포라고도 합니다. 모집단에서 가능한 모든 표본을 추출해서 통계량을 계산한다면 매우 많은 통계량이 산출될 것이고, 그 통계량의 분포를 표집분포라고 합니다.\n평균을 예로 들어 보죠. 모집단을 한국의 고등학생으로 설정하고 100명 크기의 표본을 뽑아 키 평균을 산출한다고 하죠. 평균이 하나 나오는데 170cm라고 합시다. 또 다른 100명 크기 표본을 뽑아 평균을 산출하니 이번에는 167cm가 나왔습니다. 또 다른 표본을 뽑아 평균을 산출하고 … 이런 식으로 가능한 모든 표본을 뽑아서 모든 평균을 산출하는 겁니다. 고등학생 수가 약 120만 명이므로 거기서 100명을 뽑는다면 표본의 가짓수가 엄청나게 많을 겁니다. 흔히 말하는 천문학적인 숫자의 표본들이 나오고 그 만큼 엄창난 수의 평균이 산출될 겁니다. 이러한 가능한 모든 평균을 산출하여 늘어놓은 분포가 바로 표집분포입니다. 이번 예는 100명 크기 표본의 키 평균의 표집분포입니다.\n표집분포는 산출되는 평균 등의 통계량이 확률변수이므로 확률분포입니다. 통계량의 모든 산출값이 선택될 확률이 동일한 거죠. 이론적으로 확률변수로 논의되는 통계량은 \\(\\bar X\\) 처럼 대문자로 표시하고 실제로 표본을 뽑아 계산한 통계량은 \\(\\bar x\\) 처럼 소문자로 표시합니다. 분산의 경우에도 \\(S^{2}\\)와 \\(s^{2}\\)로 각각 표시합니다. 다른 부분에서도 동일한 원칙이 적용됩니다. 확률변수로서 논의할 때는 대문자, 실제 측정한 숫자로서 논의할 때는 소문자입니다.\n표집분포, 표본분포, 통계량\n\n8.11.1 중심극한 정리\n정규분포에서 나온 평균의 표집분포는 정규분포를 이루지만 정규분포가 아닌 비정규분포에서 나온 평균의 표집분포는 정규분포가 아닐 수 있습니다. 추론 통계애서 추론을 하려면 분포를 알아야 하는데 정규분포가 아니라면 추론을 하기가 어렵습니다. 중심극한 정리 central limit theorem 는 이런 걱정을 없애줍니다.\n중심극한정리는 비정규분포에서 나온 평균의 표집분포라도 표본의 크기가 충분히 크다면 정규분포를 갖는다고 알려줍니다. 따라서 추론통계분석이 가능합니다.\n위의 내용을 중심극한정리 공식으로 나타내자면\n평균이 \\(\\mu\\) 이고 분산이 \\(\\sigma^{2}\\)인 모집단에서 크기 \\(n\\)인 표본의 평균 \\(\\bar X\\)의 분포는 \\(n \\rightarrow \\infty\\) 일때\n\\[\\displaystyle \\bar X \\rightarrow N(\\mu, \\frac{\\sigma^{2}}{n}), \\; Z=\\frac{\\bar X - \\mu}{\\frac{\\sigma}{\\sqrt n}} \\rightarrow N(0,1)   \\]\n중심극한정리, 정규분포, 비정규분포, 표본평균의 분포"
  },
  {
    "objectID": "probabilistic-distribution.html#평균의-표집분포-한-모집단",
    "href": "probabilistic-distribution.html#평균의-표집분포-한-모집단",
    "title": "8  확률분포와 표집분포",
    "section": "8.12 평균의 표집분포; 한 모집단",
    "text": "8.12 평균의 표집분포; 한 모집단\n모집단이 정규분포를 한다면 그리고 표본의 크기가 충분하다면, 표본평균 \\(\\bar X\\) 의 표집분포는 정규분포를 합니다. 그리고 표집분포의 평균 \\(\\mu_\\bar X\\) 은 모집단의 평균 \\(\\mu\\) 과 같고, 표집분포의 표준편차 \\(\\sigma_\\bar X\\) 는 모집단의 표준편차를 \\(n\\) 으로 나눈 \\(\\frac{\\sigma}{\\sqrt n}\\)과 같습니다. 간단히 말해서:\n\n표본평균들의 평균은 모평균과 같다:\n\n\\[ E(\\bar X) = \\mu_\\bar X = \\mu\\]\n\n표본평균들의 표준편차는 모표준편차를 \\(\\sqrt n\\)으로 나눈 것과 같다:\n\n\\[S(\\bar X) = \\sigma_\\bar X = \\frac{\\sigma}{\\sqrt n}\\]\n아래는 모집단에서 무한한 표본을 추출해서 평균의 표집분포를 만드는 그림입니다.\n\n\n\nFigure 8.9: 모집단과 평균의 표집분포\n\n\n모집단이 정규분포를 하지 않을 때는 중심극한 정리에 따라 표본의 크기가 충분히 커지면, 약 30 이상이 되면, 표집분포는 정규분포에 근접하며 따라서 위의 공식을 동일하게 적용합니다. 즉 표본의 평균들은 정규분포를 합니다.\n위에서 논의한 것은 모집단이 무한모집단일 경우를 가정한 것입니다. 무한모집단이 아닐 경우에 둘로 나뉩니다. 유한모집단이지만 복원추출 sampling with replacement 을 한다면 무한모집단과 동일한 방식으로 적용할 수 있습니다. 복원추출은 표본을 뽑아도 그 표본이 모집단에 다시 그대로 복원된다는 가정을 하니까 무한모집단과 유사합니다. 문제가 되는 것은 비복원추출 sampling without replacement 입니다. 유한한 모집단에서 표본을 뽑으면 모집단의 크기가 달라져서 일반적인 공식을 적용하지 못하고 보정을 해줘야 합니다.\n\n유한모집단 비복원추출일 경우에 아래의 공식을 적용한다.\n\n\\[S(\\bar X) =\\sigma_\\bar X = \\frac{\\sigma}{\\sqrt n} \\sqrt \\frac{N-n}{N-1}\\]\n뒷부분인 \\(\\sqrt \\frac{N-n}{N-1}\\)를 따로 유한모집단 수정계수 finite population correction factor 라고 합니다.\n표본을 조사해서 모평균 \\(\\mu\\) 을 추정하거나 검정할 때 정규분포를 사용합니다. 이때 모분산 \\(\\sigma^{2}\\) 이 필요한데 모분산은 통상 알려져 있지 않으므로 표준정규분포 \\(Z=\\frac{\\bar X-\\mu}{\\sigma/\\sqrt n}\\) 를 이용하기 어렵습니다. 하지만 정규분포의 모집단에서 나온 표본평균 \\(\\bar X\\)의 표집분포는 정규분포를 한다고 이미 알려졌고, 비정규분포 모집단의 표본평균도 중심극한 정리에 의해서 표본의 크기가 크다면 정규분포를 한다고 알려져서 문제가 없습니다. 왜냐하면 정규분포를 한다면 표본분산이 모분산과 유사하므로 대신 사용해도 문제가 적기 때문입니다. 표본의 크기가 30 이하일 때 충분히 크지 못하므로 표준정규분포인 z분포를 사용할 수 없는데 이때 자유도가 \\(n-1\\) 인 t 분포를 사용합니다.\n우리는 평균의 표집분포에서 표준편차를 계산할 때 모집단의 표준편차 \\(\\sigma\\) 를 사용해야 하지만 실제로는 모집단의 표준편차를 모르므로 표본의 표준편차 \\(S\\) 를 사용합니다. 그래서 표본의 크기가 작아지면 오차의 가능성이 높아집니다. 그래서 표본의 크기가 적으면, 30 이하면, t 통계량을 사용합니다. \\(t\\) 분포는 \\(n-1\\) 의 자유도에 따라 분포가 약간씩 다릅니다.\n\\[\\displaystyle  t= {\\frac {{\\bar {X}}-\\mu_\\bar X }{S_\\bar X}}={\\displaystyle {\\frac {{\\bar {X}}-\\mu }{\\frac{S}{\\sqrt {n}}}}},   \\]\n\\[ 여기서\\; \\;  \\displaystyle S={\\sqrt \\frac {\\sum _{i=1}^{n}(X_{i}-{\\bar {X}})^{2}}{n-1}}   \\]\n무한모집단, 유한모집단, 복원추출, 비복원추출, 유한모집단 수정계수, t 값\n\nExample 8.3  \n\n모집단의 나이 평균이 40살이고 표준편차가 6살입니다. 크기가 40인 표본을 모두 추출해서 평균을 계산한다면, 그 표본평균들의 평균과 표준오차는 얼마가 될까요?\n\n\n답: \\(\\mu_{\\bar X}\\)=40, \\(\\sigma_{\\bar X}\\)=0.9486833\n$\\mu_{\\bar X}$=40, $\\sigma_{\\bar X}$=`r 6/sqrt(40)`\n\nExercise 8.5  \n\n모집단의 평균이 3이고 표준편차가 2일 때, 크기가 36인 표본의 평균의 표집분포 곡선을 그리세요.\n\n\n해답 가기\n\nExercise 8.6  \n\n정규분포인 모집단에서 크기가 16인 표본을 추출하여 계산하니까 평균이 3이고 표준편차가 2가 나왔습니다. 이때 표본 평균의 표집분포 곡선을 그리세요.\n\n\n해답 가기"
  },
  {
    "objectID": "probabilistic-distribution.html#평균-차이의-표집분포-두-모집단",
    "href": "probabilistic-distribution.html#평균-차이의-표집분포-두-모집단",
    "title": "8  확률분포와 표집분포",
    "section": "8.13 평균 차이의 표집분포; 두 모집단",
    "text": "8.13 평균 차이의 표집분포; 두 모집단\n이번에는 모집단이 두 개 있을 때 평균 차이의 표집분포입니다. 평균이 각각 \\(\\mu_1\\), \\(\\mu_2\\)이고 표준편차가 \\(\\sigma_1\\), \\(\\sigma_2\\) 인 두개의 독립적인 모집단이 있다고 합시다. 또 그 모집단에서 각각 크기가 \\(n_1\\), \\(n_2\\) 인 표본을 추출했다고 합시다. 만약 표본이 충분히 크다면 두 표본의 평균 차이인 \\(\\bar x_1-\\bar x_2\\) 는 평균이 \\(\\mu_1-\\mu_2\\)이고 표준편차가 \\(\\sqrt{\\frac{\\sigma_1^{2}}{n_1}+\\frac{\\sigma_2^{2}}{n_2}}\\) 인 정규분포를 합니다.\n정리하면\n\\[ \\mu_{\\bar x_1-\\bar x_2}=\\mu_1-\\mu_2 \\]\n\\[ \\sigma_{\\bar x_1-\\bar x_2} = \\sqrt{\\frac{\\sigma_1^{2}}{n_1}+\\frac{\\sigma_2^{2}}{n_2}} \\]\n\nExample 8.4  \n\n모집단에서 남자의 나이 평균은 44살이고 표준편차는 6살, 여자의 나이 평균은 40살이고 표준편차는 4살입니다. 크기가 40인 표본을 남녀 별로 각각 추출해서 남녀 평균의 차이를 계산하는 걸 가능한 모든 경우에 실행한다면, 그 표본평균의 차이들의 평균과 표준오차는 얼마가 될까요?\n\n\n답: \\(\\mu=44-40=4\\), \\(\\sigma\\)=1.1401754\n$\\mu=44-40=4$,  $\\sigma$=`r sqrt(6^2/40+4^2/40)`\n\nExample 8.5  \n\n국민대학교 1학년과 2학년의 성적 차이를 추정하려고 합니다. 둘다 표본 크기는 40명씩입니다. 1학년 평균은 3.40이고 표준편차는 0.2, 2학년 평균은 3.55이고 표준편차는 0.22로 결과가 나왔습니다.\n\n1학년과 2학년의 평균 차이의 평균은 얼마로 추정할 수 있을까요?\n또 평균차이에 대한 표준오차는 얼마로 추정할 수 있을까요?\n\n\n\n답\n\n# collapse: true 이 옵션을 쓰면 결과가 붙어서 출력합니다. \nm_1&lt;-3.40   # 1학년\nsd_1 &lt;-0.2\nn_1&lt;-40\nm_2&lt;-3.55   # 2학년\nsd_2&lt;-0.22\nn_2&lt;-40\n\nm_diff&lt;-m_1-m_2   # 평균 차이\nse &lt;- sqrt(sd_1^2/40+sd_2^2/40)   # 평균 차이의 표준오차\n\n\\(\\mu_{\\bar X1-\\bar X2}=\\) = -0.15, \\(\\sigma_{\\bar X1-\\bar X2}\\)=0.0470106\n$\\mu_{\\bar X1-\\bar X2}=$ = `r m_diff`,   $\\sigma_{\\bar X1-\\bar X2}$=`r se`\n\nExercise 8.7  \n\n바로 위의 Example 8.5 자료를 이용하여 평균 차이의 분포 그래프를 그리세요.\n\n\n해답 가기"
  },
  {
    "objectID": "probabilistic-distribution.html#분산의-표집분포-한-모집단",
    "href": "probabilistic-distribution.html#분산의-표집분포-한-모집단",
    "title": "8  확률분포와 표집분포",
    "section": "8.14 분산의 표집분포; 한 모집단",
    "text": "8.14 분산의 표집분포; 한 모집단\n분산의 표집분포는 \\(\\chi_2\\) 분포를 이용해서 알 수 있습니다.\n\n모집단의 분산\n\n\\[ Var(X)= \\sigma^{2} = \\frac{\\sum_{i=1}^{N}(X_i -\\mu)^{2}}{N}\\]\n\n표본의 분산\n\n\\[ S^{2} = \\frac{\\sum_{i=1}^{n}(X_i -\\bar X)^{2}}{n-1}\\]\n\n카이제곱분포의 정의, 표준화한 변수 Z의 분산\n\n\\[ Z \\sim N(0, 1)일 때,\\; \\;  Z_1^{2}+Z_2^{2}+Z_3^{2}+ ... +Z_n^{2} \\sim \\chi^{2}(n) \\]\n\n표본분산과 모분산의 관계\n\n\\[ \\displaystyle \\chi^{2}= \\frac{(n-1)S^{2}}{\\sigma ^{2}} \\sim \\chi_{n-1}^{2} \\]\n즉 표본분산에 \\(n-1\\)을 곱한 것을 모분산으로 나누면 \\(\\chi_2\\)값이 되고 이것은 자유도 \\(n-1\\)의 \\(\\chi_2\\) 분포를 합니다. 따라서 표본분산과 모분산이 같아질수록 \\(\\chi_2\\)값은 \\(n-1\\)에 근접합니다. 모분산이 크면 값이 작아지고, 표본분산이 크면 값이 커집니다. \\(n\\)이 충분히 커지면, 즉 30이 넘으면 \\(\\chi_{2}\\)는 정규분포에 가까와집니다.\n\nExample 8.6  \n\n모분산이 30일 때 크기가 16인 표본의 분산이 36보다 작을 확률은 얼마인가요?\n\n\n답: 모분산과 표본분산의 관계는 위 공식처럼 자유도 \\((n-1)\\)인 \\(\\chi^2\\) 분포를 따른다. 즉 \\(\\sigma^2\\)=30일 때 \\(n\\)=16인 표본분산의 분포에서 \\(S^2\\)=36인 값의 확률이 얼마인가하는 문제다. 공식에 대입하면,\n\\[ P \\left( \\chi^{2} \\le \\frac{(n-1)S^{2}}{\\sigma ^{2}} \\right) = P \\left( \\chi^{2} \\le \\frac{(16-1) 36}{30} \\right) = P \\left( \\chi^{2} \\le 18 \\right)\\]\n따라서 자유도가 15이고 18보다 작은 \\(\\chi^2\\)값이 나올 (누적)확률은 0.7373344이다.\n# 답의 위 공식에서 큰 괄호를 집어넣는 방법: \\left(    \\right)\n\n$$ P \\left( \\chi^{2} \\le \\frac{(n-1)S^{2}}{\\sigma ^{2}} \\right) = P \\left( \\chi^{2} \\le \\frac{(16-1) 36}{30} \\right) = P \\left( \\chi^{2} \\le 18 \\right) $$\n  \n# 원문에 R 함수를 넣어 결과를 출력하는 방법\n  \n따라서 자유도가 15이고 18보다 작은 $\\chi^2$값이 나올 (누적)확률은 `r pchisq(18,15)`이다. \n\n8.14.1 분산의 표집분포; 두 모집단\n두 모집단의 분산 표집분포는 \\(F\\) 분포를 이용해서 알 수 있습니다. 정규분포를 하며 각각 \\(\\sigma_1^{2}\\), \\(\\sigma_2^{2}\\) 의 분산을 갖는 독립적인 두 모집단에서 각각 \\(n_1\\), \\(n_2\\) 의 크기를 가진 표본을 뽑아 분산의 표집분포를 만들어봅시다. 두 표본분산을 각각 \\(S_1\\), \\(S_1\\) 라고 할때 다음과 같은 관계가 형성됩니다.\n\\[ \\displaystyle \\chi_1^{2}= \\frac{(n_1-1)S_1^{2}}{\\sigma_1^{2}} \\sim \\chi^{2}(n-1) \\]\n\\[ \\displaystyle \\chi_2^{2}= \\frac{(n_2-1)S_2^{2}}{\\sigma_2^{2}} \\sim \\chi^{2}(n-1) \\]\n\\[\\displaystyle \\frac{\\chi_1^{2}/v_1}{\\chi_2^{2} / v_2} = \\frac{S_1^{2}/\\sigma_1^{2}}{S_2^{2}/\\sigma_2^{2}} \\sim F(v_1, v_2)\\] \\[ 위에서 \\; \\; v_1(자유도)=n_1-1, \\; \\; v_2(자유도)=n_2-1\\]\n여기에서 우리가 만일 두 모집단의 분산이 같다고 가정을 한다면 \\((\\sigma_1^{2}=\\sigma_2^{2})\\) 위의 식은 아래처럼 간단해집니다.\n\\[ \\frac{S_1^{2}}{S_2^{2}} \\sim F(v_1, v_2) \\]\n위의 공식들에서 분자와 분모가 바뀌면 역수가 됩니다. 그래서 아래와 같은 공식이 성립합니다. 자유도의 순서가 바뀌는 걸 주의하세요.\n\\[ F_{\\alpha} (v_1,v_2) = \\frac{1}{F_{1-\\alpha} (v_2, v_1)}  \\]\n\\(F\\) 분포도 표본 크기가 커지면 정규분포에 가까와집니다."
  },
  {
    "objectID": "probabilistic-distribution.html#sec-pro-n-1",
    "href": "probabilistic-distribution.html#sec-pro-n-1",
    "title": "8  확률분포와 표집분포",
    "section": "왜 n이 아니고 n-1인가?",
    "text": "왜 n이 아니고 n-1인가?\n확률 변수와 표집 분포를 배웠으니 이제 표본 표준편차가 왜 n이 아니라 n-1로 나누어야 하는지, 그 이유를 기대값을 사용해서 설명할 수 있게 되었습니다.\n\\[ E(S^{2})=E \\Big[ \\frac{\\sum(x_i-\\bar{x})^{2}}{n-1} \\Big] = \\frac{1}{n-1} E \\Big[  \\sum \\big( \\; (x_i - \\mu) - (\\bar{x}-\\mu) \\; \\big)^{2} \\Big] \\]\n\\[ \\; \\; \\; \\; \\; \\; \\; \\; \\; \\; \\; \\; \\; \\; = \\frac{1}{n-1} E \\Big[  \\sum \\big( \\; (x_i - \\mu)^{2} - 2(x_i-\\mu)(\\bar{x}-\\mu) + (\\bar{x}-\\mu)^{2} \\; \\big) \\Big]  \\]\n\\[ = \\frac{1}{n-1} E \\Big[  \\sum (x_i - \\mu)^{2} - n(\\bar{x}-\\mu)^{2} \\; \\Big] \\; \\; \\; \\; \\; \\; \\; \\; \\; \\;   \\; \\; \\; \\; \\; \\; \\;  \\]\n\\[ = \\frac{1}{n-1} \\sum E (x_i - \\mu)^{2} - \\frac{n}{n-1}E(\\bar{x}-\\mu)^{2} \\; \\Big]   \\; \\; \\; \\; \\; \\; \\; \\]\n\\[ = \\frac{1}{n-1}n\\sigma^{2} - \\frac{n}{n-1}\\sigma^{2}_\\bar{x} \\]\n\\[ = \\frac{n}{n-1} \\sigma^{2} - \\frac{n}{n-1} \\frac{\\sigma^{2}}{n} \\]\n\\[ = \\frac{n}{n-1} \\sigma^{2} - \\frac{1}{n-1} \\sigma^{2} \\]\n\\[ = \\sigma^{2} \\; \\; \\; \\; \\; \\;  \\; \\; \\; \\; \\; \\;  \\;  \\; \\; \\; \\; \\; \\; \\;  \\; \\; \\; \\; \\; \\; \\]"
  },
  {
    "objectID": "inference-hypothesis.html#추정",
    "href": "inference-hypothesis.html#추정",
    "title": "9  추정과 가설 검정",
    "section": "9.1 추정",
    "text": "9.1 추정\n추정 estimation 은 표본 통계량에서 모집단의 모수를 계산해내는 과정을 말합니다. 점 추정과 구간 추정이 있습니다. 이때 해당 통계량의 표집 분포를 이용하고 그 과정을 통계적 추론 statistical inference 이라고 합니다. 추정 외에 가설검정도 통계적 추론에 속합니다.\n추정, 통계적 추론"
  },
  {
    "objectID": "inference-hypothesis.html#sec-hyp-p-estimate",
    "href": "inference-hypothesis.html#sec-hyp-p-estimate",
    "title": "9  추정과 가설 검정",
    "section": "9.2 점 추정",
    "text": "9.2 점 추정\n점 추정 point estimation 은 표본에서 모수의 값을 추정하는 것을 말하며 평균, 분산, 비율 등이 있습니다. 점 추정에 사용하는 값을 점 추정값 point estimate 또는 그냥 추정값 estimate 으로 부릅니다. 좋은 점 추정은 아래의 속성을 갖습니다.\n\n일치 consistent: 표본 크기가 커지면 추정값이 더 정확해진다\n불편 unbiased: 표집 분포의 기대값이 모수와 같다.\n불편최소분산 most efficient: 표집 분포의 분산이 가장 작다. 즉 표본과 표본 사이의 측정값 차이가 가장 적다.\n\n점 추정의 방법이 위의 기준을 잘 충족하는지 여부는 모집단의 분포에 따릅니다. 모집단 분포가 정규분포에 가까우면 평균이 좋은 추정방법 estimator 이지만 한쪽으로 심하게 기울었다면 skewed 중간값이 좋은 추정방법 estimator 입니다.\n점 추정, 점 추정값, 추정값\n\n9.2.1 모 평균의 점 추정\n모 평균 추정값은 표본 평균을 가장 많이 사용합니다.\n\\[ \\bar X = \\frac{X_1+X_2+ ... +X_n}{n}=\\frac{1}{n}\\sum_{i=1}^{n} X_i \\]\n\n\n9.2.2 모 분산의 점 추정\n모 분산 추정값은 표본 분산을 가장 많이 사용합니다. 표본분산을 구할 때 \\((n-1)\\)로 나누는 걸 잊지 마세요.\n\\[ S^{2} = \\frac{\\sum_{i=1}^{n}(X_i-\\bar X)^{2}}{n-1}  \\]\n\n\n9.2.3 모 비율의 점 추정\n비율은 모집단에서 어떤 속성을 갖는 요소의 비율을 말합니다. 남녀 비율, 특정 후보의 지지율, 실업률, 합격률 등등이 있습니다. 모집단의 변수가 1과 0의 값만을 갖는다고 할 때 그 평균과 같습니다.\n\\[ p = \\frac{K}{n}, \\; \\; K는 \\; 표본에서 \\; 해당 \\; 속성을 \\; 갖는 \\; 갯수 \\]"
  },
  {
    "objectID": "inference-hypothesis.html#sec-hyp-conf-interval",
    "href": "inference-hypothesis.html#sec-hyp-conf-interval",
    "title": "9  추정과 가설 검정",
    "section": "9.3 구간 추정",
    "text": "9.3 구간 추정\n구간 추정 interval estimation 은 모수의 추정을 구간으로 하는 것입니다. 이때 구간을 신뢰구간 confidence interval 이라고 하는데 구간이 모수를 포함할 확률에 따라 달라지며 이때 확률을 신뢰수준 confidence level 이라고 합니다. 90%, 99% 등도 있으나 보통 95%를 많이 사용합니다. 95% 신뢰수준의 의미는, 만일 표본을 100개 뽑아서 평균의 신뢰구간을 모두 계산한다면 그 중에 95개의 신뢰구간이 모평균을 포함할 가능성을 말합니다.\n일단 계산이 된 특정한 신뢰구간은 확률을 말할 수 없습니다. 따라서 계산된 신뢰구간이 모 평균을 포함하고 있을 가능성이 95%라고 말할 수 없습니다.\n구간 추정, 신뢰구간, 신뢰수준"
  },
  {
    "objectID": "inference-hypothesis.html#모-평균의-구간-추정",
    "href": "inference-hypothesis.html#모-평균의-구간-추정",
    "title": "9  추정과 가설 검정",
    "section": "9.4 모 평균의 구간 추정",
    "text": "9.4 모 평균의 구간 추정\n\n모집단이 정규 분포고 모 분산을 알 때\n\\[  \\bar X \\sim N(\\mu, \\frac{\\sigma^{2}}{n}) ,  \\; \\; Z=\\frac{\\bar X-\\mu}{\\frac{\\sigma}{\\sqrt{n}}} \\sim N(0,1) \\] 여기서 \\(Z\\)는 \\(\\bar X\\) 를 표준화시키면 표준정규분포를 한다는 것을 의미합니다.\n신뢰수준이 \\(c\\) 라면 \\(\\alpha=1-c\\) (즉 신뢰수준이 95%라면 $= 0.05)\n\\[ P(\\bar X - z_{\\alpha/2}\\frac {\\sigma}{\\sqrt {n}} \\leq \\mu \\leq \\bar X + z_{\\alpha/2}\\frac {\\sigma}{\\sqrt {n}}) = 1-\\alpha \\]\n여기서 \\(z_{\\alpha/2}\\)는 \\({\\alpha/2}\\)에 대응하는 z값을 말합니다.\n모집단이 비정규 분포를 해도 표본 크기가 30이 넘으면 중심극한정리에 의해 표집분포는 정규분포와 유사하므로 위의 공식을 사용합니다.\n\n\n\nFigure 9.1: Z값과 신뢰구간\n\n\ni신뢰도가 95%라면\n\n\n모 분산을 모르지만 표본 크기가 클 때\n표본의 크기가 크면 중심극한정리에 따라 평균의 표집분포는 정규분포에 근접합니다.\n\\[  \\bar X \\sim N(\\mu, \\frac{\\sigma^{2}}{n}) \\]\n문제는 모분산을 모르는 것인데 표본 분산을 모 분산으로 대체해서 계산합니다.\n\\[ S^{2} = \\frac{\\sum_{i=1}^{n}(X_i-\\bar X)^{2}}{n-1}  \\]\n따라서 모 분산을 알 때의 공식을, 아래처럼 \\(\\sigma^{2}\\) 을 \\(S^{2}\\) 로 대체하여, 사용할 수 있습니다.\n\\[ P(\\bar X - z_{\\alpha/2}\\frac {S}{\\sqrt {n}} \\leq \\mu \\leq \\bar X + z_{\\alpha/2}\\frac {S}{\\sqrt {n}}) = 1-\\alpha \\]\n\n\n모 분산을 모르고 표본 크기가 작을 때\n이 경우에는 적어도 모집단이 정규분포를 한다는 가정이 필요합니다. 그 가정에서 t 분포를 사용합니다.\n\\[ X \\sim N(\\mu, \\sigma^{2}) \\]\n\\[ T=\\frac{\\bar X-\\mu}{\\frac{S}{\\sqrt{n}}} \\sim T(n-1) \\]\n아래의 공식을 사용하여 계산합니다. z값을 이용하는 것과 공식은 동일하지만 t값을 사용합니다.\n\\[ P(\\bar X - t_{\\alpha/2}\\frac {S}{\\sqrt {n}} \\leq \\mu \\leq \\bar X + t_{\\alpha/2}\\frac {S}{\\sqrt {n}}) = 1-\\alpha \\]\n정리를 하면;\n\n\nTable 9.1: 추정에서 z 분포와 t 분포를 사용할 때\n\n\n\n\n\n\n\n\n\n모집단 정규분포\n\\(\\sigma\\) 안다\n\\(n \\gt 30\\)\n임곗값\n표준오차\n\n\n\n\nyes\nyes\nyes\n\\(z_{\\alpha / 2}\\)\n\\(\\sigma / \\sqrt{n}\\)\n\n\nyes\nyes\nno\n\\(z_{\\alpha / 2}\\)\n\\(\\sigma / \\sqrt{n}\\)\n\n\nyes\nno\nyes\n\\(t_{\\alpha / 2}\\)\n\\(s / \\sqrt{n}\\)\n\n\nyes\nno\nno\n\\(t_{\\alpha / 2}\\)\n\\(s / \\sqrt{n}\\)\n\n\nno\nyes\nyes\n\\(z_{\\alpha / 2}\\)\n\\(\\sigma / \\sqrt{n}\\)\n\n\nno\nyes\nno\n\n안 됨\n\n\nno\nno\nyes\n\\(t_{\\alpha / 2}\\)\n\\(s / \\sqrt{n}\\)\n\n\nno\nno\nno\n\n안 됨\n\n\n\n\n\nExample 9.1  \n\n크기가 40인 표본의 평균이 45이고 표준편차가 8일 때, 신뢰도 95%인 모평균의 신뢰구간은 얼마입니까?\n\n\n풀이: 평균의 표준오차를 구하고 신뢰구간 95%와 자유도 \\((n-1)\\)을 가진 \\(t\\) 값을 구해서 계산한다.\n여기서 \\(n=40, \\; \\bar x=45, \\; s=8\\)일 때, \\(S_{\\bar x} = 8 / \\sqrt{40}\\) = 1.2649111,\n\\(\\alpha = 1- 0.95, \\; t_{\\alpha/2}\\) = 2.0226909\n따라서 모평균의 95% 신뢰구간은 45 - 2.5585241 \\(\\le \\mu \\le\\) 45 + 2.5585241,\n계산하면 답: 42.4414759 \\(\\le \\mu \\le\\) 47.5585241\n# 위의 qmd 파일 원문 (R 인라인 코드+ Quarto)\n\n여기서  $n=40, \\; \\bar x=45, \\; s=8$일 때, $S_{\\bar x} = 8 / \\sqrt{40}$ = `r S=8/sqrt(40)` `r S`, \n\n$\\alpha = 1- 0.95, \\; t_{\\alpha/2}$ = `r t=abs(qt(0.025, 39))` `r t` \n\n따라서 모평균의 95% 신뢰구간은 45-`r t*S` $\\le \\mu \\le$ 45 +`r t*S`, \n\n계산하면 답: `r 45-t*S` $\\le \\mu \\le$ `r 45 + t*S`\n\nExample 9.2  \n\n데이터 iris 의 변수인 Sepal.Length에 대해서 평균의 신뢰도 95%인 신뢰구간을 구하세요.\n\n\n풀이: t.test 함수를 사용해서 t 검정의 결과로 result$conf.int라는 변수를 만들어 답을 구한다.\n\ndata(iris)\nresult &lt;- t.test(iris$Sepal.Length, conf.level = 0.95)\n\n# 평균\nmean &lt;- result$estimate\nmean\n## mean of x \n##  5.843333\n\n# 신뢰구간\nconf_interval &lt;- result$conf.int\nconf_interval\n## [1] 5.709732 5.976934\n## attr(,\"conf.level\")\n## [1] 0.95\n\n또는\n\n# 평균의 신뢰구간 구하기\nresult &lt;- t.test(iris$Sepal.Length, conf.level = 0.95)\n# 결과 출력\nprint(result$conf.int)    # 왼쪽 오른쪽 신뢰구간 동시에 출력\n## [1] 5.709732 5.976934\n## attr(,\"conf.level\")\n## [1] 0.95\nprint(result$conf.int[1])  # 왼쪽 신뢰구간 출력\n## [1] 5.709732\nprint(result$conf.int[2])  # 오른쪽 신뢰구간 출력\n## [1] 5.976934\n\n여기서 왼쪽과 오른쪽 신뢰구간은 result란 데이터셋에 conf.int란 변수에 저장되어 있다.\n따라서\n답: 5.7097325 \\(\\le \\mu \\le\\) 5.9769342\n# 위의 qmd 파일 원문 (R 인라인 코드+ Quarto)\n**답:** `r result$conf.int[1]` $\\le \\mu \\le$ `r result$conf.int[2]`"
  },
  {
    "objectID": "inference-hypothesis.html#평균차이-구간추정-두-모집단",
    "href": "inference-hypothesis.html#평균차이-구간추정-두-모집단",
    "title": "9  추정과 가설 검정",
    "section": "9.5 평균차이 구간추정: 두 모집단",
    "text": "9.5 평균차이 구간추정: 두 모집단\n위의 모집단 평균의 구간 추정과 동일한 근거로 계산합니다.\n\n두 모집단이 독립인 정규분포를 하고 모분산이 알려진 경우\n\\[ P\\Big( \\; (\\bar X-\\bar Y) - z_{\\alpha/2} \\sqrt{\\frac{\\sigma_1^{2}}{n_1}+\\frac{\\sigma_2^{2}}{n_2}} \\leq \\mu_1-\\mu_2 \\leq (\\bar X - \\bar Y) + z_{\\alpha/2} \\sqrt{\\frac{\\sigma_1^{2}}{n_1}+\\frac{\\sigma_2^{2}}{n_2}} \\; \\; \\Big) = 1-\\alpha \\]\n\n\n두 모분산을 모르지만 표본 크기가 클 때\n\\[ P( \\; (\\bar X-\\bar Y) - z_{\\alpha/2} \\sqrt{\\frac{S_1^{2}}{n_1}+\\frac{S_2^{2}}{n_2}} \\leq \\mu_1-\\mu_2 \\leq (\\bar X - \\bar Y) + z_{\\alpha/2} \\sqrt{\\frac{S_1^{2}}{n_1}+\\frac{S_2^{2}}{n_2}} \\; ) = 1-\\alpha   \\]\n\n\n모분산을 모르고 표본 크기도 작을 때\n두 모집단이 독립이고 정규분포라는 가정이 필요하고 더불어 두 모분산이 같다는 가정도 필요합니다.\n두 모분산이 같으므로 두 모집단을 합쳐서 분산을 계산합니다. 이것을 합동추정량 pooled estimator 이라고 합니다. 두 모집단에서 표본 {\\(X_1, X_2, ..., X_n\\)}와 {\\(Y_1, Y_2, ... , Y_n\\)}을 추출해서 합동추정량을 계산하면,\n\\[ S_{p}^{2} = \\frac {\\sum _{i=1}^{n_1}(X_i-\\bar X)^{2}+ \\sum _{i=1}^{n_2}(Y_i-\\bar Y)^{2}}{n_1+n_2 -2} = \\frac {(n_1-1) S_1^{2}+(n_2-1) S_2^{2}}{n_1+n_2 -2} \\]\n합동분산을 계산하는 이유는, 표본 크기가 작으므로 개별 분산을 사용하면 t 분포는 오차의 범위가 커진다는 겁니다. 합동분산을 계산하면 분산에 사용하는 n의 크기가 커지므로 오차의 범위가 줄어듭니다. 분산을 계산할 때 평균을 빼주므로 (예, \\(X_i-\\bar X\\)) 평균이 달라도 문제가 없습니다. 분산이 같다는 가정만 충족하면 됩니다.\n\\[ P\\Big( \\; (\\bar X-\\bar Y) - t_{\\alpha/2} (n_1+n_2-2) S_p \\sqrt{\\frac{1}{n_1}+\\frac{1}{n_2}} \\leq \\mu_1-\\mu_2 \\leq (\\bar X - \\bar Y) + t_{\\alpha/2} (n_1+n_2-2) S_p \\sqrt{\\frac{1}{n_1}+\\frac{1}{n_2}} \\; \\; \\Big)= 1-\\alpha   \\]\n\n\n두 표본이 독립적이 아니며 쌍을 이룰 때\n두 확률표본이 독립적이 아니며 서로 대응을 하는 값일 때 두 모평균 차이에 대한 신뢰구간은 사실상 그 쌍의 차이에 대한 단일 표본의 신뢰구간과 같습니다.\n예를 들면, 영어 점수와 수학 점수 차이에 대한 두 모평균의 차이의 신뢰구간을 구한다고 합니다. 두 점수는 (85, 78) (72, 68) 처럼 한 학생이 두 점수를 가지고 있으므로 쌍을 이룹니다. 그리고 한 과목을 잘 하는 학생이 다른 과목도 잘 하는 경향이 있으므로 두 변수가 독립적이 아닙니다. (85, 78) (72, 68) 는 차이만 보면 7 (85-78), 4 (72-68) 입니다. 그래서 차이라는 단일 변수의 평균의 신뢰구간을 구하면 됩니다.\n\n\n\n영어\n수학\n차이\n\n\n\n\n85\n78\n7\n\n\n72\n68\n4\n\n\n…\n…\n…\n\n\n평균\n평균\n평균\n\n\n75\n71\n6"
  },
  {
    "objectID": "inference-hypothesis.html#가설-검정",
    "href": "inference-hypothesis.html#가설-검정",
    "title": "9  추정과 가설 검정",
    "section": "9.6 가설 검정",
    "text": "9.6 가설 검정\n가설 hypothesis 은 이론이 되기 전의 어떤 주장을 말합니다. 가설이 증명되면, 즉 검정을 통과하면 이론이 됩니다. 예를 들어, “지구는 둥글다”라는 주장이 있은데 예전에는 가설이었습니다. 갈릴레오가 이 가설을 주장해서 큰 곤란을 겪었지요. 그러나 점차 여러 증거들이 발견되고 이제는 우주에서 둥근 지구를 관찰하기까지 하니까 “지구는 둥글다”는 주장이 검정되어 확고한 이론이 되었습니다.\n모집단에 대한 아직 검정되지 않는 주장을 통계적 가설 statistical hypothesis 이라고 합니다. 통계적 가설은 표본조사를 통해서 검정하는데 이 과정에서 표집분포와 확률이론을 사용합니다. 따라서 추론적 통계에 속합니다. 이때 통계적 유의미 여부의 검정 대상이 되는 것을 귀무가설 null hypothesis 이라 하며, 주로 ‘차이가 없다’ 또는 ‘효과가 없다’는 내용의 가설입니다. 귀무가설의 반대 주장이 대립가설입니다. 대립가설 alternative hypothesis 은 그 자체를 검정하지 않고 귀무가설의 검정 결과에 따라 결정됩니다. 대립가설은 귀무가설의 반대이므로 주로 ’차이가 있다’ 또는 ’효과가 있다’는 내용입니다.\n가설 검정의 절차는 아래와 같습니다. 첫째 것이 일반적이지만, 다른 의견들도 있습니다. 여기는 두 개만 예로 듭니다.\n\n첫째\n\n\n귀무가설 \\(H_0\\)와 대립가설 \\(H_A\\)을 설정한다\n유의수준 \\(\\alpha\\) 을 설정한다\n적절한 검정 통계량을 선정하고 임계값을 설정한다\n통계량과 \\(p\\) 값을 계산한다\n결과를 해석하고 결론 짓는다\n\n\n둘째\n\n\n가정을 살펴보고 가설을 설정한다\n검정 통계량을 계산한다\n\\(p\\) 값을 결정한다\n결정을 내린다\n현실에 적절한 결론을 작성한다"
  },
  {
    "objectID": "inference-hypothesis.html#귀무가설과-대립가설",
    "href": "inference-hypothesis.html#귀무가설과-대립가설",
    "title": "9  추정과 가설 검정",
    "section": "9.7 귀무가설과 대립가설",
    "text": "9.7 귀무가설과 대립가설\n앞서 말한 바와 같이, 통계적 유의 검정 statistical significance test 의 직접 대상이 되는 가설이 귀무가설입니다. 귀무가설은 대개 차이가 없다, 효과가 없다 등의 내용을 가집니다. 귀무가설의 예를 들면, ‘남자와 여자의 언어 능력의 차이가 없다’ ‘마스트는 바이러스 감염에 효과가 없다’ ‘수학성적과 영어성적은 상관관계가 없다’ 등이 있습니다. 대립가설은 귀무가설의 반대 주장입니다. 예를 들어, ’마스크는 바이러스 감염 방지에 효과가 없다’라는 귀무가설의 대립가설은 ’마스크는 바이러스 감염 방지에 효과가 있다’입니다. 따라서 귀무가설 검정의 결과에 따라 대립가설의 채택 여부가 결정됩니다. 귀무가설이 기각되면, 대립가설이 선택되고, 귀무가설이 채택되면 대립가설이 선택되지 않습니다.\n사회과학 분야에서 연구자들이 주장하고자 하는 가설은 대개 대립가설입니다. 사회과학자는 통상 과거의 연구를 토대로 ‘차이가있다’ ‘효과가 있다’ ‘연관이 있다’ 등의 가설을 내세웁니다. 예를 들어, ’남자와 여자는 미디어 이용 시간에 차이가 있다’는 가설을 내세운다면 그건 대립가설입니다. 그것에 상응하는 ’남자와 여자는 미디어 이용 사간에 차이가 없다’는 귀무가설을 세우고 귀무가설의 통계적 유의미를 검정합니다.\n통계적 유의수준의 검정에는 두 가지가 있습니다. 양측 검정 two-sided test 과 단측 검정 one-sided test 이 있는데 단측 검정은 다시 우측 검정 right-sided test 과 좌측 검정 left-sided test 으로 나누어집니다. 예를 들어 보죠. ‘모집단 평균이 85’라는 귀무가설이 있다고 할 때, 대립가설은 ’85와 다르다’, ‘85보다 작다’, ‘85보다 크다’, 세 가지가 가능합니다.\n\n\\(H_0\\): \\(\\mu= 85\\), \\(H_A\\): \\(\\mu \\ne 85\\) 양측검정\n\\(H_0\\): \\(\\mu= 85\\), \\(H_A\\): \\(\\mu \\lt 85\\) 좌측검정\n\\(H_0\\): \\(\\mu= 85\\), \\(H_A\\): \\(\\mu \\gt 85\\) 우측검정\n\n귀무가설을 검정하는 수준이 유의 수준 significance level 입니다. 유의 수준에 따라 그에 대응하는 임곗값 critical value 이 결정됩니다. 검정 통계량 test statistics 이 임계값을 넘으면 귀무가설은 기각되고 대립가설이 채택됩니다. 예를 들어, 유의수준 \\(\\alpha=0.05\\) 면 양측검정에서 그에 대응하는 \\(Z\\)의 임곗값은 -1.96과 1.96입니다.\n\n\n\nFigure 9.2: 양측검정\n\n\n\n\n\nFigure 9.3: 단측검정: 좌측검정"
  },
  {
    "objectID": "inference-hypothesis.html#종-오류와-2종-오류",
    "href": "inference-hypothesis.html#종-오류와-2종-오류",
    "title": "9  추정과 가설 검정",
    "section": "9.8 1종 오류와 2종 오류",
    "text": "9.8 1종 오류와 2종 오류\n가설 검정의 결과에 나타나는 오류는 두 가지가 있습니다. 제1종 오류 type I error 는 귀무가설이 참인데 그걸 기각하고 대립가설을 선택하는 것입니다. 이것이 발생할 확률은 유의수준 \\(\\alpha\\) 과 같습니다. 왜냐하면 우리가 검정에 사용하는 분포는 귀무가설이 참이라고 가정할 때의 분포이기 때문입니다. 제2종 오류 type II error 는 귀무가설이 거짓인데 그걸 채택하고 대립가설을 기각하는 것입니다. 이것이 발생할 확률을 \\(\\beta\\) 라고 합니다. \\(\\beta\\) 는 알기 어렵습니다. 귀무가설이 거짓이라는 것을 알아도 참값이 얼마인지 모르므로 (예를 들어, 모 평균이 얼마인지 모르므로) 분포를 특정할 수 없기 때문입니다.\n\n\nTable 9.2: 1종 오류와 2종 오류\n\n\n실제사실\n\\(H_0\\) 채택\n\\(H_A\\) 채택\n\n\n\n\n\\(H_0\\) 참\n\\(1-\\alpha\\)\n\\(\\alpha\\)\n\n\n\\(H_A\\) 참\n\\(\\beta\\)\n\\(1-\\beta\\)\n\n\n\n\n\n\n\nFigure 9.4: 제1종 오류\n\n\n\n\n\nFigure 9.5: 제2종 오류"
  },
  {
    "objectID": "inference-hypothesis.html#모평균-검정-단일-모집단",
    "href": "inference-hypothesis.html#모평균-검정-단일-모집단",
    "title": "9  추정과 가설 검정",
    "section": "9.9 모평균 검정: 단일 모집단",
    "text": "9.9 모평균 검정: 단일 모집단\n\n정규 모집단이고 분산을 알 때\n이미 아는 모집단의 평균이 맞는지 표본조사의 의한 표본 평균을 이용하여 검정합니다. 정규 모집단이므로 표본 평균도 정규 분포를 한다는 가정을 합니다. 표집분포가 정규이므로 검정통계량은 Z값입니다.\n\n\\(H_0\\): \\(\\mu=\\mu_0\\), \\(H_A\\): \\(\\mu \\ne \\mu_0\\),  또는 \\(H_0\\): \\(\\mu \\le \\mu_0\\), \\(H_A\\): \\(\\mu \\gt \\mu_0\\),  또는 \\(H_0\\): \\(\\mu \\ge \\mu_0\\), \\(H_A\\): \\(\\mu \\lt \\mu_0\\)\n유의수준 \\(\\alpha\\)을 결정한다\n표본에서 평균 \\(\\bar x\\)을 계산한다\n평균에 대응하는 검정통계량 \\(z\\)값을 계산한다 \\(z=\\frac{\\bar x-\\mu_0}{\\sigma/\\sqrt{n}}\\)\n임계값과 비교하여 기각과 채택을 결정한다\n\n\n\n모 분산을 모르고 표본의 크기가 클 때\n위와 동일하고, 모분산 대신에 표본 분산을 사용합니다. \\(S^{2}=\\frac{1}{n-1}\\sum(X_i-\\bar X)^{2}\\)\n\n\n모 분산을 모르고 표본의 크기가 작을 때\n모집단이 정규분포를 한다면, 위와 동일한 과정을 거치되 \\(Z\\)값 대신에 \\(T\\)값을 사용합니다. \\(T=\\frac{\\bar x-\\mu_0}{S/\\sqrt{n}}\\) 자유도는 \\(n-1\\) 입니다.\n정리를 하면 (앞에 나왔던 것과 동일)\n\n\n\n\n\n\n\n\n\n\n모집단 정규분포\n\\(\\sigma\\) 안다\n\\(n \\gt 30\\)\n임곗값\n표준오차\n\n\n\n\nyes\nyes\nyes\n\\(z_{\\alpha / 2}\\)\n\\(\\sigma / \\sqrt{n}\\)\n\n\nyes\nyes\nno\n\\(z_{\\alpha / 2}\\)\n\\(\\sigma / \\sqrt{n}\\)\n\n\nyes\nno\nyes\n\\(t_{\\alpha / 2}\\)\n\\(s / \\sqrt{n}\\)\n\n\nyes\nno\nno\n\\(t_{\\alpha / 2}\\)\n\\(s / \\sqrt{n}\\)\n\n\nno\nyes\nyes\n\\(z_{\\alpha / 2}\\)\n\\(\\sigma / \\sqrt{n}\\)\n\n\nno\nyes\nno\n\n안 됨\n\n\nno\nno\nyes\n\\(t_{\\alpha / 2}\\)\n\\(s / \\sqrt{n}\\)\n\n\nno\nno\nno\n\n안 됨\n\n\n\n\nExample 9.3  \n\n한 방송국의 토크쇼가 평균 시청 시간이 42.5분이고 표준편차가 7.07분인 정규분포를 가졌습니다. MC가 바뀌었는데 시청 시간이 바뀌었는지 알아보려고 시청자 50명을 무작위로 뽑아 조사했더니 평균이 39.7분이 나왔습니다.\n\n시청시간이 달라졌을까요? 유의수준 5%로 계산해보세요.\n시청시간이 줄었다고 말할 수 있을까요? 유의수준 5%로 계산해보세요.\n\n\n\n풀이: \n\nmu=42.5\nsigma=7.07\n\nn=50\nxbar=39.7  # 표본평균\n\nalpha=0.05\nse=sigma/sqrt(n) # 표본평균의 표준오차: standard error\n\nz=(xbar-mu)/se  # 표본평균의 z값\ncv.two.l =qnorm(alpha/2)    # 양측검정일 때 왼쪽 임곗값\ncv.two.r =qnorm(1-alpha/2)  # 양측검정일 때 오른쪽 임곗값\n\ncv.left =qnorm(alpha)      # 왼쪽 단측검정일 때 임곗값\n\n# sprintf() 함수가 만드는 문자열을 cat() 함수가 출력합니다. \nstr=sprintf(\"유의수준= %.2f, z값= %.2f, 왼쪽임곗값= %.2f, 오른쪽임곗값= %.2f, 단측왼쪽임곗값=%.2f\", alpha, z, cv.two.l, cv.two.r, cv.left)\ncat(str)\n\n유의수준= 0.05, z값= -2.80, 왼쪽임곗값= -1.96, 오른쪽임곗값= 1.96, 단측왼쪽임곗값=-1.64\n\n\n답: 1) 양측 검정: \\(H_0: \\mu = 42.5, \\; \\; H_A: \\mu \\ne 42.5\\)\n임계값 \\(z_{\\alpha /2}=z_{0.025}=\\pm\\) 1.959964\n표본평균 39.7분에 대한 z값은 -2.8004229이며 왼쪽 임곗값인 -1.959964보다 작으므로 시청시간이 달라졌다고 판단합니다.\n\n왼쪽 단측 검정: \\(H_0: \\mu = 42.5, \\; \\; H_A: \\mu \\lt 42.5\\)\n\n임계값 \\(z_{\\alpha}=z_{0.05}=\\) –1.6448536\n표본평균 39.7분에 대한 z값은 -2.8004229이며 단측 임곗값인 -1.6448536보다 작으므로 시청시간이 적어졌다고 판단합니다.\n1) 양측 검정: $H_0: \\mu = 42.5, \\; \\; H_A: \\mu \\ne 42.5$\n임계값 $z_{\\alpha /2}=z_{0.025}=\\pm$ `r cv.two.r`\n표본평균 39.7분에 대한 z값은 `r z`이며 왼쪽 임곗값인 `r cv.two.l`보다\n\nExample 9.4  \n\niris 데이터셋에서 명목변수인 Species 의 setosa 품종의 Sepal.Length 평균이 평균 5.2를 가진 모집단에서 나온 것인지 검정해보세요. (변수의 대문자 주의!)\n\n\n\n# iris 데이터셋 불러온다\ndata(iris)\n# Species에서 \"setosa\"만 선택해서 new_iris 데이터셋을 만든다\nnew_iris &lt;- subset(iris, Species %in% c(\"setosa\")) \n\nt.test(new_iris$Sepal.Length, mu=5.2)\n\n\n    One Sample t-test\n\ndata:  new_iris$Sepal.Length\nt = -3.8917, df = 49, p-value = 0.0003007\nalternative hypothesis: true mean is not equal to 5.2\n95 percent confidence interval:\n 4.905824 5.106176\nsample estimates:\nmean of x \n    5.006 \n\n\n답: setosa의 Sepal.Length 평균의 t 값은 -3.8917고 확률 \\(p=0.0003\\) 입니다. 따라서 차이가 0이라는 귀무가설을 기각하고 대립가설을 채택합니다."
  },
  {
    "objectID": "inference-hypothesis.html#평균차이-검정-두-모집단",
    "href": "inference-hypothesis.html#평균차이-검정-두-모집단",
    "title": "9  추정과 가설 검정",
    "section": "9.10 평균차이 검정: 두 모집단",
    "text": "9.10 평균차이 검정: 두 모집단\n\n독립적인 정규 모집단이고 분산을 알 때\n두 모집단의 평균이 같은지 표본조사의 의한 표본 평균을 이용하여 검정합니다. 정규 모집단이므로 표본 평균도 정규 분포를 한다는 가정을 합니다. 표집분포가 정규이므로 검정통계량은 Z값입니다.\n\n\\(H_0\\): \\(\\mu_1=\\mu_2\\) 또는 \\(\\mu_1-\\mu_2=0\\),  \\(H_A\\): \\(\\mu_1 \\ne \\mu_2\\) 또는 \\(\\mu_1-\\mu_2 \\ne 0\\) \n유의수준 \\(\\alpha\\)을 결정한다\n표본에서 평균 차이를 \\(\\bar x_1-\\bar x_2\\)을 계산한다\n평균에 대응하는 검정통계량 \\(z\\)값을 계산한다 \\[z=\\frac{(\\bar x_1-\\bar x_2)-(\\mu_1-\\mu_2)}{\\sqrt{\\sigma_1^{2}/n_1+\\sigma_2^{2}/n_2}}\\]\n임계값과 비교하여 기각과 채택을 결정한다\n\n\n\n모 분산을 모르고 표본의 크기가 클 때\n위와 동일하고, 모분산 대신에 표본 분산을 사용합니다.\n\\[S^{2}=\\frac{1}{n-1}\\sum(X_i-\\bar X)^{2}\\]\n\n\n모 분산을 모르고 표본의 크기가 작을 때\n모집단이 정규분포를 한다면, 위와 동일한 과정을 거치되 \\(Z\\)값 대신에 \\(T\\)값을 사용합니다.\n\\[T=\\frac{\\bar X_1-\\bar X_2}{S_p\\sqrt{\\frac{1}{n_1}+\\frac{1}{n_2}}} \\; \\sim t(n_1+n_2-2)\\]\n여기서 \\(S_p\\)는 합동추정량입니다.\n\\[ S_{p}^{2} = \\frac {(n_1-1) S_1^{2}+(n_2-1) S_2^{2}}{n_1+n_2 -2} \\]\n\nExample 9.5  \n\n국민대학교 1학년과 2학년의 성적 평균에 차이가 있는지 검정하려고 합니다. 둘다 표본 크기는 40명씩입니다. 1학년 평균은 3.40이고 표준편차는 0.2, 2학년 평균은 3.55이고 표준편차는 0.22로 결과가 나왔습니다. 유의수준 10%에서 1학년과 2학년의 평균 차이가 있을까요?\n\n\n풀이\n\n# {r collapse: TRUE} 이런 옵션을 쓰면 붙어서 나옵니다. \nm_1&lt;-3.40   # 1학년\nsd_1 &lt;-0.2\nn_1&lt;-40\nm_2&lt;-3.55   # 2학년\nsd_2&lt;-0.22\nn_2&lt;-40\n\nm_diff&lt;-m_1-m_2   # 평균 차이\nse &lt;- sqrt(sd_1^2/40+sd_2^2/40)   # 평균 차이의 표준오차\n\nz=(m_diff-0)/se  #평균차이의 z값, (평균차이의 평균= 0 :귀무가설)\n\nalpha=0.10\n\ncv.two.l =qnorm(alpha/2)    # 양측검정일 때 왼쪽 임곗값\ncv.two.r =qnorm(1-alpha/2)  # 양측검정일 때 오른쪽 임곗값\n\n# sprintf() 함수가 만드는 문자열을 cat() 함수가 출력합니다. \nstr=sprintf(\"유의수준= %.2f, z값= %.2f, 왼쪽임곗값= %.2f, 오른쪽임곗값= %.2f\", alpha, z, cv.two.l, cv.two.r)\ncat(str)\n## 유의수준= 0.10, z값= -3.19, 왼쪽임곗값= -1.64, 오른쪽임곗값= 1.64\n\n\n\\(H_0\\): \\(\\mu_1=\\mu_2\\) 또는 \\(\\mu_1-\\mu_2=0\\),  \\(H_A\\): \\(\\mu_1 \\ne \\mu_2\\) 또는 \\(\\mu_1-\\mu_2 \\ne 0\\)\n유의수준 \\(\\alpha=0.1\\)\n표본평균 차이= -0.15\n평균 차이에 대응하는 검정통계량 \\(z\\)값 = -3.1907672\n양측검정: 임계값과 비교하여 기각과 채택을 결정; 임곗값 \\(\\pm\\) 1.6448536\n\n답: 표본평균 차이의 z값 -3.19가 임곗값보다 적으므로 남녀 차이가 있다고 검정한다.\n\n앞 5 장의 t 검정 실시하기 부분을 잠깐 다시보면 도움이 될 거예요.\n\n\nExample 9.6  \n\niris 데이터셋에서 명목변수인 Species 의 setosa 품종과 versicolor 품중 간에 Sepal.Length에 대한 평균 차이가 있는지 검정해 보세요. (변수의 대문자 주의!)\n\n\n\n# iris 데이터셋 불러온다\ndata(iris)\n# Species에서 \"setosa\"와 \"versicolor\"만 선택해서 new_iris 데이터셋을 만든다\nnew_iris &lt;- subset(iris, Species %in% c(\"setosa\", \"versicolor\")) \n\nt.test(new_iris$Sepal.Length ~ new_iris$Species)\n\n\n    Welch Two Sample t-test\n\ndata:  new_iris$Sepal.Length by new_iris$Species\nt = -10.521, df = 86.538, p-value &lt; 2.2e-16\nalternative hypothesis: true difference in means between group setosa and group versicolor is not equal to 0\n95 percent confidence interval:\n -1.1057074 -0.7542926\nsample estimates:\n    mean in group setosa mean in group versicolor \n                   5.006                    5.936 \n\n\n답: setosa와 versicolor의 Sepal.Length 평균차이인 (5.006-5.936)의 t 값은 -10.521이고 확률 \\(p \\lt 0.001\\) 입니다. 따라서 차이가 0이라는 귀무가설을 기각하고 대립가설을 채택합니다."
  },
  {
    "objectID": "inference-hypothesis.html#평균차이-검정-쌍일-때",
    "href": "inference-hypothesis.html#평균차이-검정-쌍일-때",
    "title": "9  추정과 가설 검정",
    "section": "9.11 평균차이 검정: 쌍일 때",
    "text": "9.11 평균차이 검정: 쌍일 때\n쌍을 이룬 두 모평균 차이의 검정은 사실 쌍의 차이의 평균이 0인가를 검정하는 것과 같습니다. 따라서 두 모집단이 아니라 한 모집단에 대한 검정입니다. 따라서 절차는 단일 모집단에 대한 검정을 따릅니다.\n\\(H_0\\): \\(\\mu_1=\\mu_2\\) 또는 \\(\\mu_1-\\mu_2=0\\), \\(H_A\\): \\(\\mu_1 \\ne \\mu_2\\) 또는 \\(\\mu_1-\\mu_2 \\ne 0\\)\n각 쌍의 차이를 {\\(D_1, D_2, ... , D_n\\)}이라고 하고 그것이 분산이 \\(\\sigma^{2}\\) 인 정규 모집단에서 추출한 확률 표본이라고 합니다.\n\\[\\bar D = \\frac{\\sum_{i=1}^{n} D_i}{n}\\]\n\\[S_D^{2}=\\frac{\\sum_{i=1}^{n} (D_i-\\bar D)^{2}}{n-1}\\]\n귀무가설이 사실이라면 차이의 평균은 0이므로\n\\[T=\\frac{\\bar D}{S_D/\\sqrt{n}} \\; \\sim t(n-1)\\]\n\n모 분산을 모르고 표본의 크기가 클 때\n위와 동일하고, 모분산 대신에 표본 분산을 사용합니다. \\(S^{2}=\\frac{1}{n-1}\\sum(X_i-\\bar X)^{2}\\)"
  },
  {
    "objectID": "inference-hypothesis.html#모-분산-검정-단일-모집단",
    "href": "inference-hypothesis.html#모-분산-검정-단일-모집단",
    "title": "9  추정과 가설 검정",
    "section": "9.12 모 분산 검정: 단일 모집단",
    "text": "9.12 모 분산 검정: 단일 모집단\n\\(H_0\\)가 제시한 모 분산에 대해서 표본 분산을 이용하여 검정을 하는 방법입니다. 모 분산에 대한 검정통계량은 \\(\\chi^{2}\\) 며, 계산하는 법은 아래와 같습니다. 비율을 이용해서 양측검정과 단측검정을 모두 할 수 있습니다.\n\\[\\chi^{2}= \\frac{(n-1)S^{2}}{\\sigma_0^{2}} \\sim \\chi_{n-1}^{2}\\]\n\n\\(H_0\\): \\(\\sigma^{2}=\\sigma^{2}_0\\),  \\(H_A\\): \\(\\sigma^{2} \\ne \\sigma^{2}_0\\)\n유의수준 \\(\\alpha\\)을 결정한다\n표본에서 카이제곱 \\(\\chi^{2}\\)을 계산한다. 자유도는 \\(n-1\\).\n임계값과 비교하여 기각과 채택을 결정한다\n\n\n\n\nFigure 9.6: 분산의 가설검정: 단일 모집단"
  },
  {
    "objectID": "inference-hypothesis.html#모-분산의-검정-두-모집단",
    "href": "inference-hypothesis.html#모-분산의-검정-두-모집단",
    "title": "9  추정과 가설 검정",
    "section": "9.13 모 분산의 검정: 두 모집단",
    "text": "9.13 모 분산의 검정: 두 모집단\n두 모집단 분산의 차이는 비율로 검정합니다. 확률변수인 두 분산의 비율은 F 분포를 따르므로 F 값을 검정통계량으로 사용합니다. \\(H_0\\)의 가정인 \\(\\sigma_1^{2}=\\sigma_2^{2}\\) 를 적용하면 아래 공식이 도출됩니다. 그것를 이용해서 검정통계량을 계산합니다. 비율을 이용해서 양측검정과 단측검정을 모두 할 수 있습니다.\n두 모집단 분산의 차이에 대한 검정통계량\n\\[ F=\\frac{S_1^{2}}{S_2^{2}} \\sim F(n_1-1, n_2-1) \\]\n\n가설 검정의 절차\n\n\\(H_0\\): \\(\\sigma^{2}=\\sigma^{2}_0\\),  \\(H_A\\): \\(\\sigma^{2} \\ne \\sigma^{2}_0\\)\n유의수준 \\(\\alpha\\)을 결정한다\n표본에서 F값을 계산한다. 자유도는 \\((n_1-1,\\;n_2-1)\\)\n임계값과 비교하여 기각과 채택을 결정한다\n\n\n\n\nFigure 9.7: 분산의 가설검정: 두 모집단"
  },
  {
    "objectID": "categorical-analysis.html#적합도-검정",
    "href": "categorical-analysis.html#적합도-검정",
    "title": "10  범주형 자료분석",
    "section": "10.1 적합도 검정",
    "text": "10.1 적합도 검정\n적합도 검정 goodness-of-fit test 은 실험 또는 관찰에 의한 표본의 관측빈도 observed frequency 와 이론이나 가정에 의한 (또는 모집단에 의한) 기대빈도 expected frequency 를 비교해서 검정하는 방법입니다. 관측빈도와 기대빈도는 각각 관측도수, 기대도수로 표기하기도 하는데 빈도와 도수는 모두 영어 frequency를 번역한 것으로 실제로 혼용하고 있습니다.\n\n10.1.1 단순 적합도 검정\n검정 통계량은 아래처럼 계산합니다. \\(k\\)는 범주의 수, \\(O_i\\)와 \\(E_i\\)는 각각 \\(i\\)번째 범주에 해당하는 관찰빈도와 기대빈도를 의미합니다. 관찰빈도와 기대빈도가 같다면 검정통계량은 0에 수렴합니다. 다르다면 검정 통계량이 점점 커지겠지요. 따라서 언제나 우측 검정이 됩니다.\n\\[\\chi^2=\\sum_{i=1}^k \\frac{(O_i - E_i)^2}{E_i}\\]\n\n가설을 설정한다.\n\n\n\\(H_0:\\) 표본분포는 모집단 또는 이론/가정의 분포와 같다.\n\n\\(H_A:\\) 표본분포는 모집단 또는 이론/가정의 분포와 다르다.\n\\(H_0: E_i=O_i\\)\n\n\\(H_A:\\) 모든 \\(E_i\\)가 \\(O_i\\)는 아니다\n\n\n유의수준을 결정한다.\n관찰빈도와 기대빈도를 이용해 검정통계량을 계산한다.\n검정 통계량과 임계값을 비교하여 결정한다. 또는 검정통계량의 \\(p\\) 값을 구하여 유의수준과 비교한다. 적합도 검정은 오른쪽 단측검정이다.\n\n\n\nCode\n올해 &lt;- c(56, 65, 60, 65)  #올해 입학생\n올해합 &lt;- sum(올해)\n\n작년 &lt;- c(60, 65, 56, 58)  #작년 입학생\n작년합 &lt;- sum(작년)\n\n작년비 &lt;- prop.table(작년)  #작년의 비율 (모집단/이론의 비율)\n기대빈 &lt;- 작년비*올해합 #기대빈도를 산출\n기대빈합 &lt;- sum(기대빈)\n\n제곱 &lt;-(올해-기대빈)^2/기대빈\n제곱합 &lt;-sum(제곱)\n\n작년비 &lt;- round(작년비, 2)  #표에 보기좋게 반올림\n기대빈 &lt;- round(기대빈, 2)\n제곱 &lt;- round(제곱, 4)\n\n\n예를 들어 보죠. 국토순례에 참가한 학생들의 학년별 분포가 작년과 올해가 달라졌는지 알아보는 겁니다. 범주변수는 학년이고 모두 4개 범주가 있습니다. 모수를 추정하는 건 없습니다. 따라서 자유도는 3입니다. 유의수준은 0.05로 한다면 그에 따른 임계값은 7.8147279입니다.\n\n\n\n학년\n올해참가 \\(O_i\\)\n작년참가 (비율)\n기대빈도 \\(E_i\\)\n\\((O_i-E_i)^2/E_i\\)\n\n\n\n\n1학년\n56\n60 (0.25)\n61.76\n0.5367\n\n\n2학년\n65\n65 (0.27)\n66.9\n0.0542\n\n\n3학년\n60\n56 (0.23)\n57.64\n0.0966\n\n\n4학년\n65\n58 (0.24)\n59.7\n0.4708\n\n\n합계\n246\n239 (1)\n246\n1.1582636\n\n\n\n\n검정통계량: \\(\\chi^2\\)= 1.1582636, 자유도=3 (=\\(k-1\\)), \\(p\\)=0.763 \\(\\gt\\) 0.05\n유의수준: 0.05\n임계값: \\(\\chi^2_{0.95,3}\\)= 7.8147279\n\n적합성 검정은 아래 그림처럼 \\(\\chi^2\\) 오른쪽 단측검정입니다.\n\n\n\nFigure 10.1: 적합성 검정\n\n\n\n\n올해 학년별 참가자가 작년과 다른지 유의수준 5% 수준으로 검정해보세요\n\n\n\n\n학년\n올해참가 \\(O_i\\)\n작년참가 (비율)\n기대빈도 \\(E_i\\)\n\\((O_i-E_i)^2/E_i\\)\n\n\n\n\n1학년\n56\n60 ( )\n\n\n\n\n2학년\n65\n65 ( )\n\n\n\n\n3학년\n60\n56 ( )\n\n\n\n\n4학년\n65\n58 ( )\n\n\n\n\n합계\n\n(1)\n\n\n\n\n\n\n답: 답은 위에 있어요. 아래를 참고하세요.\n\n올해 &lt;- c(56, 65, 60, 65)  #올해 입학생\n올해합 &lt;- sum(올해)\n\n작년 &lt;- c(60, 65, 56, 58)  #작년 입학생\n작년합 &lt;- sum(작년)\n\n작년비 &lt;- prop.table(작년)  #작년의 비율 (모집단/이론의 비율)\n기대빈 &lt;- 작년비*올해합 #기대빈도를 산출\n기대빈합 &lt;- sum(기대빈)\n\n제곱 &lt;-(올해-기대빈)^2/기대빈\n제곱합 &lt;-sum(제곱)\n\n작년비 &lt;- round(작년비, 2)  #표에 보기좋게 반올림\n기대빈 &lt;- round(기대빈, 2)\n제곱 &lt;- round(제곱, 4)\n| 학년|올해참가 $O_i$|       작년참가 (비율)     |기대빈도 $E_i$|$(O_i-E_i)^2/E_i$|\n|:---:|:------------:|:-------------------------:|:------------:|:---------------:|\n|1학년| `r 올해[1]`  |`r 작년[1]` (`r 작년비[1]`)|`r 기대빈[1]` |`r 제곱[1]`      |\n|2학년| `r 올해[2]`  |`r 작년[2]` (`r 작년비[2]`)|`r 기대빈[2]` |`r 제곱[2]`      |\n|3학년| `r 올해[3]`  |`r 작년[3]` (`r 작년비[3]`)|`r 기대빈[3]` |`r 제곱[3]`      |\n|4학년| `r 올해[4]`  |`r 작년[4]` (`r 작년비[4]`)|`r 기대빈[4]` |`r 제곱[4]`      |\n|합계 | `r 올해합`   |`r 작년합` (1)             |`r 기대빈합`  |`r 제곱합`       |\n\n- 검정통계량: $\\chi^2$= `r 제곱합`, 자유도=3 (=$k-1$), $p$=`r 1-round(pchisq(제곱합,3), 3)`\n- 유의수준: 0.05\n- 임계값: $\\chi^2_{0.95,3}$= `r qchisq(0.95,3)`\n\n\n위의 표를 가지고 R 함수를 사용해서 올해 참가자의 학년별 비율이 작년과 다른지 검정해보세요.\n\n\n답\n\n올해 &lt;- c(56, 65, 60, 65)\n작년 &lt;- c(60, 65, 56, 58)\n작년비율 &lt;- 작년/sum(작년)\n\nresult &lt;- chisq.test(올해, p = 작년비율)\nprint(result)\n\n\n    Chi-squared test for given probabilities\n\ndata:  올해\nX-squared = 1.1583, df = 3, p-value = 0.763\n\n\n\\(\\chi^2\\)값이 1.1582636이고 \\(p\\)값 0.7630308이 0.05보다 크므로 귀무가설을 채택한다. 따라서 작년과 올해의 학년별 참가 비율은 다르지 않다.\n$\\chi^2$값이 `r result[1])`이고 $p$값 `r result[3])`이 0.05보다 크므로 귀무가설을 채택한다.\n위처럼 통계함수의 결과를 변수로 넣으면 데이터 형이 리스트가 됩니다. 리스트에서 요소를 추출하는 방법은 Section 5.3 를 보세요.\n\n\n10.1.2 정규 분포에 대한 적합도 검정\n정규 분포에 대한 적합도 검정은 정규 분포뿐만 아니라 포아송 분포 등의 다른 이론적 분포에도 사용할 수 있습니다. 관찰 빈도를 보고 그 비율에 따라서 정규 분포의 확률을 계산하여 기대빈도로 사용하여 앞과 동일하게 계산합니다.\n자유도는 \\(k-m-1\\)인데 \\(k\\)는 범주의 수이므로 \\(k=6\\)이 되고 모집단의 분포를 알려면 모수의 평균과 분산 두 개를 추정해야 하므로 \\(m=2\\) 가 됩니다. 따라서 자유도는 3 입니다.\n\n\n\n점수\n관찰빈도\\(O_i\\)\nz값\n확률\n기대빈도\\(E_i\\)\n\\((O_i-E_i)^2/E_i\\)\n\n\n\n\n0-15\n5\n-2.34~-1.61\n0.0443\n4.21\n0.15\n\n\n15-30\n16\n-1.61~-0.87\n0.1375\n13.07\n0.66\n\n\n30-45\n22\n-0.87~-0.14\n0.2542\n24.15\n0.19\n\n\n45-60\n25\n-0.14~0.6\n0.2799\n26.59\n0.09\n\n\n60-75\n18\n0.6~1.34\n0.1836\n17.44\n0.02\n\n\n75-90\n9\n1.34~2.07\n0.0717\n6.82\n0.7\n\n\n합계\n95\n\n1\n\n1.8106467\n\n\n\n\n검정통계량: \\(\\chi^2\\)= 1.8106467, 자유도=3 (=\\(k-m-1\\)), \\(p\\)=0.387\n유의수준: 0.01\n임계값: \\(\\chi^2_{0.99,3}\\)= 11.3448667\n\n위에서 확률과 기대빈도를 구하는 절차는 아래와 같습니다.\n\n계급구간의 중간값과 관찰빈도를 이용해서 평균과 표준편차를 계산한다\n평균과 표준편차를 이용해서 계급구간의 z값을 계산한다\nz값을 이용해서 정규분포의 구간확률을 계산한다.\n확률에 관찰빈도의 합을 곱해서 기대도수를 계산한다\n\n# 위의 표를 그린다 \n관찰 &lt;- c(5, 16, 22, 25, 18, 9)  #관찰 빈도\n계급 &lt;- c(8, 23, 38, 53, 68, 83) #계급구간의 중간값\n\n평균 &lt;- sum(계급*관찰)/sum(관찰)  #평균-표본\n표편 &lt;- sqrt(sum((계급-평균)^2*관찰)/(sum(관찰)-1)) #표준편차-표본\n\n# 계급구간의 z 값 계산\n구간값 &lt;- c(0, 15, 30, 45, 60, 75, 90)\nz값 &lt;- (구간값-평균)/표편\n확률 &lt;- pnorm(z값, mean=0, sd=1)\n확률2 &lt;- c(1:6)\n\n# 구간확률계산;  for 함수를 사용\n# for (i in a:b) {code} a에서 b까지 i값이 차례로 변하며 code 실행\nfor (i in 2:length(구간값)) { 확률2[i-1] &lt;- 확률[i]-확률[i-1] }\n\n기대빈 &lt;- 확률2*sum(관찰) #기대빈도를 산출\n기대빈합 &lt;- sum(기대빈)\n제곱 &lt;-(관찰-기대빈)^2/기대빈\n제곱합 &lt;- sum(제곱)\n\nz값 &lt;- round(z값, 2)   # 반올림 소수점 2자리\n확률2 &lt;- round(확률2, 4)   # 반올림 소수점 4자리\n기대빈 &lt;- round(기대빈, 2)\n제곱 &lt;- round(제곱, 2)\n|점수|관찰빈도$O_i$|z값|확률|기대빈도$E_i$|$(O_i-E_i)^2/E_i$|\n|:---:|:---:|:---:|:---:|:---:|:---:|\n|0-15 |5 |`r z값[1]`~`r z값[2]`|`r 확률2[1]`|`r 기대빈[1]`|`r 제곱[1]`|\n|15-30|16|`r z값[2]`~`r z값[3]`|`r 확률2[2]`|`r 기대빈[2]`|`r 제곱[2]`|\n|30-45|22|`r z값[3]`~`r z값[4]`|`r 확률2[3]`|`r 기대빈[3]`|`r 제곱[3]`|\n|45-60|25|`r z값[4]`~`r z값[5]`|`r 확률2[4]`|`r 기대빈[4]`|`r 제곱[4]`|\n|60-75|18|`r z값[5]`~`r z값[6]`|`r 확률2[5]`|`r 기대빈[5]`|`r 제곱[5]`|\n|75-90|9 |`r z값[6]`~`r z값[7]`|`r 확률2[6]`|`r 기대빈[6]`|`r 제곱[6]`|\n|합계| `r sum(관찰)`    |   |1 |  | `r 제곱합`|\n\n- 검정통계량: $\\chi^2$= `r 제곱합`, 자유도=3 (=$k-m-1$), $p$=`r round(pchisq(제곱합,3), 3)`\n- 유의수준: 0.01\n- 임계값: $\\chi^2_{0.99,3}$= `r qchisq(0.99,3)`\n\n\niris데이터셋의 ’Sepal.Length` 변수가 정규분포를 하는지 검정하세요.\n\n\n풀이: 정규분포 검정은 Shapiro test를 사용합니다. 귀무가설이 모집단이 정규분포를 한다는 것이므로 확률이 \\(\\alpha=\\) 0.05 이하가 나오면 대립가설을 채택합니다.\n\n# 정규성 검정\nresult &lt;- shapiro.test(iris$Sepal.Length)\nprint(result)\n\n\n    Shapiro-Wilk normality test\n\ndata:  iris$Sepal.Length\nW = 0.97609, p-value = 0.01018\n\n\n답: \\(p=0.010 \\; \\lt \\; 0.05\\). 따라서 대립가설을 채택하므로 정규분포를 하지 않는다고 결론을 내립니다."
  },
  {
    "objectID": "categorical-analysis.html#독립성-검정",
    "href": "categorical-analysis.html#독립성-검정",
    "title": "10  범주형 자료분석",
    "section": "10.2 독립성 검정",
    "text": "10.2 독립성 검정\n독립성 검정 independence test 은 모집단에서 추출한 표본이 가진 두 가지 속성이 서로 관련이 있는가 아니면 독립적인가 검정하는 것입니다. 범주 변수 두 개가 열과 행으로 분할표 contingency table 를 이루고 각 셀에는 빈도가 나타납니다. 아래에서 \\(O_{ij}\\) 는 해당 셀의 관찰빈도입니다. \\(c\\)는 열의 수, \\(r\\)은 행의 수.\n\n\n\n\n\\(B_1\\)\n\\(B_2\\)\n\\(...\\)\n\\(B_c\\)\n부분합\n\n\n\n\n\\(A_1\\)\n\\(O_{11}\\)\n\\(O_{12}\\)\n\\(\\cdots\\)\n\\(O_{1c}\\)\n\\(O_{1 \\cdot}\\)\n\n\n\\(A_2\\)\n\\(O_{21}\\)\n\\(O_{22}\\)\n\\(\\cdots\\)\n\\(O_{2c}\\)\n\\(O_{2 \\cdot}\\)\n\n\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\\(O_{ij}\\)\n\\(\\cdots\\)\n\\(\\cdots\\)\n\n\n\\(A_r\\)\n\\(O_{r1}\\)\n\\(O_{r2}\\)\n\\(\\cdots\\)\n\\(O_{rc}\\)\n\\(O_{r \\cdot}\\)\n\n\n부분합\n\\(O_{\\cdot 1}\\)\n\\(O_{\\cdot 2}\\)\n\\(\\cdots\\)\n\\(O_{\\cdot c}\\)\n\\(n\\) (총합)\n\n\n\n검정 통계량은 아래처럼 계산합니다. \\(r\\)은 행의 (범주) 수, \\(c\\)는 열의 (범주) 수, \\(O_ij\\)와 \\(E_ij\\)는 각각 \\(i\\)번째 행의 \\(j\\)번째 열에 해당하는 관찰빈도와 기대빈도를 의미합니다. 관찰빈도와 기대빈도가 같다면 검정통계량은 0에 수렴합니다. 다르다면 검정 통계량이 점점 커지겠지요. 따라서 언제나 우측 검정이 됩니다.\n\\[\\chi^2=\\sum_{i=1}^{r} \\sum_{j=1}^{c} \\frac{(O_{ij} - E_{ij})^2}{E_{ij}}\\]\n위의 공식은 좀 복잡해보이지만, 간단히 말하면, “모든 셀에 대해서 해당 값을 구하고 그걸 모두 더한 총합을 계산하라”는 말입니다.\n\n가설을 설정한다.\n\n\n\\(H_0:\\) 행과 열의 두 분포는 독립적인다 (두 변수는 독립적이다)\n\\(H_A:\\) 행과 열의 두 분포는 종속적이다 (두 변수는 종속적이다)\n\\(H_0: E_{ij}=O_{ij}\\)\n\n\\(H_A:\\) \\(H_0\\)가 아니다\n\n\n유의수준을 결정한다.\n관찰빈도와 기대빈도를 이용해 검정통계량을 계산한다.\n검정 통계량과 임계값을 비교하여 결정한다. 또는 검정통계량의 \\(p\\) 값을 구하여 유의수준과 비교한다. 독립성 검정도 오른쪽 단측 검정입니다.\n\n기대빈도를 구하는 절차는 아래와 같습니다.\n1.각 셀의 확률(상대 기대빈도)을 구한다 \\[ p_{ij}=p_{i \\cdot} \\times p_{\\cdot j}\\]\n\n\\(p_{i \\cdot}\\)는 관찰빈도 총합에 대한 \\(i\\) 행의 관찰빈도 부분합의 비율\n\\(p_{\\cdot j}\\)는 관찰빈도 총합에 대한 \\(j\\) 열의 관찰빈도 부분합의 비율\n\n\n구한 확률에 관찰빈도의 합을 곱한다\n\n아래 표에서 왼쪽은 관찰빈도이고 오른쪽은 그에 대응하여 계산한 기대빈도입니다.\n\n\n\n\n남자\n여자\n부분합\n비율\n\n\n남자\n여자\n부분합\n비율\n\n\n\n\n이과\n7\n3\n10\n0.5\n\n이과\n5\n5\n10\n0.5\n\n\n문과\n3\n7\n10\n0.5\n\n문과\n5\n5\n10\n0.5\n\n\n부분합\n10\n10\n20\n\n\n부분합\n10\n10\n20\n\n\n\n비율\n0.5\n0.5\n\n1.0\n\n비율\n0.5\n0.5\n\n1.0\n\n\n\n\n\n아래 표의 기대빈도를 채우고 \\(\\chi^2\\)과 확률 \\(p\\)를 구하세요.\n\n\n\n\n\n\n남자\n여자\n부분합\n비율\n\n\n남자\n여자\n부분합\n비율\n\n\n\n\n이과\n10\n5\n15\n0.6\n\n이과\n\n\n\n\n\n\n문과\n5\n5\n10\n0.4\n\n문과\n\n\n\n\n\n\n부분합\n15\n10\n25\n\n\n부분합\n\n\n\n\n\n\n비율\n0.6\n0.4\n\n1.0\n\n비율\n\n\n\n\n\n\n\n아래는 문제를 풀 때 테이블을 쉽게 만들게 하려고 R 마크다운 본문을 넣은 것입니다. 커서를 올리고 카피단추를 클릭해서 붙이기 해서 사용하세요.\n|      |남자  |여자  |부분합|비율 |     |     |남자 |여자|부분합|비율|\n|:----:|:----:|:----:|:----:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|\n|이과  |10    | 5    |15    |0.6  |     |이과 |     |     |     |    |\n|문과  | 5    | 5    |10    |0.4  |     |문과 |     |     |     |    | \n|부분합|15    |10    |25    |     |     |부분합|    |     |     |    |\n|비율  |0.6   |0.4   |      |1.0  |     |비율 |     |     |     |    |\n\n\n위의 관찰빈도를 R을 사용해서 테이블로 만들어서 넣고 카이제곱 검정을 해보세요.\n\n\n\n# 데이터 생성\nsex &lt;- rep(c(\"남자\", \"여자\"), times = c(15, 10))\nmajor &lt;- rep(c(\"이과\", \"문과\", \"이과\", \"문과\"), times = c(10, 5, 5, 5))\n\ncross_tab &lt;- table(sex, major)  # 교차빈도표를 만든다\nresult &lt;- chisq.test(cross_tab)  # 카이제곱 독립성 검정 수행\nprint(result)\n## \n##  Pearson's Chi-squared test with Yates' continuity correction\n## \n## data:  cross_tab\n## X-squared = 0.17361, df = 1, p-value = 0.6769\n\n# 또는 테이블을 직접 만든다\ncross_tab &lt;- matrix(c(10, 5, 5, 5), nrow = 2, byrow = TRUE)\n답: \\(\\chi^2=\\) 0.1736111, \\(p=\\) 0.6769222 \\(\\gt 0.05\\) 따라서 귀무가설을 채택한다. (p-value = 0.6769, 이 값이 오른쪽부터 시작하는 누적확률이라는 걸 주의하세요.)\n  $\\chi^2=$ `r result[1]`,  $p=$ `r result[3]` $\\gt 0.05$\n\n일반 데이터셋을 이용하여 교차빈도표를 만들 때 @ref(ch-bas) 장의 범주형 자료 부분을 참고해 보세요. (여기 클릭)"
  },
  {
    "objectID": "variance-analysis.html#일원분산분석",
    "href": "variance-analysis.html#일원분산분석",
    "title": "11  분산분석",
    "section": "11.1 일원분산분석",
    "text": "11.1 일원분산분석\n일원분산분석은 집단을 나누는 요인인 독립변수 하나와 비교할 평균을 이루는 종속변수 하나를 갖습니다. 예를 들어, 독립변수가 “전공분야”라고 하고 전공분야는 “미디어” “광고” “저널리즘” 이렇게 세 집단으로 나뉜다고 합시다. 종속변수는 “통계학 점수”로 한다면, 세 집단의 평균이 차이가 있는지 검정하는 것입니다. 총변동, 그룹간 변동, 그룹내 변동, 이 세 가지를 계산하고 비교해서 검정을 합니다."
  },
  {
    "objectID": "variance-analysis.html#변동",
    "href": "variance-analysis.html#변동",
    "title": "11  분산분석",
    "section": "11.2 변동",
    "text": "11.2 변동\n총변동 SST; sum of squares total 은 표본 전체의 평균과 각 관찰값의 차이의 제곱합을 말합니다. 독립변수를 고려하지 않았을 때의 변동입니다.\n\\[  SST=\\sum_{i=1}^{k}\\sum_{j=1}^{n_i}(X_{ij}-\\bar X_{\\cdot \\cdot})^2  \\]\n여기에서 \\(k\\)는 독립변수 안의 집단의 수, \\(n_i\\)은 각 집단의 관찰값의 수, \\(X_{ij}\\) 는 \\(i\\)번째 집단의 \\(j\\)번째 관찰값, \\(\\bar X_{\\cdot \\cdot}\\)는 표본 전체의 평균.\n그룹간 변동 SSB; sum of squares between groups 은 각 집단의 평균과 전체 평균의 차이의 제곱을 그 집단의 관찰값 수만큼 각각 곱해서 다 합한 것을 말합니다. 독립변수를 도입해서 설명되는 부분입니다.\n\\[ SSB=\\sum_{i=1}^{k}n_i(\\bar X_{i \\cdot}-\\bar X_{\\cdot \\cdot})^2  \\]\n여기에서 \\(k\\)는 독립변수 안의 집단의 수, \\(n_i\\)은 각 집단의 관찰값의 수, \\(X_{i \\cdot}\\) 는 \\(i\\)번째 집단의 평균, \\(\\bar X_{\\cdot \\cdot}\\)는 표본 전체의 평균. 전체 평균과 집단 평균의 차이는 집단의 속성으로 설명되는 부분이므로 그룹간변동은 독립변수가 설명하는 변동입니다.\n그룹내 변동 SSW; sum of squares within groups 은 각 집단의 평균과 그 집단내 관찰값의 차이의 제곱합을 말합니다. 독립변수가 도입되어도 여전히 설명되지 않는 변동입니다.\n\\[ SSW(SSE)=\\sum_{i=1}^{k}\\sum_{j=1}^{n_i}(X_{ij}-\\bar X_{i \\cdot})^2  \\]\n여기에서 \\(k\\)는 독립변수 안의 집단의 수, \\(n_i\\)은 각 집단의 관찰값의 수, \\(X_{ij}\\) 는 \\(i\\)번째 집단의 \\(j\\)번째 관찰값, \\(\\bar X_{i \\cdot}\\)는 \\(i\\)번째 집단의 평균. 집단내의 평균과 관찰값의 차이는 집단의 속성이 설명하지 못하는 부분이라서 오차와 같으므로 SSE로 적기도 합니다.\n\n세 변동의 관계\n총변동의 수식을 풀어서 정리하면 그룹간변동과 그룹내변동의 합과 같습니다. 따라서\n\\[SST= SSB + SSW\\]\n이것은 회귀분석의 \\(SST= SSR + SSE\\)와 유사합니다.\n\n\n\nFigure 11.1: 총변동, 집단간 변동, 집단내 변동\n\n\n\n\n분산분석표\n분산분석을 정리한 표를 분산분석표라고 합니다. 한눈에 분석 결과를 보기에 편합니다.\n\n\n\n\n\n\n\n\n\n\n\n변동의 원천\n변동\n자유도\nmean squared\n\\(F\\)\n\\(p\\)\n\n\n\n\n그룹간\n\\(SSB\\)\n\\(k-1\\)\n\\(MSB= \\frac{SSB}{k-1}\\)\n\\(\\frac{MSB}{MSW}\\)\n\n\n\n그룹내\n\\(SSW\\)\n\\(n-k\\)\n\\(MSW=\\frac{SSW}{n-k}\\)\n\n\n\n\n총합\n\\(SST\\)\n\\(n-1\\)"
  },
  {
    "objectID": "variance-analysis.html#평균-차이에-대한-가설-검정",
    "href": "variance-analysis.html#평균-차이에-대한-가설-검정",
    "title": "11  분산분석",
    "section": "11.3 평균 차이에 대한 가설 검정",
    "text": "11.3 평균 차이에 대한 가설 검정\n집단간 평균 차이에 대한 가설 검정은 자유도 \\((k-1,n-k)\\)를 가진 \\(F\\) 분포를 이용하는데 검정통계량인 F값은 분산분석표에 나오는 것처럼 아래의 공식으로 산출합니다. 각 집단간에 평균 차이가 작을수록 평균들의 분산이 작어져서 분자인 MSB가 작아져서 F 값이 작아질 것이고, 집단내의 분산이 커질수록 집단간 평균 차이가 의미가 없어지는데 이때 분모인 MSW가 커지므로 F 값이 역시 작아집니다. 따라서 F 값이 작을수록 평균의 차이가 작거나 의미가 없다는 것이 되므로 F 값을 가지고 평균 차이를 검정할 수 있습니다.\n\\[F_0=\\frac{MSB}{MSW}\\]\n또는 한참 앞에서 배웠던 분산 또는 \\(F\\)의 표집분포와 합동분산으로 설명할 수 있습니다. 위에서 \\(F_0\\)는 \\(H_0\\)인 “각 모집단의 분산은 정규 분포를 하고 동일하다”는 가정에 따라 \\(F\\)값을 산출했다는 의미입니다. 이 가정에 따르면 \\(S_{\\bar X}^2\\)는 \\(\\sigma_{\\bar X}^2\\)의 추정량이 됩니다. 즉 집단 평균들의 분산은 모집단 평균의 분산의 추정량이 됩니다. 평균의 표집분포에 따르면, \\(\\sigma_{\\bar X}^2\\) = \\(\\frac{\\sigma^2}{n}\\)이므로 \\(\\sigma^2\\) 대신 추정량인 \\(S_{\\bar X}^2\\)를 넣으면\n\\[ \\sigma^2의 \\; 추정량=n S_{\\bar X}^2\\]\n그런데 위의 방법외에도, 앞의 각 모집단에 대한 가정이 맞다면, 또한 합동분산을 이용해도 \\(\\sigma^2\\)의 추정량을 구할 수 있습니다. \\(k\\)는 집단의 수, \\(S_i^2\\)는 \\(i\\)번째 집단의 분산.\n\\[\\sigma^2의 \\; 추정량=\\frac{1}{k}\\sum_{i=1}^{k}S_i^2\\]\n모집단에 대한 가정이 맞다면, 즉 귀무가설이 맞다면 위의 두 방법에 의한 추정량이 근접할 것이고 그렇지 않다면 첫째번 추정량이 둘째보다 더 클 것입니다. 이 둘의 비율은 F 분포를 따르므로 F 값을 구해서 비교해보면 검정을 할 수 있습니다.\n\\[ F=\\frac{ 집단 \\; 평균간의 \\; 분산을 \\;  사용한 \\; \\sigma^2 \\; 추정량}{각 \\; 집단내의 \\; 분산에 \\; 의한 \\; \\sigma^2 \\; 추정량} = \\frac{MSB}{MSW}\\]\n\n\n\nFigure 11.2: 집단내 변동이 평균 차이 검정에 주는 영향\n\n\n위의 설명을 토대로 아래와 같이 가설검정을 합니다.\n\n가설을 설정한다  \\(H_0: \\mu_1=\\mu_2= \\cdots = \\mu_k\\) 모든 집단의 평균은 동일하다  \\(H_A:\\) \\(\\mu_i\\) 중 적어도 하나는 다르다 \n유의수준을 결정한다\n검정통계량 F값을 산출한다 (자유도; k-1, n-k)\n임곗값과 비교하여 결정한다\n\n\nExample 11.1  \n\niris 데이터셋에서 Species 변수의 세 품종 간의 Sepal.Length 평균 차이가 있는지 검정하세요.\n\n\n\ndata(iris)\n# ANOVA 분석 수행\nresult &lt;- aov(iris$Sepal.Length ~ iris$Species, data = iris)\n# 분석 결과 출력\nprint(result)\n\nCall:\n   aov(formula = iris$Sepal.Length ~ iris$Species, data = iris)\n\nTerms:\n                iris$Species Residuals\nSum of Squares      63.21213  38.95620\nDeg. of Freedom            2       147\n\nResidual standard error: 0.5147894\nEstimated effects may be unbalanced\n\n\n\nsummary(result)\n\n              Df Sum Sq Mean Sq F value Pr(&gt;F)    \niris$Species   2  63.21  31.606   119.3 &lt;2e-16 ***\nResiduals    147  38.96   0.265                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nanova(result)\n\nAnalysis of Variance Table\n\nResponse: iris$Sepal.Length\n              Df Sum Sq Mean Sq F value    Pr(&gt;F)    \niris$Species   2 63.212  31.606  119.26 &lt; 2.2e-16 ***\nResiduals    147 38.956   0.265                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n답: F값이 119.26이고 그에 해당하는 확률 p 0.000 \\(\\lt\\) 0.05 이므로 집단 간에 평균 차이가 없다는 귀무가설을 기각한다. 따라서 집단 간 평균 차이 중에서 적어도 하나는 차이가 있다.\n\nExample 11.2  \n\n위의 결과에서 MSB와 SSW는 각각 얼마인가요?\n\n\n답 MSB=31.606, SSW=38.956"
  },
  {
    "objectID": "variance-analysis.html#이원분산분석",
    "href": "variance-analysis.html#이원분산분석",
    "title": "11  분산분석",
    "section": "11.4 이원분산분석",
    "text": "11.4 이원분산분석\n분산분석을 정리한 표를 분산분석표라고 합니다. 한눈에 분석 결과를 보기에 편합니다. 모든 셀의 빈도가 두 개 이상이고 동일하다는 가정입니다. 셀당 \\(i\\) 사례가 있다고 하면 \\(abi=n\\)\n\n분산분석표\n\n\n\n\n\n\n\n\n\n\n분산 원천\n변동\n자유도\n평균제곱\nF\np\n\n\n\n\n요인 A\n\\(SSA\\)\n\\(a-1\\)\n\\(MSA\\)\n\\(\\frac{MSA}{MSE}\\)\n\n\n\n요인 B\n\\(SSB\\)\n\\(b-1\\)\n\\(MSB\\)\n\\(\\frac{MSB}{MSE}\\)\n\n\n\n교호작용 AB\n\\(SSAB\\)\n\\((a-1)(b-1)\\)\n\\(MSAB\\)\n\\(\\frac{MSAB}{MSE}\\)\n\n\n\n집단내\n\\(SSE\\)\n\\(n-ab\\)\n\\(MSE\\)\n\n\n\n\n계\n\\(SST\\)\n\\(n-1\\)"
  },
  {
    "objectID": "variance-analysis.html#가설검정",
    "href": "variance-analysis.html#가설검정",
    "title": "11  분산분석",
    "section": "11.5 가설검정",
    "text": "11.5 가설검정\n이원분산분석은 행 요인과 열 요인에 관하여 아래의 가설 검정 절차를 각각 시행합니다.\n\n가설을 설정한다  \\(H_0: \\mu_1=\\mu_2= \\cdots = \\mu_k\\) 모든 집단의 평균은 동일하다  \\(H_A:\\) \\(\\mu_i\\) 중 적어도 하나는 다르다 \n유의수준을 결정한다\n검정통계량 F값을 산출한다 (자유도; k-1, (k-1)(l-1) )\n임곗값과 비교하여 결정한다\n\n분산분석의 R 함수는 aov()를 사용합니다. 이원분산분석일 때 관찰수가 다르면 요인을 넣는 순서가 결과에 영향을 줍니다. 앞에 넣을수록 영향이 강하게 나오므로 대게 앞에 통제변인, 뒤에 효과변인을 넣습니다. 교호작용 요인이 들어간다면 가장 뒤에 넣습니다.\n\nExample 11.3  \n\nToothGrowth 데이터셋에서 공급방식 supp와 투여량 dose가 이빨길이 len에 미치는 영향을 분석하세요. (supp: VC 비타민C형태, OJ 오렌지쥬스형태) (dose: 0.5, 1, 2 mg/하루)\n\n\n풀이: 교호작용을 고려하지 않을 때\n\ndata(\"ToothGrowth\")\nresult &lt;- aov(len ~ factor(dose) + supp, data = ToothGrowth)\n  # factor(dose); dose가 숫자변수이므로 factor() 함수를 사용해 명목변수로 변경\nanova(result)\n\nAnalysis of Variance Table\n\nResponse: len\n             Df  Sum Sq Mean Sq F value    Pr(&gt;F)    \nfactor(dose)  2 2426.43 1213.22  82.811 &lt; 2.2e-16 ***\nsupp          1  205.35  205.35  14.017 0.0004293 ***\nResiduals    56  820.43   14.65                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n답1 두 요인 모두 F값의 확률 p \\(\\lt\\) 0.001 이므로 귀무가설을 기각합니다.\n풀이: 교호작용을 고려할 때\n\ndata(\"ToothGrowth\")\nresult_inter &lt;- aov(len ~ factor(dose) + supp + factor(dose):supp, data = ToothGrowth)\n  # 또는 aov(len ~ factor(dose) * supp, data = ToothGrowth) 로 적어도 된다 \n  # factor(dose); dose가 숫자변수이므로 factor() 함수를 사용해 명목변수로 변경\nanova(result_inter)\n\nAnalysis of Variance Table\n\nResponse: len\n                  Df  Sum Sq Mean Sq F value    Pr(&gt;F)    \nfactor(dose)       2 2426.43 1213.22  92.000 &lt; 2.2e-16 ***\nsupp               1  205.35  205.35  15.572 0.0002312 ***\nfactor(dose):supp  2  108.32   54.16   4.107 0.0218603 *  \nResiduals         54  712.11   13.19                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n답2 두 요인 모두 F값의 확률 p \\(\\lt\\) 0.001 이므로 귀무가설을 기각합니다. 교호작용 역시 p \\(\\lt\\) 0.05 이므로 len에 영향이 없다는 귀무가설을 기각합니다. 만일 유의수준 \\(\\alpha=0.01\\)이라면 교호작용의 확률인 0.02186은 0.01보다 크므로 귀무가설을 채택합니다. 따라서 교호작용이 len에 영향을 주지 않는다고 결론을 내립니다.\n분산분석표를 직접 그리려면\n\n# 앞의 코드청크를 실행해 result_inter 변수를 생성하고 실행한다.\nresult.anova&lt;- anova(result_inter)\nknitr::kable(result.anova, align = 'c', caption = '쥐 이빨 길이 len에 대한 이원분산분석 결과')\n\n\n쥐 이빨 길이 len에 대한 이원분산분석 결과\n\n\n\n\n\n\n\n\n\n\n\nDf\nSum Sq\nMean Sq\nF value\nPr(&gt;F)\n\n\n\n\nfactor(dose)\n2\n2426.434\n1213.21717\n91.999965\n0.0000000\n\n\nsupp\n1\n205.350\n205.35000\n15.571979\n0.0002312\n\n\nfactor(dose):supp\n2\n108.319\n54.15950\n4.106991\n0.0218603\n\n\nResiduals\n54\n712.106\n13.18715\nNA\nNA"
  },
  {
    "objectID": "linear-regression.html#피어슨-상관계수",
    "href": "linear-regression.html#피어슨-상관계수",
    "title": "12  선형 회귀분석",
    "section": "12.1 피어슨 상관계수",
    "text": "12.1 피어슨 상관계수\n상관분석 correlation analysis 은 두 변수 사이의 관계가 관련되어 있는 정도를 측정하는 방법입니다. 여러 기법이 있는데, 피어슨 상관계수 Pearson correlation coefficient 는 상관분석에서 가장 흔하게 사용하는 방법입니다. 모집단에서 각 개체가 가진 특성 두 개를 X와 Y라고 하면, 두 변수 사이에 직선관계가 얼마나 강한가를 \\(\\rho\\)=Corr(\\(X,Y\\))로 표기합니다. 상관계수는 -1에서 1 사이의 값을 가지며 0이면 두 변수가 독립적입니다.\n모 상관계수의 계산은;\n\\[ \\rho_{XY} = {Corr}(X,Y) = \\frac{Cov(X,Y)}{\\sigma_X \\sigma_Y} \\]\n표본 상관계수의 계산은;\n\\[ r = \\frac{\\sum_{i=1}^{n}(x_i-\\bar x)(y_i-\\bar y)}{\\sqrt{\\sum_{i=1}^{n}(x_i-\\bar x)^2 \\sum_{i=1}^{n}(y_i-\\bar y)^2}} = \\frac{S_{xy}}{S_x S_y} \\]\n\nExample 12.1  \n\n다음은 옷가게에서 손님의 키와 무게를 조사한 것입니다. 상관계수를 구하세요.\n\n\n\n\nID\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n\n키\n162\n158\n160\n168\n150\n154\n160\n166\n170\n146\n\n\n무게\n55\n52\n60\n58\n50\n67\n56\n66\n72\n51\n\n\n\n\n\n# x=키, y=무게\nx &lt;- c(162, 158, 160, 168, 150, 154, 160, 166, 170, 146)\ny &lt;- c(55, 52, 60, 58, 50, 67, 56, 66, 72, 51)\n\nxbar &lt;- mean(x)   # x 평균\nybar &lt;- mean(y)   # y 평균\nS_xy &lt;- sum( (x-xbar)*(y-ybar) ) # 공분산: x 편차와 y 편차를 곱해서 다 더한 것\nS_x &lt;- sqrt( sum( (x-xbar)^2 ) )  # x 편차를 제곱해서 다 더한 뒤에 제곱근\nS_y &lt;- sqrt( sum( (y-ybar)^2 ) )  # y 편차를 제곱해서 다 더한 뒤에 제곱근\n\nr &lt;- S_xy/(S_x*S_y)  # 공식에 대입해서 구한 상관계수\ncat(\"상관계수= \", r)\n\n상관계수=  0.6208491\n\n\n\ncor(x,y)  # 답이 맞나 확인\n## [1] 0.6208491\n\n\n위의 코드청크는 전에 나왔던 벡터변수를 계산하는 공식을 사용한 것입니다. 참고로 다시 잠깐 떠올려 봅시다.\n\n\n# 벡터변수를 만들고 계산하는 예\nx &lt;- c(1, 2, 3)\nx\n## [1] 1 2 3\nmean(x)   # 평균\n## [1] 2\nsum(x)    # 합\n## [1] 6\nx * 3\n## [1] 3 6 9\ny &lt;- c(4, 5, 6)\ny\n## [1] 4 5 6\n# 벡터변수 두 개를 서로 곱하면; \nx * y  # (1*4, 2*5, 3*6)\n## [1]  4 10 18\nsum(x * y)\n## [1] 32\n\n\nExample 12.2  \n\n위의 키와 무게 상관계수 \\(r\\)의 표준오차 \\(S_{r}\\)와 \\(r\\)의 \\(t\\) 값은 얼마입니까?\n\n\n답: 아래의 공식에 따라서 \\(r\\)의 \\(t\\)값과 표준오차를 구합니다.\n\nr &lt;- r #위의 r값을 그대로 가져온다\nn &lt;- length(x)  # 10 손님의 수 또는 표본의 크기\nS_r &lt;- sqrt( (1-r^2)/(n-2) )\nt &lt;- (r-0)/S_r\np &lt;- pt(t, n-2)\n         # \\n은 줄 바꿈 기능, round( ,3)은 소수3자리 반올림\nout1 &lt;- paste(\"표준오차= \", round(S_r, 3), \"\\n\") \nout2 &lt;- paste(\"t= \", round(t, 3), \"p= \", round(p, 3), \"\\n\")\nout3 &lt;- paste(\"(참고로 임곗값은\", round(qt(0.025, 8), 3), \n              round(qt(0.975, 8), 3), \")\" )\n# 한꺼번에 출력\ncat(out1, out2, out3)\n\n표준오차=  0.784 \n t=  0.792 p=  0.713 \n (참고로 임곗값은 -2.306 2.306 )\n\n\n여기에서 모 상관계수가 0인지 아닌지 또는 두 변수가 상관관계가 있는지 없는지 알기 위해서 검정을 할 수 있습니다. 검정 통계량은 \\(t\\) 값입니다. 자유도는 \\(n-2\\).\n\n\\(H_0: \\rho=0\\) 두 변수는 상관관계가 없다.\n\\(H_A: \\rho \\ne 0\\) 두 변수는 상관관계가 있다.\n\n검정을 하려면 표본 상관계수 \\(r\\)의 표집분포를 살펴봐야 합니다. 모집단에서 두 변수가 관계가 없다는 가정을 하면 모집단의 상관계수 \\(\\rho\\)=0 입니다. 따라서 상관계수의 \\(t\\)값은 아래와 같습니다. \\(S_r\\)은 \\(r\\)의 표준오차입니다.\n\\[ t=\\frac{r-0}{S_r}, \\; \\; 여기서 \\; \\; S_r=\\sqrt{\\frac{1-r^2}{n-2}}   \\]\n산출한 \\(t\\)값 또는 그에 대응하는 \\(p\\)값을 미리 정한 유의수준 \\(\\alpha\\)이나 그에 대응하는 \\(t\\) 임계값과 비교하여 결정합니다.\n\nExample 12.3  \n\niris 데이터셋의 변수 Sepal.Length 와 Petal.Length 의 상관계수를 구하세요.\n\n\n\ndata(\"iris\")\n# 피어슨 상관계수 계산\nresult &lt;- cor.test(iris$Sepal.Length, iris$Petal.Length)\nprint(result)\n\n\n    Pearson's product-moment correlation\n\ndata:  iris$Sepal.Length and iris$Petal.Length\nt = 21.646, df = 148, p-value &lt; 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.8270363 0.9055080\nsample estimates:\n      cor \n0.8717538 \n\n\n답: \\(r\\)= 0.8717538, \\(t\\)= 21.6460193, \\(p\\)= 0 \\(\\lt 0.005\\)\n따라서 유의수준 \\(\\alpha\\)=1% 수준에서 두 변수는 상관관계가 있다.\n(참고로 신뢰구간은 0.8270363, 0.905508)\n$r$= `r result[4]`, $t$= `r result[1]`, $p$= `r round(result[[3]], 3)` $\\lt 0.005$\n따라서 유의수준 $\\alpha$=1% 수준에서 두 변수는 상관관계가 있다. \n(참고로 신뢰구간은 `r result$conf.int`)\n상관계수는 리스트 변수인 result 속의 한 요소로서 이름 있는 데이터 named data 로 저장되어 있습니다. 그래서 인라인 코드에서 result[4]하면 미리 정한 규칙에 따라 숫자만을 되주지만 round(result[4])는 에러가 납니다. round()에는 숫자형 데이터만 들어갈 수 있기 때문입니다 (이름 있는 데이터가 아니고). 함수를 사용하면서 이름 있는 데이터 형에서 숫자만을 끄집어내려면 ’[[ ]]’을 사용합니다. 그래서 round(result[[4]])라고 해야 합니다. (또는 이름을 사용해서, result[[\"estimate\"]]) 아래의 차이를 보세요.\n\nresult[4]\nresult[\"estimate\"]\nresult[[4]]\nresult[[\"estimate\"]]\n\n\n\n$estimate\n      cor \n0.8717538 \n\n\n$estimate\n      cor \n0.8717538 \n\n\n      cor \n0.8717538 \n\n\n      cor \n0.8717538 \n\n\n\n\n\n\n\n\n\n\n결과에 나타난 용어의 의미\n\n\n\n위 상관분석 결과에서 나타난 용어 confidence interval과 estimate를 주목해주세요. 이 용어들은 9 장의 점 추정과 구간 추정에서 배웠습니다. 거기에 다시 가서 한 번 읽어보세요.\n\n\n위의 corr.test 함수 결과가 저장된 result는 데이터 형태가 리스트 list 입니다. 다루기 어렵지 않지만 익숙해지기까지 시간이 걸리니까 위의 예를 보고 그대로 사용하거나 또는 코드청크의 결과를 보고 직접 숫자를 넣어도 좋습니다. 아래는 위의 청크를 실행한 뒤에 오른쪽 위 Environment 패널에 생긴 result를 클릭하면 왼쪽 위에 나타나는 result의 리스트 값들입니다. 작은 삼각형들을 눌러서 펼친 결과입니다.\n\n\n\nFigure 12.1: result의 리스트 형태\n\n\n참고로 Section 5.3 에 나왔던 여러 데이터 형태를 다시 보면,\n\nve &lt;- c(1, 2, 3, 4)  # 벡터\nve\nma &lt;- matrix(c(5, 6, 7, 8), nrow=2)  # 매트릭스\nma\nli &lt;- list(보호자=\"영희\", 아이_수=3, 아이_나이=c(4, 7, 9), 아이_이름=c(\"수동\", \"길동\", \"신혜\") )    # 리스트\nli\n키 = c(174, 182, 167, 164, 161)\n무게 = c(72, 74, 65, 62, 59)\nda &lt;- data.frame(키, 무게)  # 데이터 프레임\nda\n\n\n\n[1] 1 2 3 4\n\n\n     [,1] [,2]\n[1,]    5    7\n[2,]    6    8\n\n\n$보호자\n[1] \"영희\"\n\n$아이_수\n[1] 3\n\n$아이_나이\n[1] 4 7 9\n\n$아이_이름\n[1] \"수동\" \"길동\" \"신혜\"\n\n\n   키 무게\n1 174   72\n2 182   74\n3 167   65\n4 164   62\n5 161   59\n\n\n\n\n\n\n\n\n\n\nTip\n\n\n\n위의 0.8717538에서 대체 [4]인 것을 어떻게 알았는가? 하는 생각이 들겠지요. 환경 패널의 result 리스트를 펼쳐서 네 번째 요소에 r이 들었다는 걸 (estimate 와 cor을) 찾으면 됩니다.\n\n\n산포도를 그려보는 게 관계를 아는 데 도움이됩니다. iris 데이터에는 품종 Species 변수도 있으므로 산포도에서 세 품종의 빛깔을 달리해서 품종에 따라 관계가 다른지 눈으로 확인해 봅시다.\n\nlibrary(ggplot2)\n# Sepal.Length =꽃받침.길이, Petal.Length=꽃잎.길이, Species=품종\nggplot(iris, aes(Sepal.Length, Petal.Length, colour = Species)) + geom_point()\n\n\n\n\nFigure 12.2: ?(caption)\n\n\n\n\n변수가 여럿일 때 pairs 함수가 관계를 예측하는 데 도움이 됩니다.\n\npairs(iris[1:4], col = iris$Species)\n\n\n\n\nFigure 12.3: iris 데이터의 산포도 행렬"
  },
  {
    "objectID": "linear-regression.html#편상관계수",
    "href": "linear-regression.html#편상관계수",
    "title": "12  선형 회귀분석",
    "section": "12.2 편상관계수",
    "text": "12.2 편상관계수\n편상관계수 partial correlation coeffiencient 는 두 확률변수의 상관관계를 계산할 때 두 변수에 모두 작용하는 제3의 변수가 있다면 왜곡된 상관계수를 산출할 수 있습니다. 이때 제3의 변수를 교란변수 confounding variable 라고 합니다. 즉 교란변수가 양쪽 두 변수에 허위상관관계를 만들어서 실제 관계 정도와 달라질 수 있는 것이죠. 이럴 때 교란변수의 영향을 제거한 뒤에 계산한 상관계수를 말합니다. 영향을 통제(제거)하려는 제3의 변수를 통제변수 control variable 라고 합니다.\n예를 들면, 대학생들이 대학 교육의 결과로 소통 능력이 향상한다는 가설이 있다고 합시다. 가설을 검정하려고 학년(재학 기간)과 소통능력의 상관계수를 산출합니다. 그런데 나이가 늘수록 사회경험이 증가하니까, 나이도 소통능력의 향상에 영향을 미친다고 볼 수 있습니다. 그리고 학년이 올라갈수록 나이도 한 살씩 늘어갑니다. 따라서 소통능력의 향상에 미치는 나이의 영향을 통제해야만 순수하게 대학 교육의 효과를 측정할 수 있습니다. 이럴 때 학년과 소통능력의 상관계수에서 나이가 미치는 영향을 통제(제외)하고 계산한 상관계수가 편상관계수입니다.\n\\(X\\), \\(Y\\)의 상관계수에서 교란변수 \\(Z\\)의 영향을 제외한 편상관계수 \\(\\rho _{XY\\cdot Z}\\) 는 \\(\\epsilon_X\\)와 \\(\\epsilon_Y\\)의 상관계수와 동일합니다. \\(\\epsilon_X\\)는 \\(Z\\)로 \\(X\\)를 설명하고 남은 잔차이고 \\(\\epsilon_Y\\) 는 \\(Z\\)로 \\(Y\\)를 설명하고 남은 잔차입니다. 이것은 \\(X=\\alpha Z+\\epsilon_X\\) 와 \\(Y=\\beta Z+\\epsilon_Y\\)의 공식으로 표현합니다. 잔차의 개념은 바로 뒤의 회귀분석에서 자세히 나옵니다. 그래서 \\(\\rho _{XY\\cdot Z} = Corr(\\epsilon_X, \\epsilon_Y)\\) 가 되고 이걸 풀어내면 나오는 아래의 공식을 편상관계수를 산출하는 데 사용합니다.\n\\[\\rho_{XY \\cdot Z} =\\frac {\\rho_{XY}-\\rho_{XZ} \\rho_{ZY}}{\\sqrt {1-\\rho _{XZ}^{2}} \\sqrt {1-\\rho_{ZY}^{2}}} \\]\n아래 Figure 12.4 을 봅니다. 변수X와 변수Y 사이에 직접경로와 간접경로가 모두 존재한다고 가정하면 X와 Y의 상관관계는 그 둘을 모두 합친 것입니다. 따라서 상관계수 \\(\\rho_{XY}\\)는 직접경로 X\\(\\rightarrow\\)Y와 간접경로 X\\(\\rightarrow\\)Z\\(\\rightarrow\\)Y를 합친 것입니다. 편상관계수 \\(\\rho_{XY \\cdot Z}\\)는 간접경로 X\\(\\rightarrow\\)Z\\(\\rightarrow\\)Y를 제외하고 직접경로 X\\(\\rightarrow\\)Y만을 계산한 것입니다.\n\n\n\n\n\nFigure 12.4: X와 Y의 관계 경로와 편상관계수\n\n\n\n\n편상관계수는 ppcor 패키지를 설치하고 pcor() 함수를 사용하여 계산합니다."
  },
  {
    "objectID": "linear-regression.html#공분산",
    "href": "linear-regression.html#공분산",
    "title": "12  선형 회귀분석",
    "section": "12.3 공분산",
    "text": "12.3 공분산\n확률변수 X와 확률변수 Y의 선형 연관성은 공분산 covariance 으로 측정이 가능합니다.\n\\[ Cov(X,Y) = E[(X-\\mu_X)(Y-\\mu_Y)] = \\frac{1}{N} \\sum_{i=1}^{N}(X-\\mu_X)(Y-\\mu_Y)\\]\n공분산은 아래의 속성을 갖습니다.\n\n공분산이 양이면 두 변수는 같은 방향으로 증감한다.\n공분산이 음이면 두 변수는 반대 방향으로 증감한다.\n공분산이 0에 가까우면 선형적 상관관계가 작다."
  },
  {
    "objectID": "linear-regression.html#단순회귀분석",
    "href": "linear-regression.html#단순회귀분석",
    "title": "12  선형 회귀분석",
    "section": "12.4 단순회귀분석",
    "text": "12.4 단순회귀분석\n회귀분석 regression analysis 은 종속변수와 독립변수 사이의 관계를 추정하는 통계적 과정을 말합니다. 회귀분석에서 종속변수는 오직 한 개이며 결과 또는 반응 변수라고도 합니다. 독립변수는 하나 또는 여러 개일 수도 있으며 예측 또는 설명 변수라고도 불립니다. 독립변수가 하나면 단순회귀분석 simple regression analysis 이고 여러 개이면 다중회귀분석 multiple regression analysis 입니다. 여기서는 선형 회귀분석 linear regression 을 다루는데 그 중에서도 최소제곱법 least square method 을 이용해서 모수 추정을 하는 기법을 배웁니다.\n\n12.4.1 단순회귀계수 산출\n회귀분석은 선형 회귀모형 linear regression model 을 만드는데, 두 가지 핵심 목적을 가집니다. 하나는 독립변수를 이용하여 종속변수를 예측하는 것이고 둘째 것은 독립변수가 종속변수에 영향을 준다는 인과관계를 검정하려는 것입니다. 인과관계의 검정은 회귀분석만으로는 검정이 안 되고 문헌조사를 통한 논리적인 근거를 연구자가 따로 제공해야 합니다.\n단순회귀분석 모형은 아래와 같은 식으로 나타낼 수 있습니다.\n\\[ {\\displaystyle Y_{i}=\\beta _{0}+\\beta _{1}X_{i}+\\epsilon_{i}} \\; , \\; \\epsilon \\sim N(0,\\sigma^2) \\]\n여기서 \\(\\beta _{0}\\)와 \\(\\beta_{1}\\)은 아직 모르는 모수(모 회귀계수)이고 \\(x_{i}\\)는 독립변수, \\(Y_{i}\\)는 종속변수입니다. \\(e_{i}\\)는 오차항 error term 이라고 하며 독립변수에 의해 설명되지 않는 종속변수의 잔여 부분을 말합니다. 오차항은 정규분포를 하는 확률변수입니다. \\(\\beta _{0}\\)와 \\(\\beta_{1}\\)은 회귀계수를 밑첨자 숫자로 구분했지만, 절편은 \\(\\alpha\\)로 기울기는 \\(\\beta\\)로 통상 문자를 달리해서 표시하는 방법을 사용합니다.\n이러한 회귀모형을 만들려면 가정이 여러 개 필요합니다.\n\n잔차 \\(\\epsilon\\)는 평균이 0 인 정규분포를 따른다\n잔차는 서로 독립적이다\n잔차 \\(\\epsilon\\)는 모든 \\(X\\) 값에서 동일한 분산을 갖는다\n독립변수 \\(X\\)는 측정오차가 없다\n\n추정값를 넣어서 회귀직선 방정식을 만들면 아래와 같습니다.\n\\[\\displaystyle {\\hat {Y}}_{i}={\\hat {\\beta }}_{0}+{\\hat {\\beta }}_{1}X_{i} \\]\n\\(Y\\)의 예측값과 관찰값의 차이가 잔차 residual 또는 error 인데, 잔차 제곱의 합을 최소로 만드는 최소제곱법에 의해서 회귀계수를 구해야 합니다.\n잔차는 표본에서 나타난 실제값이고 이론적 회귀모형 모델에서는 오차항입니다. 이때는 모델의 설명력 밖에 있는 (아직 밝혀지지 않은 다른) 요인들을 나타내는 통계적인 개념입니다.\n\\[ \\sum_{i=1}^{n} (y_i-\\hat y_i)^2 =  \\sum_{i=1}^{n}\\epsilon_i^2 = \\sum_{i=1}^{n}(y_i-\\hat \\beta_0 - \\hat \\beta_1 x_i)^2 \\]\n\\(\\beta_0\\)와 \\(\\beta_1\\)의 추정량인 \\(\\hat \\beta_0\\)와 \\(\\hat \\beta_1\\)을 구하는 공식은 아래와 같습니다. 위의 식인 2차방정식을 최소로 만드는 값은 미분해서 0 인 값이므로 아래 식을 만들 수 있습니다.\n\\[\\displaystyle \\hat \\beta_1 = \\frac{\\sum_{i=1}^{n}(x_i-\\bar x)(y_i-\\bar y)}{\\sum_{i=1}^{n}(x_i-\\bar x)^2} = \\frac{\\sum_{i=1}^{n}x_i y_i-n \\bar x \\bar y}{\\sum_{i=1}^{n}x_i^2-n\\bar x^2} \\; , \\; \\; \\hat \\beta_0 = \\bar y-\\hat \\beta_1 \\bar x\\]\n위의 값에서 산출한 회귀직선의 방정식은;\n\\[\\displaystyle {\\hat {Y}}_{i}={\\hat {\\beta }}_{0}+{\\hat {\\beta }}_{1}X_{i} \\]\n독립변수와 종속변수를 모두 \\(z\\)로 표준화해서 단순회귀분석을 하면 단순회귀계수 \\(\\beta\\)는 두 변수의 피어슨 상관계수와 동일한 값을 갖습니다.\n\n\n12.4.2 Anscombe’s quartet\n1973년 통계학자 안스콤이 만든 데이타셋 4개. 동일한 기술 통계를 가지고 아주 비슷한 회귀직선을 갖지만 명백하게 다른 분포를 지닙니다. 단지 통계 결과만이 아니라 시각적 분포를 살펴야 한다는 점을 보여줍니다. 극단값을 주목해야 한다는 점도 있고요. 아래는 4개의 데이터셋이 동일한 속성을 가진 것을 보여주는데 특히 회귀식이 같다는 점을 주목해 주세요.\n\n\nTable 12.1: 안스콤이 만든 네 쌍의 데이터\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nx1\ny1\n|\nx2\ny2\n|\nx3\ny3\n|\nx4\ny4\n\n\n\n\n10.0\n8.04\n|\n10.0\n9.14\n|\n10.0\n7.46\n|\n8.0\n6.58\n\n\n8.0\n6.95\n|\n8.0\n8.14\n|\n8.0\n6.77\n|\n8.0\n5.76\n\n\n13.0\n7.58\n|\n13.0\n8.74\n|\n13.0\n12.74\n|\n8.0\n7.71\n\n\n9.0\n8.81\n|\n9.0\n8.77\n|\n9.0\n7.11\n|\n8.0\n8.84\n\n\n11.0\n8.33\n|\n11.0\n9.26\n|\n11.0\n7.81\n|\n8.0\n8.47\n\n\n14.0\n9.96\n|\n14.0\n8.10\n|\n14.0\n8.84\n|\n8.0\n7.04\n\n\n6.0\n7.24\n|\n6.0\n6.13\n|\n6.0\n6.08\n|\n8.0\n5.25\n\n\n4.0\n4.26\n|\n4.0\n3.10\n|\n4.0\n5.39\n|\n19.0\n12.50\n\n\n12.0\n10.84\n|\n12.0\n9.13\n|\n12.0\n8.15\n|\n8.0\n5.56\n\n\n7.0\n4.82\n|\n7.0\n7.26\n|\n7.0\n6.42\n|\n8.0\n7.91\n\n\n5.0\n5.68\n|\n5.0\n4.74\n|\n5.0\n5.73\n|\n8.0\n6.89\n\n\n\n\n아래는 안스콤의 데이터 네 쌍이 가진 거의 동일한 기술 통계를 표로 나타낸 것입니다. 완전히 일치하거나 적어도 소숫점 둘째 자리까지 동일할 정도로 유사합니다.\n\n\nTable 12.2: 안스콤 4 쌍의 유사한 기술 통계 (평균, 분산, 상관계수, 회귀식)\n\n\n속성\n값\n정확도\n\n\n\n\nx의 평균\n9\n일치\n\n\nx의 분산 \\(s_x^2\\)\n11\n일치\n\n\ny의 평균\n7.50\n소수점 2자리까지\n\n\ny의 분산 \\(s_y^2\\)\n4.125\n\\(\\pm 0.003\\)\n\n\nx와 Y의 상관계수\n0.816\n소수점 3자리까지\n\n\n회귀식\ny=3.00+0.500x\n각 소수점 2와 3자리까지\n\n\n회귀직선 \\(R^2\\)\n0.67\n소수점 2자리까지\n\n\n\n\n\npar(mfrow=c(2,2), mar = c(2, 4, 1, 2) + 1) # 그래프 영역을 2x2로 분할, 여백과 크기를 조정\n\ndata(\"anscombe\")\n\n# for 루프로 그래프 4번 반복 생산\nfor (i in 1:4) {     \np &lt;- plot(anscombe[,i], anscombe[,i+4], type = \"p\", pch = 21, xlim = c(3, 20), ylim = c(3, 14), ylab =paste0(\"y\", i))\np &lt;- abline(a=3, b=0.5, col=\"red\")  # 그래프에 선 넣기\n}\n\n\n\n\nFigure 12.5: 안스콤의 네 쌍 데이터가 만든 각 산포도의 비교\n\n\n\n\n\n\n12.4.3 단순회귀모형 적합성 검정\n적합도 검정(goodness-of-fit test)은 계수를 구해 도출한 회귀식 \\(Y = \\beta_0 + \\beta_1 X\\)이 표본의 실제값을 얼마나 잘 설명하는지를 확인하는 방법입니다. 추정한 회귀식의 설명력에 대한 척도를 \\(R^2\\)(회귀선의 설명력, 결정계수)으로 표현합니다.\n\\(R^2\\)(결정계수) = \\(\\frac{SSR}{SST}\\) = \\(\\frac{회귀식으로 \\; 설명된 \\; 변동}{총변동}\\)\n\\(Y_i\\)는 실제 관찰값이고 \\(\\hat{Y_i}\\)는 그에 대응하는 회귀선이 예측한 값이고, \\(\\bar{Y}\\)는 \\(Y\\) 관찰값의 평균입니다.\n\n적합도 검정을 위한 \\(R^2\\) 값\n\n\n변동\n계산\n\n\n\n\n관찰한 모든 변동: 총제곱합(SST)\n\\(\\sum{(Y_i-\\bar{Y})^2}\\)\n\n\n설명한 변동: 회귀제곱합(SSR)\n\\(\\sum{(\\hat{Y}_i-\\bar{Y})^2}\\)\n\n\n설명 못한 변동: 잔차 제곱합(SSE)\n\\(\\sum{(Y_i-\\hat{Y}_i)^2}\\)\n\n\n\n\\(SST = SSE + SSR \\rightarrow \\frac{SSR}{SST}=1-\\frac{SSE}{SST}=R^2\\)\n\n\n\nFigure 12.6: 설명한 변동\n\n\n\n\n12.4.4 분산분석표\n분산분석표 analysis of variance table 는 제곱합 \\(SS\\); sum of squares 과 자유도, 제곱평균\\(MS\\); mean square, \\(F\\)값 등을 표로 나타낸 것입니다. 각 요소들의 관계를 한 눈에 살필 수 있습니다.\n\n\nTable 12.3: 단순회귀 분산분석표\n\n\n\n\n\n\n\n\n\n\n요인\n자유도\n제곱합\n제곱평균\n\\(F\\)\n\\(p\\)\n\n\n\n\n회귀\n1\n\\(SSR=\\sum(\\hat Y_i-\\bar Y)^2\\)\n\\(MSR=\\frac{SSR}{1}\\)\n\\(\\frac{MSR}{MSE}\\)\n\n\n\n잔차\n\\(n-2\\)\n\\(SSE=\\sum(Y_i-\\hat Y_i)^2\\)\n\\(MSE=\\frac{SSE}{n-2}\\)\n\n\n\n\n계\n\\(n-1\\)\n\\(SST=\\sum(Y_i-\\bar Y)^2\\)\n\n\n\n\n\n\n\n\\(MSE\\)는 오차 분산 \\(\\sigma_{\\epsilon}^{2}\\) 의 불편 추정량 unbiased estimator 입니다.\n여기서 나오는 \\(F\\)값과 그에 대응하는 \\(p\\)값은 회귀모형의 유의성 검정에 사용합니다.\n\n\n12.4.5 단순회귀모형의 유의성 검토\n회귀모형의 유의성은 독립변수 \\(X\\)가 종속변수 \\(Y\\)에 정말로 영향을 미치는지 검정하는 겁니다. 유의성을 검토하는 절차는 아래와 같습니다.\n\n가설을 세운다  \\(H_0: \\beta = 0\\)  \\(H_A: \\beta \\ne 0\\) \n유의수준을 결정한다\n검정통계량을 계산한다 \\[ F_0= \\frac{MSR}{MSE} \\gt F_{\\alpha , (1,n-2)} \\]\n임곗값과 비교하여 결정한다\n\n\n\n12.4.6 단순회귀 추정의 표준오차\n잔차가 적을수록 독립변수 \\(X\\)가 종속변수 \\(Y\\)를 잘 설명하는 것이므로 잔차의 표준편차를 추정의 표준오차라고도 부릅니다. 계산 공식은 아래와 같습니다.\n\\[ s = \\sqrt{\\frac{\\sum(Y_i-\\hat Y_i)^2}{n-2}} = \\sqrt{\\frac{\\sum e_i^2}{n-2}} = \\sqrt{\\frac{SSE}{n-2}} = \\sqrt{MSE} \\]\n추정의 표준오차가 적을수록 회귀식이 잘 작동하는 것이지만 \\(s\\)는 표준화가 되지 않아서 \\(Y\\) 단위에 따라 달라져서 다른 회귀분석과 비교하기 어려운 단점이 있습니다. 그래서 결정계수를 이용합니다.\n\n\n12.4.7 결정계수\n결정계수 coefficient of determination 는 총제곱합 \\(SST\\) 중에서 회귀직선이 설명하는 제곱합 \\(SSR\\)의 비율로 나타냅니다. 실제로는 계산하기 편하게 \\(SSE\\)를 이용하여 산출합니다. 결정계수는 회귀 모델이 변동을 얼마나 설명하는지에 대한 설명력을 나타냅니다.\n\\[ R^2=\\frac{SSR}{SST} = 1 - \\frac{SSE}{SST}   \\]\n\n\n12.4.8 회귀계수의 신뢰구간\n\n12.4.8.1 \\(\\beta\\)의 신뢰구간 추정\n회귀계수 \\(\\beta\\)의 표집분포는 \\(n-2\\)의 자유도와 표준오차 \\(S_b\\)를 가진 \\(t\\) 분포를 따르므로 그 신뢰구간은 아래와 같습니다. 이것은 앞서 배운 평균의 신뢰구간과 오차범위 계산 방법이 동일합니다.\n\\[ b-t_{n-2,\\alpha / 2} S_b \\le \\beta \\le b + t_{n-2,\\alpha / 2} S_b\\]\n여기서\n\\[ S_b = \\sqrt{\\frac{MSE}{\\sum(X_i-\\bar X)^2}} \\; ,  \\; \\; \\; MSE = \\frac{\\sum(Y_i-\\hat{Y}_i)^2}{n-2}   \\]\n\n\n12.4.8.2 \\(\\alpha\\)의 신뢰구간 추정\n회귀직선의 절편인 \\(\\alpha\\)는 잘 사용하지 않지만 \\(\\beta\\)가 0인 경우에 가끔 추정하기도 합니다. \\(\\alpha\\)의 점추정량 \\(a\\)는\n\\[  a = \\bar Y - b \\bar X  \\] \\(a\\)의 표집분포는 정규분포를 하며 기대값과 분산은 아래와 같습니다.\n\\[ E(a)=\\alpha \\; , \\; \\;    S_a = \\sqrt{MSE \\frac{\\sum X_i^2}{n \\sum(X_i-\\bar X)^2}} \\; ,  \\; \\; \\; MSE = \\frac{\\sum(Y_i-\\hat{Y}_i)^2}{n-2}     \\]\n그래서 \\(\\alpha\\)의 신뢰구간은\n\\[ a-t_{n-2,\\alpha / 2} S_a \\le \\alpha \\le a + t_{n-2,\\alpha / 2} S_a \\]\n\n\n12.4.8.3 \\(E(\\hat Y_h)\\)의 신뢰구간 추정\n\\(X_h\\)로 예측하는 \\(Y\\) 값의 평균을 \\(E(\\hat Y_h)\\)라고 할 때 \\(\\hat Y_h\\)는 그것의 점추정량입니다.\n\\[ \\hat Y_h = a+bX_h \\]\n\\(\\hat Y_h\\)의 표집분포는 정규분포이며 기대값과 분산은 아래와 같습니다.\n\\[ E(\\hat Y_h)= E(Y_h)\\; , \\; \\; \\sigma_{\\hat Y_h}^2 =  \\sigma^2 \\left( \\frac{1}{n}+\\frac{(X_h-\\bar X)^2}{\\sum_{i=1}^{n} (X_i-\\bar X)^2} \\right) \\]\n우리는 \\(\\sigma^2\\)를 모르는 경우가 많으므로 \\(\\hat Y_h\\) 분산의 추정치인 \\(S_{\\hat Y_h}^2\\)를 대신 사용합니다.\n\\[ S_{\\hat Y_h}^2 =  MSE \\left( \\frac{1}{n}+\\frac{(X_h-\\bar X)^2}{\\sum_{i=1}^{n} (X_i-\\bar X)^2} \\right) \\]\n따라서 신뢰구간은\n\\[ \\hat Y_h-t_{n-2,\\alpha / 2} S_{\\hat Y_h} \\le E(\\hat Y_h) \\le \\hat Y_h + t_{n-2,\\alpha / 2} S_{\\hat Y_h} \\]"
  },
  {
    "objectID": "linear-regression.html#단순회귀모형의-검토",
    "href": "linear-regression.html#단순회귀모형의-검토",
    "title": "12  선형 회귀분석",
    "section": "12.5 단순회귀모형의 검토",
    "text": "12.5 단순회귀모형의 검토\n\n12.5.1 잔차의 검토\n회귀모형에서는 오차항에 대한 가정이 여럿입니다. 선형성, 정규성, 독립성, 등분산성 등인데 이것을 충족하는지 잔차를 통해서 검토합니다. 잔차는 통상 표준화를 해서 검토하는데 표준화한 잔차를 영어로는 studentized residuals 라고 합니다. 아래의 \\(d_i\\)가 표준화한 잔차입니다.\n\\[ d_i = \\frac{e_i}{\\sqrt{MSE}} \\]\n\n\n12.5.2 선형성 검토\n\\(x\\)에 대해서 산점도를 그렸을 때 0을 중심으로 무작위하게 나타나야 합니다. 아래의 잔차 산포도는 잔차가 0을 중심으로 고루 분포되어 있습니다.\n\n\nCode\nx &lt;- seq(from = 0, to = 1, length.out = 301)   # 0부터 1까지 501개 등간 숫자 생성\ny &lt;- rnorm(301, mean=0, sd=0.3)                # 평균 0, 표준편차 0.3인 정규분포 난수를 501개 생성\n\npar(mar = c(1, 1, 1, 1))  # 그림 주위의 여백 조정. par; parameter. mar; margin (상, 우, 하, 좌)\n\nplot(x, y, type = \"p\", pch = 20, xlim = c(-0.03, 1.02), ylim = c(-2.1, 2.1), axes=F, xlab = \"\",  ylab = \"\")\n# pch; point character. 20; 꽉차고 작은 둥근 점. axes=F; 축 눈금이 없다\nabline(0,0, v=-0.04, col = \"black\")  # y 축을 대신할 선을 그린다. v; vertical line. (h는 수평선)\ntext(1.05, -0.1, \"x\")                # 그래프 안에 좌표로 텍스트를 넣을 위치를 표시\ntext(-0.06, 1.1, \"e\")\ntext(-0.06, -0.1, \"0\")\n\n\n\n\n\nFigure 12.7: 잔차의 선형성 검토\n\n\n\n\n위의 그래프는 잔차만을 그린 것이지만 원래 그래프 상에서 그대로 나타내면 아래와 같습니다. 윗그림과 잔차는 동일합니다.\n\n\nCode\nx &lt;- seq(from = 0, to = 1, length.out = 301)   # 0부터 1까지 501개 등간 숫자 생성\ny &lt;- rnorm(301, mean=0, sd=0.3)                # 평균 0, 표준편차 0.3인 정규분포 난수를 501개 생성\ny1 &lt;- 1 + 3*x +y       # y=1+3*x+y  맨뒤 y는 잔차\n\npar(mar = c(1, 1, 1, 1))  # 그림 주위의 여백 조정. par; parameter. mar; margin (상, 우, 하, 좌)\n\nplot(x, y1, type = \"p\", pch = 20, axes=F, xlim = c(-0.03, 1.02), ylim = c(0, 5), xlab = \"x\",  ylab = \"y\")\n# pch; point character. 20; 꽉차고 작은 둥근 점. axes=F; 축 눈금이 없다\nabline(0,0, v=-0.04, col = \"black\")  # y 축을 대신할 선을 그린다. v; vertical line. (h는 수평선)\nabline(1, 3, col = \"blue\", lwd=2) \ntext(1.05, -0.1, \"x\")                # 그래프 안에 좌표로 텍스트를 넣을 위치를 표시\ntext(-0.06, 1.1, \"e\")\ntext(-0.06, -0.1, \"0\")\n\n\n\n\n\nFigure 12.8: 잔차의 선형성 검토 (산포도)\n\n\n\n\n\n\nCode\nx &lt;- seq(from = 0, to = 1, length.out = 301)   # 0부터 1까지 501개 등간 숫자 생성\ny &lt;- rnorm(301, mean=0, sd=0.3)                # 평균 0, 표준편차 0.3인 정규분포 난수를 501개 생성\ny1 &lt;- 2.3 + 3*x +y       # y=1+0.5*x+y  맨뒤 y는 잔차\n\npar(mar = c(1, 1, 1, 1))  # 그림 주위의 여백 조정. par; parameter. mar; margin (상, 우, 하, 좌)\n\nplot(x, y1, type = \"p\", pch = 20, axes=F, xlim = c(-0.03, 1.02), ylim = c(-1, 6), xlab = \"x\",  ylab = \"y\")\n# pch; point character. 20; 꽉차고 작은 둥근 점. axes=F; 축 눈금이 없다\nabline(0,0, v=-0.04, col = \"black\")  # y 축을 대신할 선을 그린다. v; vertical line. (h는 수평선)\nabline(2.3,3, col = \"blue\", lwd=2) \npoints(x, y, pch=20, col=\"purple\")\ntext(1.05, -0.15, \"x\")                # 그래프 안에 좌표로 텍스트를 넣을 위치를 표시\ntext(-0.06, 0.8, \"e\", col=\"purple\")\ntext(-0.06, -0.1, \"0\")\ntext(-0.06, 6, \"y\")\n\n\n\n\n\nFigure 12.9: 잔차의 선형성 검토: 비교\n\n\n\n\n\n\n12.5.3 정규성 검토\n오차항의 분포가 정규분포를 이루어야 선형회귀 모형을 적용할 수 있습니다. Figure 12.7 처럼 x값에 따라 옆으로 퍼져 있는 잔차를 X에 상관하지 않고 잔차 자체의 크기 순서로 늘어놓으면, 빈도 분포가 아래처럼 정규분포와 유사한 형태를 이루어야 합니다. (높이를 해당 잔차의 빈도로 해석해주세요.)\n\n\nCode\nlx &lt;- 41                        # x의 갯수 (간격)\ns &lt;- seq(-4, 4, length.out=lx)\np &lt;- dnorm(s, mean=0, sd=2)       \n\nx &lt;- c()\ny &lt;- c()\n\nfor (i in 1:lx) {\n  \nk &lt;- p[i] %/% 0.02  # 나눈 몫\n\nx &lt;- c(x, rep(s[i], times=k) )   # y 갯수만큼 x를 생성\ny &lt;- c(y, runif(k)*p[i] )        # y를 상대도수 갯수만큼 랜덤하게 생성\n}\n\nfor (i in 1:length(x)){        # x 값을 좌우로 약간씩 변형해서 그래프를 보기 좋게\n    x[i] &lt;- x[i] + runif(1)*0.1   # runif(1) ; 0과 1 사이의 숫자를 1개 생성\n}\n\npar(mar = c(1, 1, 1, 1))  # 그림 주위의 여백 조정. par; parameter. mar; margin (상, 우, 하, 좌)\n\nplot (x,y, pch=20, axes=F, ylim = c(-0.007, 0.2), xlab = \"\",  ylab = \"\")    # axes=F; 축 없애기\nabline (0,0)                    # x 축 그리기\nlines(s,p,type=\"l\")             # 정규분포 곡선 넣기\ntext(4, -0.005, \"e\")           # 그래프 안에 좌표로 텍스트를 넣을 위치를 표시\ntext(0, -0.005, \"0\")\n\n\n\n\n\nFigure 12.10: 잔차의 정규성 검토\n\n\n\n\n\n\n12.5.4 등분산성 검토\n잔차는 \\(\\hat Y_i\\)에 대해서 \\(\\epsilon_i\\)의 분포가 동일한 분산을 가져야 한다는 가정을 충족해야 합니다.\n\n\nCode\npar(mfrow=c(1,2), mar = c(2, 4, 1, 2) + 1) # 그래프 영역을 1x2로 분할, 여백과 크기를 조정\n\nx &lt;- seq(from = 0, to = 1, length.out = 101)   # 0부터 1까지 101개 등간 숫자 생성\ny &lt;- rnorm(101, mean=0, sd=0.3)              # 평균 0, 표준편차 0.3인 정규분포 난수를 501개 생성\n\npar(mar = c(1, 1, 1, 1))  # 그림 주위의 여백 조정. par; parameter. mar; margin (상, 우, 하, 좌)\n\nplot(x, y, type = \"p\", pch = 20, xlim = c(-0.04, 1.02), ylim = c(-1.3, 1.3), axes=F, xlab = \"\",  ylab = \"\")\n                # pch; point character. 20; 꽉차고 작은 둥근 점. axes=F; 축 눈금이 없다\nabline(0,0, v=-0.04, col = \"black\")  # y 축을 대신할 선을 그린다. v; vertical line. (h는 수평선)\ntext(1.05, -0.1, \"Y\")                # 그래프 안에 좌표로 텍스트를 넣을 위치를 표시\ntext(-0.06, 1.3, \"e\")\nabline(0, 0, h = 0.6, col=\"blue\")\nabline(0, 0, h = -0.6, col=\"blue\")\n\nx1 &lt;- seq(from = 0, to = 1, length.out = 101)   # 0부터 1까지 501개 등간 숫자 생성\ny1 &lt;- rnorm(101, mean=0, sd=0.3)                # 평균 0, 표준편차 0.3인 정규분포 난수를 501개 생성\n\nfor (i in 1: 101) {\n  y1[i] &lt;- y1[i]/4 + y[i]*(i/50)\n  }\n  \npar(mar = c(1, 1, 1, 1))  # 그림 주위의 여백 조정. par; parameter. mar; margin (상, 우, 하, 좌)\n\nplot(x1, y1, type = \"p\", pch = 20, xlim = c(-0.04, 1.02), ylim = c(-1.3, 1.3), axes=F, xlab = \"\",  ylab = \"\")\n# pch; point character. 20; 꽉차고 작은 둥근 점. axes=F; 축 눈금이 없다\nabline(0,0, v=-0.04, col = \"black\")  # y 축을 대신할 선을 그린다. v; vertical line. (h는 수평선)\ntext(1.05, -0.1, \"Y\")                # 그래프 안에 좌표로 텍스트를 넣을 위치를 표시\ntext(-0.06, 1.3, \"e\")\nabline(0, 1, col=\"blue\")\nabline(0, -1, col=\"blue\")\n\n\n\n\n\nFigure 12.11: 잔차의 등분산성 검토\n\n\n\n\n왼쪽은 \\(\\hat Y_i\\)에 대해서 \\(e_i\\)가 등분산이지만, 오른쪽은 \\(\\hat Y_i\\)값이 커지면서 \\(e_i\\)의 분산도 커지므로 등분산 가정을 충족하지 못합니다. 몸무게와 키의 관계를 회귀분석할 때, 몸무게가 클수록 키가 커지니까 오차의 분산도 증가하는 경향을 보이는데 그게 오른쪽 그래프의 경우와 유사합니다.\n\n\n12.5.5 독립성 검토\n잔차들이 서로 독립적이어야 선형 회귀모델이 가능합니다. 무언가 서로 연관이 있어 보이는지 산포도로 확인해봅니다. 만일 잔차들이 자기상관 autocorrelation 이 있다면, 즉 어떤 식으로든 서로 연관이 있다면 선형 회귀모델의 가정은 충족하지 않습니다.\n잔차 \\(e_i\\)가 있을 때, 자기 앞의 잔차가 그 전 것보다 증가했고 자신도 증가했는데 자기 뒤의 잔차도 증가한다면, 그건 자기상관성의 가능성이 있는 겁니다. 감소하는 경우도 마찬가지입니다. 그런 경우가 많다면 독립성의 가정은 성립하지 않고 따라서 선형 회귀분석을 사용하지 못합니다.\n자기상관은 더빈-왓슨 Durbin-Watson 검정통계량 \\(d\\)을 사용해서 검정할 수 있습니다.\n\\[ d=\\frac{\\sum_{t=2}^{n}(e_t-e_{t-1})^2}{\\sum_{t=1}^{n} e_t^2}, \\; \\; e_t=y_t-\\hat y_t  \\]\n더빈-왓슨의 \\(d\\)는 0 부터 4 의 값을 가집니다. 2 보다 작으면 양의 자기상관이고, 2 보다 크면 음의 자기상관입니다. 2에 가까울수록 자기상관이 없습니다.\n\n# DW 계수 계산\nresult &lt;- lm(y ~ x, data = 데이터_이름)            # 회귀 모형\nresiduals &lt;- residuals(result)                   # 잔차 추출\ndw_coefficient &lt;- sum(diff(residuals)^2) / sum(residuals^2)  # DW 계수 계산\ndw_coefficient\n\n\nExample 12.4  \n\n앞서 나왔던 옷가게 손님의 키와 무게의 상관계수 계산 데이터를 이용해서 단순회귀식을 계산해봅시다.\n\n\n\n키 &lt;- c(162, 158, 160, 168, 150, 154, 160, 166, 170, 146)\n무게 &lt;- c(55, 52, 60, 58, 50, 67, 56, 66, 72, 51)\n\nm &lt;- lm(무게 ~ 키)\nm\n\n\nCall:\nlm(formula = 무게 ~ 키)\n\nCoefficients:\n(Intercept)           키  \n   -37.0470       0.6007  \n\n\n답: 회귀식: 무게 = -37.047 + 0.6 * 키 (\\(\\alpha=-37.047, \\; \\beta=0.6\\))\n\nExample 12.5  \n\nmtcars 데이터셋을 사용하여 단순회귀분석을 해봅시다. 마력 hp가 연료효율 mpg에 주는 영향을 분석합니다.\n\n\n\nresult.car &lt;- lm(mpg ~ hp, data = mtcars)\nsummary(result.car)\n\n\nCall:\nlm(formula = mpg ~ hp, data = mtcars)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-5.7121 -2.1122 -0.8854  1.5819  8.2360 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 30.09886    1.63392  18.421  &lt; 2e-16 ***\nhp          -0.06823    0.01012  -6.742 1.79e-07 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.863 on 30 degrees of freedom\nMultiple R-squared:  0.6024,    Adjusted R-squared:  0.5892 \nF-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n\n\n\nCode\n# 회귀계수의 출력 (y절편과 기울기)\n# (앞의 코드청크를 실행해서 result.car가 형성되어 있어야 한다)\ncoef(result.car)\n\n\n(Intercept)          hp \n30.09886054 -0.06822828 \n\n\nCode\n# 산포도에 회귀선을 추가\nlibrary(ggplot2)\nggplot(mtcars, aes(hp, mpg)) +\n      geom_point() + \n      geom_abline(aes(intercept = coef(result.car)[1], slope = coef(result.car)[2]),\n                colour = \"red\")\n\n\n\n\n\nFigure 12.12: ?(caption)\n\n\n\n\n위의 결과인 result.car를 바탕으로 앞에서 나온 것들의 값을 구한다면,\n\n회귀계수:\n\n절편 = 30.09886, (p &lt; 0.000)\n회귀계수 = -0.06823 (p &lt; 0.000)\n\n\nCoefficients:\n            Estimate   Std. Error  t value    Pr(&gt;|t|)    \n(Intercept) 30.09886     1.63392    18.421    &lt; 2e-16 *** \nhp          -0.06823     0.01012  -6.742     1.79e-07 ***\n회귀계수: $\\alpha=$ `r result.car$coefficients[1]`, $\\beta=$ `r result.car$coefficients[[2]`\n\n회귀계수의 신뢰구간\n\n절편: 30.09886 \\(\\pm\\) 1.63392 * 18.421\n회귀계수: -0.06823 \\(\\pm\\) -6.742 * 0.01012\n\n\nStd. Error   t value  \n1.63392       18.421 \n0.01012       -6.742 \n\n유의성 검토:\n\nF = 45.46 (자유도 1, 30), p &lt; 0.000\n\n\nF-statistic: 45.46 on 1 and 30 DF,  p-value: 1.788e-07\n\n추정의 표준오차 ( Figure 12.7 의 잔차의 표준편차를 말합니다.)\n\n추정의 표준오차: 3.863\n\n\nResidual standard error: 3.863\n\\(s= \\sqrt{MSE} = \\sqrt{14.92}\\) = 3.862642 (MSE 14.92는 아래분산분석표에 있다.)\n\n결정계수:\n\n결정계수 \\(R^2\\) =0.6024, 조정결정계수 \\(R^2\\) = 0.5892\n\n\nMultiple R-squared:  0.6024,    Adjusted R-squared:  0.5892\n\n분산분석표: anova 함수를 사용한다\n\n\n분산분석표 &lt;- anova(result.car)\n분산분석표\n\nAnalysis of Variance Table\n\nResponse: mpg\n          Df Sum Sq Mean Sq F value    Pr(&gt;F)    \nhp         1 678.37  678.37   45.46 1.788e-07 ***\nResiduals 30 447.67   14.92                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n요인\n자유도\n제곱합\n제곱평균\n\\(F\\)\n\\(p\\)\n\n\n\n\n회귀\n1\n678.37\n678.37\n45.46\n1.788e-07\n\n\n잔차\n30\n447.67\n14.92\n\n\n\n\n계\n31\n1126.04\n\n\n\n\n\n\n\n참고\n\n\n\n\n\n\n\n\n\n\n\n\n요인\n자유도\n제곱합\n제곱평균\n\\(F\\)\n\\(p\\)\n\n\n\n\n회귀\n1\n\\(SSR=\\sum(\\hat Y_i-\\bar Y)^2\\)\n\\(MSR=\\frac{SSR}{1}\\)\n\\(\\frac{MSR}{MSE}\\)\n\n\n\n잔차\n\\(n-2\\)\n\\(SSE=\\sum(Y_i-\\hat Y_i)^2\\)\n\\(MSE=\\frac{SSE}{n-2}\\)\n\n\n\n\n계\n\\(n-1\\)\n\\(SST=\\sum(Y_i-\\bar Y)^2\\)\n\n\n\n\n\n\n\n앞 5 장의 선형회귀분석모델 부분을 참고해 보세요.\n\n\nExample 12.6  \n\n위의 결과에서 마력 hp가 200일 때, 연료효율 mpg는 얼마로 예측할 수 있을까요?\n\n\n답:\n16.45286, 위의 회귀식에 대입하여 계산 mpg= 30.09886 + (- 0.06823)* hp = 16.45286\n\nExample 12.7  \n\nhp가 400일 때, mpg는 얼마로 예측할 수 있을까요?\n\n\n답:\n\nrange(mtcars$hp)\n\n[1]  52 335\n\n\n독립변수인 hp의 변수값 범위가 52-335이므로 400은 여기서 벗어난다. 회귀분석에서 기존 데이터의 범위를 벗어난 예측 extrapolation 은 정확도와 신뢰도가 떨어지므로 바람직하지 않다. 부득이 하지 않다면 하지 않는 것이 좋다."
  },
  {
    "objectID": "linear-regression.html#다중회귀분석",
    "href": "linear-regression.html#다중회귀분석",
    "title": "12  선형 회귀분석",
    "section": "12.6 다중회귀분석",
    "text": "12.6 다중회귀분석\n\n12.6.1 다중회귀 회귀계수\n단순회귀분석은 종속변수와 독립변수가 각각 하나씩 있습니다. 다중회귀분석은 종속변수는 여전히 하나지만 독립변수는 여러 개가 있습니다. 그러나 단순회귀분석에서 다룬 개념과 이론들은 여전히 다중회귀분석에도 유사하게 적용이 됩니다.\n다중회귀모형도 아래 식처럼 표현합니다. \\(Y_{i}\\)는 \\(Y\\)의 \\(i\\)번째 관찰값이고 \\(X_1\\)과 \\(X_2\\)는 각각 별도의 독립변수이고 \\(\\beta\\)와 \\(\\gamma\\)는 거기에 대응하는 회귀계수입니다.\n\\[ {\\displaystyle Y_{i}=\\alpha+\\beta X_{1}+\\gamma X_{2}+\\epsilon_{i}} \\; , \\epsilon \\sim N(0,\\sigma^2) \\]\n종속변수 \\(Y\\)의 기댓값은;\n\\[ E(Y_i)= \\alpha+\\beta X_{1}+\\gamma X_{2} \\]\n\\(\\alpha\\), \\(\\beta\\), \\(\\gamma\\)의 추정값을 \\(a\\), \\(b\\), \\(c\\)라고 하면 추정회귀방정식은\n\\[\\displaystyle {\\hat {Y}}_{i}=\\alpha+\\beta X_1+\\gamma X_2 \\]\n위의 방정식을 가지고 최소제곱법으로 \\(a\\), \\(b\\), \\(c\\)를 각각 구합니다.\n\n\n12.6.2 다중회귀 분산분석표\n여기서도 분산분석표 analysis of variance table 는 제곱합 \\(SS\\); sum of squares 과 자유도, 제곱평균\\(MS\\); mean square, \\(F\\)값 등을 표로 나타낸 것입니다. 각 요소들의 관계를 한 눈에 살필 수 있습니다. \\(K\\)는 독립변수의 수입니다.\n\n다중회귀분산분석표\n\n\n\n\n\n\n\n\n\n\n요인\n자유도\n제곱합\n제곱평균\n\\(F\\)\n\\(p\\)\n\n\n\n\n회귀\n\\(k\\)\n\\(SSR=\\sum(\\hat Y_i-\\bar Y)^2\\)\n\\(MSR=\\frac{SSR}{1}\\)\n\\(\\frac{MSR}{MSE}\\)\n\n\n\n잔차\n\\(n-1-k\\)\n\\(SSE=\\sum(Y_i-\\hat Y_i)^2\\)\n\\(MSE=\\frac{SSE}{n-2}\\)\n\n\n\n\n계\n\\(n-1\\)\n\\(SST=\\sum(Y_i-\\bar Y)^2\\)\n\n\n\n\n\n\n\\(MSE\\)는 오차 분산 \\(\\sigma_{\\epsilon}^{2}\\) 의 불편 추정량 unbiased estimator 입니다.\n여기서 나오는 \\(F\\)값과 그에 대응하는 \\(p\\)값은 회귀모형의 유의성 검정에 사용합니다.\n\nknitr::kable 함수를 이용해서 분산분석표를 직접 그려봅시다.\n\n\n다중회귀.결과 &lt;- lm(formula = Sepal.Length ~ Sepal.Width + Petal.Length, data = iris, )\n다중회귀.표 &lt;- anova(다중회귀.결과)\nknitr::kable(다중회귀.표, align = 'c')\n\n\n\nTable 12.4: 분산분석표 Sepal.Length에 대한 다중회귀분석\n\n\n\nDf\nSum Sq\nMean Sq\nF value\nPr(&gt;F)\n\n\n\n\nSepal.Width\n1\n1.412238\n1.412238\n12.71369\n0.0004902\n\n\nPetal.Length\n1\n84.427332\n84.427332\n760.05861\n0.0000000\n\n\nResiduals\n147\n16.328764\n0.111080\nNA\nNA\n\n\n\n\n\n\n\n\n12.6.3 다중회귀 결정계수\n결정계수는 회귀식이 독립변수와 종속변수 간의 관계를 잘 설명하는 정도를 보여주는 척도입니다. 다중회귀모형의 결정계수는 아래의 공식으로 얻어집니다. 단순회귀모형과 동일합니다.\n\\[ R^2=\\frac{SSR}{SST} = 1 - \\frac{SSE}{SST}\\]\n결정계수의 제곱근을 상관계수라고 합니다. 상관계수 \\(R=\\sqrt{R^2}\\)\n단순회귀모형과 달리 다중회귀모형의 결정계수는 문제가 있습니다. 독립변수의 수가 늘어날수록 \\(SSE\\)는 감소하는데 \\(SST\\)는 그대로 있으므로, 독립변수의 수가 결정계수의 값을 증가시키기 때문입니다. 독립변수의 수가 많아지면 모형도 복잡해지고 효율성도 감소하며, 무엇보다도 독립변수 사이의 상관관계가 높아지게 되어 회귀계수의 해석이 어려워집니다. 독립변수 사이의 상관관계는 다중공선성 문제라고 하여 회귀분석에서 가능하다면 피해야 하므로 독립변수의 수가 많아지는 게 꼭 좋은 일은 아닙니다. 그래서 독립변수의 수를 고려해서 결정계수를 다소 조정한 것이 조정결정계수 adjusted coefficient of multiple determination 입니다. 조정결정계수의 공식은 아래와 같습니다.\n\\[ R^2=1-\\frac{n-1}{n-k-1}(\\frac{SSE}{SST})  \\]\n독립변수가 하나 늘어나면 \\(k\\)가 1 증가하므로 분모가 증가합니다. 따라서 \\(SSE\\)가 상응하는 만큼 줄어들지 충분히 줄어즐지 않는다면 \\(R^2\\)은 작아집니다. 독립변수를 추가해도 추가 설명력이 약하다면 조정결정계수는 오히려 감소하므로 다중회귀모형에서 독립변수를 추가할 때 조정결정계수를 잘 살펴서 판단하는 것이 좋습니다.\n\n\n12.6.4 다중회귀 유의성 검정\n회귀모형의 유의성은 독립변수가 종속변수에 정말로 영향을 미치는지 검정하는 겁니다. 유의성을 검토하는 절차는 아래와 같습니다.\n\n가설을 세운다  \\(H_0: \\beta_1 = \\beta_2 = \\cdots =\\beta_k = 0\\) 모든 회귀계수는 0이다.  \\(H_A: \\beta_j \\ne 0\\) 회귀계수 중에 적어도 하나는 0이 아니다. \n유의수준을 결정한다\n검정통계량을 계산한다 \\[ F_0= \\frac{MSR}{MSE} \\gt F_{\\alpha , (1,n-2)} \\]\n임곗값과 비교하여 결정한다\n\n다중회귀모형이 유용한가는 유의성 검정만으로 결정하는 것이 아니라 결정계수, 추정의 표준오차 등을 복합적으로 살핀 후에 결정하는 것이 바람직합니다.\n\n\n12.6.5 다공선성\n다중회귀모형에서 독립변수 또는 설명변수가 여러 개일 때 다공선성의 문제가 발생하기 쉽습니다. 다중공선성 multicollinearity 은 독립변수 사이에 높은 상관관계가 있을 때 모형의 추정에 나쁜 영향을 주는 문제를 말합니다. 따라서 다중회귀모형을 수립할 때 독립변수의 추가는 가능한 한 적은 것이 바람직하며 신중하게 판단해야 합니다. 다음의 경우에 다중공선성이 발생하기 쉽습니다.\n\n독립변수들 사이의 상관관계가 높게 나타났을 때\n중요하게 생각했던 독립변수의 회귀계수가 유의미하게 나타나지 않았을 때\n추정한 회귀게수의 부호가 이론이나 과거 경험에서 예상했던 것과 반대일 때\n독립변수를 추가하거나 제거했을 때 다른 회귀계수들에게 큰 변화가 있을 때\n다중공선성을 측정하는 분산팽창인자 VIF 의 값이 기준을 넘었을 때\n\n독립변수를 선택할 때 결정계수와 조정결정계수의 증가는 높은 것이 좋고, 평균제곱오차와 멜로우 C 는 낮은 것이 좋습니다.\n\\[MSE_k=\\frac{SSE_l}{n-k-1}\\] \\[C_p=\\frac{1}{\\hat \\sigma^2}SSE_p-n+2(p+1) \\]\n독립변수의 선택 방법은 아래와 같습니다.\n\n전진선택: 후보 독립변수 중에서 가장 기여가 높은 순서로 하나씩 선택하며 더 이상 선택이 없을 때 멈춘다.\n후진소거: 후보 독립변수를 모두 포함하는 회귀모형에서 출발해서 기여가 낮은 순서로 하나씩 제거한다. 더 이상 제거가 없을 때 멈춘다.\n단계적 회귀: 전진선택과 후진소거를 혼합한 것으로 가장 기여가 높은 순서로 추가하지만 이미 선정했어도 기여가 기준 이하로 내려가면 제거한다.\n모든 가능한 회귀: 가능한 모든 모형을 검토해서 최적의 모형을 찾는다. 독립변수가 \\(k\\)개라면 \\(2^k\\)번 실행하여 검토한다. 할 수 있다면 최선이다.\n\n앞 5 장의 선형회귀분석모델 부분을 잠깐 다시보기 해보세요.\n\nExample 12.8  \n\nmtcars 데이터셋을 사용하여 다중회귀분석을 해봅시다. 마력 hp와 무게 wt가 연료효율 mpg에 주는 영향을 봅니다.\n\n\n회귀식을 구하세요.\n이 회귀식이 의미가 있을까요?\n각 독립변수 hp와 wt가 종속변수 mpg에 영향을 줄까요?\n\n\n\nresult2.car &lt;- lm(mpg ~ hp + wt, data = mtcars)\nsummary(result2.car)\n\n\nCall:\nlm(formula = mpg ~ hp + wt, data = mtcars)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-3.941 -1.600 -0.182  1.050  5.854 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 37.22727    1.59879  23.285  &lt; 2e-16 ***\nhp          -0.03177    0.00903  -3.519  0.00145 ** \nwt          -3.87783    0.63273  -6.129 1.12e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.593 on 29 degrees of freedom\nMultiple R-squared:  0.8268,    Adjusted R-squared:  0.8148 \nF-statistic: 69.21 on 2 and 29 DF,  p-value: 9.109e-12\n\n\n답:\n\n회귀식: mpg = 37.22727 + (-0.03177) * hp + (-3.87783) * wt\n이 회귀식 모델의 F값은 69.21 이고 이때 p=0.000 &lt; 0.05 이므로 의미가 있다.\nhp의 회귀계수가 -0.03177 이고 그에 해당하는 t 값은 -3.519, p값은 0.00145다. p값이 0.025(\\(\\alpha=0.05\\) ; 양측검정)보다 적으므로 hp의 회귀계수가 0이라는 귀무가설을 기각한다.  따라서 hp의 회귀계수가 0이 아니라는 대립가설을 채택한다. hp의 mpg에 대한 영향은 통계적으로 유의미하다.\n\n또한 wt의 회귀계수가 -3.87783 이고 그에 해당하는 t 값은 -6.129, p값은 0.000이다. p값이 0.025(\\(\\alpha=0.05\\) ; 양측검정)보다 적으므로 wt의 회귀계수가 0이라는 귀무가설을 기각한다.  따라서 wt의 회귀계수가 0이 아니라는 대립가설을 채택한다. wt의 mpg에 대한 영향은 통계적으로 유의미하다.\n\n\n\n\n\n\n결과에 나타난 용어의 의미\n\n\n\n위 회귀분석 결과의 Coefficients:에서 나타난 용어 estimate와 Std. error, t value를 주목해주세요. 그것들을 이용해서 confidence interval을 계산할 줄 알아야 합니다. 이 용어들은 9 장의 점 추정과 구간 추정에서 배웠습니다. 거기에 가서 다시 한 번 읽어보세요.\n\n\n회귀계수의 구간 추정은 confint(결과_변수) 함수를 사용할 수 있지만 신뢰수준을 달리 줄 수 있으므로 직접 계산할 수도 있어야 합니다.\n\n\n12.6.6 교호작용\n교호작용은 독립변수가 상호작용을 하며 종속변수에 미치는 영향을 말합니다. 예를 들어, 독립변수 hp와 wt, 종속변수 mpg가 있다고 합시다. hp가 10마력일 때 wt가 mpg에 5만큼 영향을 주고 (즉 wt 회귀계수가 5), hp가 20마력일 때도 여전히 wt가 5만큼 영향을 준다면 (즉 여전히 wt 회귀계수가 5) 교호작용 효과가 없는 것입니다.\n그러나 hp가 10마력일 때는 wt가 mpg에 5만큼 영향을 주지만, hp가 20마력일 때는 wt가 10만큼 영향을 준다면 교호작용 효과가 있는 것입니다. 즉 hp가 늘어날수록 wt가 mpg에 주는 영향이 늘어나거나 줄어들면 교호작용 효과가 있는 것이고, hp의 크기에 관계없이 wt가 mpg에 주는 영향이 같다면 교호작용이 없는 것입니다.\n\nExample 12.9  \n\n위의 회귀분석을 교호작용을 넣어서 회귀분석을 합니다.\n\n\n\nresult3.car &lt;- lm(mpg ~ hp + wt + hp:wt, data = mtcars)\n  # lm(mpg ~ hp*wt, data = mtcars)도 위와 동일한 코딩\nsummary(result3.car)\n\n\nCall:\nlm(formula = mpg ~ hp + wt + hp:wt, data = mtcars)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.0632 -1.6491 -0.7362  1.4211  4.5513 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) 49.80842    3.60516  13.816 5.01e-14 ***\nhp          -0.12010    0.02470  -4.863 4.04e-05 ***\nwt          -8.21662    1.26971  -6.471 5.20e-07 ***\nhp:wt        0.02785    0.00742   3.753 0.000811 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.153 on 28 degrees of freedom\nMultiple R-squared:  0.8848,    Adjusted R-squared:  0.8724 \nF-statistic: 71.66 on 3 and 28 DF,  p-value: 2.981e-13\n\n\n답:\nhp와 wt가 각각 종속변수 mpg에 통계적으로 유의미한 효과를 줍니다. 교호작용 효과도 통계적으로 유의미하게 나타나서 hp와 wt의 효과의 크기인 회귀계수가 (교호작용 포함 전과) 달라졌습니다.\n교호작용의 호귀계수는 0.02785이고 그에 해당하는 t값이 3.753, p값이 0.000811입니다. p&lt;0.025(\\(\\alpha=0.05\\) 양측검정)이므로 교호작용의 회귀계수가 0이라는 귀무가설을 기각합니다. 따라서 교호작용의 회귀계수가 0이 아니라는 대립가설을 채택합니다. hp와 wt의 교호작용이 mpg에 대한 영향은 통계적으로 유의미합니다.\n\nExercise 12.1  \n\nairquality 데이터에서 Ozone를 종속변수로 하고 Solar.R, Wind, Temp를 독립변수로 하여 회귀분석을 하세요. 변수 간의 산포도와 상관계수를 참고하세요.\n\n\n해답 보기"
  },
  {
    "objectID": "solutions.html#sec-sol-pro",
    "href": "solutions.html#sec-sol-pro",
    "title": "13  해답",
    "section": "8 장",
    "text": "8 장\n\n해답 Exercise 8.1\n\n{1, 2, 3, 4, 5, 6}\n{1, 2}\n\\(f(x)=\\frac{1}{6}x\\)\n\n예) 만일 \\(x가\\) 3이면 1, 2, 3 이 나올 때 3보다 적거나 같다. 따라서 \\(\\frac{1}{6}*3=\\frac{1}{2}\\)이 답이 된다.\n\n\n해답 Exercise 8.2\n\n답\n\n\nn&lt;-12\nx&lt;-7\np&lt;-0.5\n\nans1 &lt;- dbinom(7,12,0.5)                #함수 이용\nans2 &lt;- choose(n,x)*p^x*(1-p)^(n-x)     #공식 이용\n\n확률은 0.1933594\n확률은 0.1933594\n확률은 `r ans1`  # 둘 중 하나를 사용하면 됩니다. \n확률은 `r ans2`\n\n답\n\n\n## μ =  6\n## σ =  1.732051\n\n# 그리스 문자를 넣은 방법\ncat(\"\\u03BC = \", 3)   # mu를 나타내는 유니코드\ncat(\"\\u03C3 = \", x)   # sigma를 나타내는 유니코드\n     # {r collapse=TRUE} 옵션을 넣으면 두 줄이 붙어서 나온다.\n\\(\\mu\\)=6, \\(\\sigma\\)= 1.7320508\n\n\n해답 Exercise 8.3\n\nx &lt;-seq(-5, 11, length = 500)   # x의 최소값 최대값을 평균에서 각각 표준오차의 4배 먼 곳으로 잡는다.\ny_p &lt;- pnorm(x, mean = 3, sd = 2)  # 누적확률함수\ny_d &lt;- dnorm(x, mean = 3, sd = 2)  # 확률밀도함수\n\nplot(x, y_d, type = \"l\", col = \"blue\", xlab = \"x\", ylab= \"확률\", ylim = c(0.03, 1.01), main = \"누적확률함수(빨강), 확률밀도함수(파랑)\")\nlines(x, y_p, type = \"l\", col = \"red\")\n\n\n\n\n\n\n해답 Exercise 8.4\n\nm=3\nsd=2\ndf1=30\ndf2=4\n\nt &lt;-seq(-4, 4, length = 500)   # t값의 최소값 최대값을 평균에서 각각 표준오차의 4배 먼 곳으로 잡는다.\ny1 &lt;- dt(t, df =30)            # t값에 해당하는 확률인 y1을 구한다\nx1 &lt;- t * sd + m               # t값을 원래 관찰값인 x1값으로 바꾼다. \n\ny2 &lt;- dt(t, df =4)             # t값에 해당하는 확률인 y2을 구한다\nx2 &lt;- t * sd + m               # t값을 원래 관찰값인 x2값으로 바꾼다. \n\nplot(x1, y1, type = \"l\", col = \"red\", lwd = 2.0, main = \"자유도 30 (빨강), 자유도 4 (녹색)\")\nlines(x2, y2, type = \"l\", lwd = 2.0, col = \"green\")\n\n\n\n\n\n\n해답 Exercise 8.5\n\n# 정규분포\n표본평균_평균 &lt;- 3\n표준오차 &lt;- 2/sqrt(36)\n\n# 표준정규분포의 z값과 y값을 구한다. \nz &lt;-seq(-4, 4, length = 500)\nf &lt;- dnorm(z, mean = 0, sd = 1)\n\nx &lt;- z * 표준오차 + 표본평균_평균      # t값을 원래 관찰값인 x1값으로 바꾼다. \n\n  # X\\u0305 는 bar를 넣는 유니코드\nplot(x, f, type = \"l\", col = \"blue\", lwd = 2.0, xlab = \"표본평균 X\\u0305\", ylab = \"확률 f(X\\u0305)\", main = \"표본 평균의 표집분포\")   \n\n\n\n\n\n\n해답 Exercise 8.6\n\n# t 분포\nn &lt;- 16  #표본 크기\n표본평균 &lt;- 3   #표본 평균\n표본표준편차 &lt;- 2  #표본 표준편차\n자유도 &lt;- n-1  #자유도\n표본평균_평균 &lt;- 표본평균\n표준오차 &lt;- 2/sqrt(n)  # 표본평균의 표준편차\n\n#t값과 그에 해당하는 확률을 구한다\nt &lt;-seq(-4, 4, length = 500)\nf &lt;- dt(t, 자유도)\n\nx &lt;- t * 표준오차 + 표본평균_평균  # t값에 해당하는 관찰값 x를 구한다\n\n  # X\\u0305 는 bar를 넣는 유니코드\nplot(x, f, type = \"l\", col = \"blue\", lwd = 2.0, xlab = \"표본평균 X\\u0305\", ylab = \"확률 f(X\\u0305)\", main = \"표본 평균의 표집분포 (평균=3, 자유도=15)\")   \n\n\n\n\n\n\n해답 Exercise 8.7\n\n# 정규분포\n평균차이_평균 &lt;- -0.15\n표준오차 &lt;- 0.047\n\n# 확률을 구한다\nz &lt;-seq(-4, 4, length = 500)\nf &lt;- dnorm(z, mean = 0, sd = 1)\n\nx &lt;- z * 표준오차 + 평균차이_평균      # t값을 원래 관찰값인 x1값으로 바꾼다. \n\n# X\\u0305 는 bar를 넣는 유니코드\nplot(x, f, type = \"l\", col = \"blue\", lwd = 2.0, xlab = \"평균차이 X\\u0305-X\\u0305\", ylab = \"확률\", main = \"평균차이의 표집분포\")"
  },
  {
    "objectID": "solutions.html#sec-sol-reg",
    "href": "solutions.html#sec-sol-reg",
    "title": "13  해답",
    "section": "12 장",
    "text": "12 장\n\n해답 Exercise 12.1\n\npairs(airquality[1:4])\n\n\n\ncor_matrix &lt;- cor(airquality[, 1:4], use= \"pairwise\")\nround(cor_matrix, digits = 2)\nlm &lt;- lm(Ozone ~ Solar.R + Wind + Temp, data = airquality)\nsummary(lm)\n\n        Ozone Solar.R  Wind  Temp\nOzone    1.00    0.35 -0.60  0.70\nSolar.R  0.35    1.00 -0.06  0.28\nWind    -0.60   -0.06  1.00 -0.46\nTemp     0.70    0.28 -0.46  1.00\n\nCall:\nlm(formula = Ozone ~ Solar.R + Wind + Temp, data = airquality)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-40.485 -14.219  -3.551  10.097  95.619 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept) -64.34208   23.05472  -2.791  0.00623 ** \nSolar.R       0.05982    0.02319   2.580  0.01124 *  \nWind         -3.33359    0.65441  -5.094 1.52e-06 ***\nTemp          1.65209    0.25353   6.516 2.42e-09 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 21.18 on 107 degrees of freedom\n  (42 observations deleted due to missingness)\nMultiple R-squared:  0.6059,    Adjusted R-squared:  0.5948 \nF-statistic: 54.83 on 3 and 107 DF,  p-value: &lt; 2.2e-16\n\n\n\n\n\n\n\n\nTip\n\n\n\n위 청크 옵션에 results: hold를 넣었기 때문에 텍스트로 된 결과가 뭉쳐서 나왔습니다.\n\n\n위의 플롯과 상관계수, 회귀분석 결과를 보고 아래의 것들을 구하거나 설명할 수 있어야 합니다.\n\n회귀식\n분산분석표\n회귀 모델의 유의미 여부\n회귀 모델의 결정계수 또는 설명력\n추정의 표준오차\n회귀계수의 표준오차와 신뢰구간\n회귀분석의 독립변인과 종속변인과의 가설 검정\n리스트 형식의 결과 변수에서 요소를 추출"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "14  참고문헌",
    "section": "",
    "text": "posit. (2023). Welcome to Quarto. https://quarto.org\n\n\nThulin, M. (2021). Modern statistics with R. Eos\nChasma Press. https://modernstatisticswithr.com/\n\n\nYihui Xie, G. G., J. J. Allaire. (2019). R Markdown:\nThe definitive guide. Chapman & Hall/CRC. https://bookdown.org/yihui/rmarkdown/"
  }
]